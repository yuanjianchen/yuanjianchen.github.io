<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>并发理论基础：Java 内存模型JMM</title>
      <link href="/post/164995635/"/>
      <url>/post/164995635/</url>
      
        <content type="html"><![CDATA[<p>在<a href="./%E5%B9%B6%E5%8F%91%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%EF%BC%9A%E7%BC%93%E5%AD%98%E5%8F%AF%E8%A7%81%E6%80%A7%E3%80%81MESI%E3%80%81%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C.md">并发理论基础：缓存可见性、MESI、内存屏障</a>一文中分析了缓存可见性导致的并发问题。为了解决缓存可见性问题所以有了缓存一致性协议 <code>MESI</code>，但是<code>MESI</code>的同步等待机制会影响性能，所以用了 storeBuffer 来优化，但是优化过后还是会在一些场景存在可见性问题。这个时候又不能单方面的放弃优化，所以就提供一套内存屏障些指令来让我们的开发人员可以根据自己的场景来决定什么是需要禁用CPU缓存优化来避免可见性问题。</p><p>在<a href="./%E5%B9%B6%E5%8F%91%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%EF%BC%9A%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%E5%BA%8F%E9%97%AE%E9%A2%98.md">并发理论基础：指令重排序问题</a>一文中分析了指令重排序现象引发的并发问题。虽然 CPU 层面通过<code>as-if-serial</code>原则来保证指令集重排乱序执行的结果在单线程场景下结果的正确性。但是<code>as-if-serial</code>原则在多线程场景是行不通的，因为CPU没办法通过指令来辨别多线程中的指令逻辑依赖，所以这个时候CPU和编译器它们也提供了屏障指令来让我们的开发人员可以根据自己的场景来决定什么是需禁止重排序来避免重排序可能导致的并发问题。</p><p>以上我们说的都是计算机硬件方面的实现,但是 JVM 是运行在操作系统层面的，不同的硬件架构的缓存体系不一样，指令重排序的策略不一样，所提供的内存屏障指令也就有差异。而不同的操作系统对于硬件封装的指令集也不同。所以在Java中为了简化开发人员的工作，避免开发人员需要对底层的系统原理理解过分的依赖，所以封装了一套规范，把这些复杂的指令操作与开发人员编码隔离开来，这套规范就是”Java内存模型“。</p><h2 id="Java内存模型">Java内存模型<a class="" href="#Java内存模型"></a></h2><p>JVM 在软件层面上有着和计算机硬件层面上的诸多异曲同工之妙，诸如 CPU 和 JVM 中的程序计数器、JIT 编译器与 CPU 中的指令乱序执行优化等。对于缓存一致性协议<a href="http://www.cs.umd.edu/~pugh/java/memoryModel/">《Java虚拟机规范》</a>中试图定义一种 <strong>Java 内存模型（Java Memory Model，JMM）</strong> 来屏蔽各种硬件和操作系统的内存访问差异，以实现让 Java 程序在各种平台下都能达到一致的内存访问效果。</p><p>JMM规范了Java虚拟机与计算机内存是如何协同工作的:<strong>规定了一个线程如何和何时可 以看到由其他线程修改过后的共享变量的值，以及在必须时如何同步的访问共享变量</strong>。JMM 描述的是一种抽象的概念，一组规则，通过这组规则控制程序中各个变量在共享数据区域和私 有数据区域的访问方式，JMM是围绕原子性、有序性、可见性展开的。</p><blockquote><p>此处的变量（Variables）与 Java 编程中所说的变量有所区别，它包括了<strong>实例字段</strong>、<strong>静态字段</strong>和<strong>构成数组对象的元素</strong>，但不包括局部变量与方法参数，因为后者是虚拟机栈中线程私有的，不会被共享，自然就不会存在竞争问题。</p></blockquote><p>Java内存模型实际上就是规范了 JVM 如何提供按需禁用缓存和重排序优化的方法。其核心就包括<code>volatile</code>、<code>synchronized</code> 和 <code>final</code> 三个关键字，以及几项<code>Happens-Before</code> 规则。有了JMM 作为Java的开发人员只需要使用几个关键字(<code>sychronized</code>，<code>volatile</code>，<code>final</code>) ,并且理解几个<code>happens before</code>规则，就能根据自己的需要来禁用缓存优化和指令重排序，从而避免并发问题。</p><h3 id="JMM内存模型和JVM内存结构之前的区别">JMM内存模型和JVM内存结构之前的区别<a class="" href="#JMM内存模型和JVM内存结构之前的区别"></a></h3><ul><li><p><strong>JVM 内存结构</strong>：是指 JVM 运行时将数据分区域存储，强调对内存空间的划分。</p></li><li><p><strong>JMM 内存模型</strong>：是指线程和主内存之间的抽象关系，即 JMM 中定义了线程在 JVM 主内存中的工作方式，如果要想深入了解 Java 并发编程，就要先理解好 JMM。</p></li></ul><h3 id="JVM中的工作内存和主内存">JVM中的工作内存和主内存<a class="" href="#JVM中的工作内存和主内存"></a></h3><ul><li><p><strong>主内存（Main Memory）</strong>：类比的物理硬件为主内存，实则是指 JVM 内存的一部分。</p></li><li><p><strong>工作内存（Working Memory）</strong>：类比的物理硬件为 CPU 高速缓存，实则是指每条线程都有自己的工作内存，其中保存了被该线程使用到的变量在主内存中的拷贝副本（对于对象实例并不是完全拷贝，而是用到了哪个字段就拷贝哪个）。</p></li></ul><p>线程对变量的所有操作（读取、赋值等）都<strong>必须在工作内存中进行</strong>，而不能直接读写主内存中的变量。不同的线程之间也<strong>无法直接访问对方工作内存中的变量</strong>，线程间变量值的传递<strong>均需要通过主内存来完成</strong>。</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/2022/04/image-20220414235858873.png" alt="JMM控制流程"></p><h2 id="JMM与硬件内存架构的关系">JMM与硬件内存架构的关系<a class="" href="#JMM与硬件内存架构的关系"></a></h2><p>Java内存模型与硬件内存架构之间存在差异。硬件内存架构没有区分线程栈和堆。对于硬件，所有的线程栈和堆都分布在主内存中。部分线程栈和堆可能有时候会出现在CPU缓存中和CPU内部的寄存器中。如下图所示，Java内存模型和计算机硬件内存架构是一个交叉关系:</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/2022/04/image-20220415000708910.png" alt="JMM 与硬件内存架构关系"></p><p>从抽象的角度来看，JMM定义了线程和主内存之间的抽象关系：</p><ul><li>线程之间的共享变量存储在主内存（Main Memory）中</li><li>每个线程都有一个私有的本地内存（Local Memory），本地内存是JMM的一个抽象概念，并不真实存在，它涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器优化。本地内存中存储了该线程以读/写共享变量的拷贝副本。</li><li>从更低的层次来说，主内存就是硬件的内存，而为了获取更好的运行速度，虚拟机及硬件系统可能会让工作内存优先存储于寄存器和高速缓存中。</li><li>Java内存模型中的线程的工作内存（working memory）是cpu的寄存器和高速缓存的抽象描述。而JVM的内存结构只是一种对内存的物理划分而已，它只局限在内存，而且只局限在JVM的内存。</li></ul><h2 id="JMM模型下的线程间通信">JMM模型下的线程间通信<a class="" href="#JMM模型下的线程间通信"></a></h2><p>线程间通信必须要经过主内存。</p><p>如下，如果线程A与线程B之间要通信的话，必须要经历下面2个步骤：</p><p>1）线程A把本地内存A中更新过的共享变量刷新到主内存中去。</p><p>2）线程B到主内存中去读取线程A之前已更新过的共享变量。</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/2022/04/v2-8750cb14ecaa93509e3f1981563513e1_r.jpg" alt="线程间的通讯"></p><p>关于主内存与工作内存之间的具体交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步到主内存之间的实现细节，Java内存模型定义了以下八种操作来完成：</p><ul><li><strong>lock（锁定）</strong>：作用于主内存的变量，把一个变量标识为一条线程独占状态。</li><li><strong>unlock（解锁）</strong>：作用于主内存变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。</li><li><strong>read（读取）</strong>：作用于主内存变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用</li><li><strong>load（载入）</strong>：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。</li><li><strong>use（使用）</strong>：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。</li><li><strong>assign（赋值）</strong>：作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。</li><li><strong>store（存储）</strong>：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作。</li><li><strong>write（写入）</strong>：作用于主内存的变量，它把store操作从工作内存中一个变量的值传送到主内存的变量中。</li></ul><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/2022/04/image-20220415001420504.png" alt="内存模型的八种操作"></p><p>除此之外，Java内存模型还规定了在执行上述8种基本操作时必须满足如下规则：</p><ul><li><p>不允许read和load、store和write操作之一单独出现，即不允许一个变量从主内存读取了但工作内存不接受，或者工作内存发起回写了但主内存不接受的情况出现。</p><blockquote><p>如果要把一个变量从主内存拷贝到工作内存，那就要按顺序执行read和load操作，如果要把变量从工作内存同步回主内存，就要按顺序执行store和write操作。注意，Java内存模型只要求上述两个操作必须按顺序执行，但不要求是连续执行。也就是说read与load之间、store与write之间是可插入其他指令的，如对主内存中的变量a、b进行访问时，一种可能出现的顺序是<code>read a</code>、<code>read b</code>、<code>load b</code>、<code>load a</code>。</p></blockquote></li><li><p>不允许一个线程丢弃它最近的assign操作，即变量在工作内存中改变了之后必须把该变化同步回主内存。</p></li><li><p>不允许一个线程无原因地（没有发生过任何assign操作）把数据从线程的工作内存同步回主内存中。</p></li><li><p>一个新的变量只能在主内存中“诞生”，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量，换句话说就是对一个变量实施use、store操作之前，必须先执行assign和load操作。</p></li><li><p>一个变量在同一个时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。</p></li><li><p>如果对一个变量执行lock操作，那将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load或assign操作以初始化变量的值。</p></li><li><p>如果一个变量事先没有被lock操作锁定，那就不允许对它执行unlock操作，也不允许去unlock一个被其他线程锁定的变量。</p></li><li><p>对一个变量执行unlock操作之前，必须先把此变量同步回主内存中（执行store、write操作）。</p></li></ul><p>这 8 种操作和规则在 <a href="https://gitee.com/yuanjianchen/programming-resources/blob/master/Java/JSR133/JSR133%E4%B8%AD%E6%96%87%E7%89%88.pdf">JSR-133</a> 中并没有被提及，已经放弃采用这 8 种描述去片面地定义 JMM 的访问协议（仅是描述方式改变了），而是由更完备的<strong>先行发生原则（Happens-Before）<strong>和</strong>因果关系</strong>来进行约束。</p><h2 id="Happens-Before-原则">Happens Before 原则<a class="" href="#Happens-Before-原则"></a></h2><p>**先行发生原则（Happens-Before）**是判断数据是否存在竞争、线程是否安全的主要依据，依靠这个原则，我们可以解决并发环境下两个操作之间是否可能存在冲突的所有问题。</p><p>先行发生原则是 JMM 中定义的两项操作之间的偏序关系，例如：操作 A 先行发生于操作 B（即发生在操作 B 之前），则操作 A 产生的影响（包括修改了内存中共享变量的值、发送了消息、调用了方法等）就能被操作B观察到。</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 在线程A中执行</span></span><br><span class="line">i=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在线程B中执行</span></span><br><span class="line">j=i;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在线程C中执行</span></span><br><span class="line">i=<span class="number">2</span>;</span><br></pre></td></tr></tbody></table></figure><p>假设线程 A 先行发生于线程 B（A、B 有先行发生关系），那么在线程 B 执行后变量 <code>j</code> 的值一定等于 <code>1</code>。</p><p>假设线程 C 出现在了线程 A 和线程 B 的操作之间（A、B有先行发生关系），但线程 C 与线程 B 又没先行发生关系的情况下，那变量 <code>j</code> 的值是一个不确定的数，线程 B 就存在读取到过期数据的风险，不具备线程安全性。</p><p>作为开发人员来说，如果不想太深入底层去了解计算机底层的原理，又想编写出正确的并发程序，那么就必须对Happens Before原则加以理解，理解这些原则才能帮助我们避免并发程序的BUG，在出现并发问题后也能马上发现问题的所在。</p><h3 id="程序次序规则（Program-Order-Rule）">程序次序规则（Program Order Rule）<a class="" href="#程序次序规则（Program-Order-Rule）"></a></h3><p>定义：在一个线程中，按照程序代码的执行流顺序，先执行的操作happen—before后执行的操作。</p><p>说明：这个规则的意思就是，在同一个线程中前面的写操作对于后面的读操作来说是可见的。按下面的代码来说，x=1的写入对于flag=true是可见的。</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">boolean</span> flag;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">()</span></span>{</span><br><span class="line">    x=<span class="number">1</span>;       <span class="comment">//这里的值对于后续操作可见</span></span><br><span class="line">    flag=<span class="keyword">true</span>;</span><br><span class="line"> </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="管程锁定规则（Monitor-Lock-Rule）">管程锁定规则（Monitor Lock Rule）<a class="" href="#管程锁定规则（Monitor-Lock-Rule）"></a></h3><p>定义：一个锁的unlock(解锁)操作happen—before后面对该锁的lock(加锁)操作。</p><p>说明：如果线程1解锁了A对象，然后线程2对A进行了加锁操作，那么线程1对共享变量的所有写操作对于线程2是可见的。</p><p>这个逻辑对应到代码里面就如下, write()方法 synchronized 代码块执行完之后（也就是对this对象的解锁操作，synchronized代码执行完自动解锁）的结果，对于 read()方法 进入synchronized 代码块(也就是对this对象的加锁操作)是可见的，也就是 代码2 会看到 x=x+1 的结果。</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x; <span class="comment">//共享变量</span></span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">()</span></span>{</span><br><span class="line">     <span class="keyword">synchronized</span>(<span class="keyword">this</span>){</span><br><span class="line">         x=x+<span class="number">1</span>;  <span class="comment">//代码1</span></span><br><span class="line">     }</span><br><span class="line"> }</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span>{</span><br><span class="line">       <span class="keyword">synchronized</span>(<span class="keyword">this</span>){</span><br><span class="line">          Systemt.out.println(x) <span class="comment">//代码2</span></span><br><span class="line">     }</span><br><span class="line">     </span><br><span class="line"> }</span><br></pre></td></tr></tbody></table></figure><h3 id="Volatile-变量规则（Volatile-Variable-Rule）">Volatile 变量规则（Volatile Variable Rule）<a class="" href="#Volatile-变量规则（Volatile-Variable-Rule）"></a></h3><p>定义：对一个 <code>volatile</code> 变量的 write 操作先行发生（happen—before）于后面（时间上）对这个变量的 read 操作。</p><p>说明：这个规则的是说，如果一个线程先修改了volatile的变量，那么这个操作对于后续其他线程对这个volatile变量读操作是可见的。 如下代码，线程1调用write() 修改了共享变量 x，然后线程2调用了read() 读取x，这个时候线程1 操作 x=1 对于线程2是可见的。</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">volatile</span>  <span class="keyword">int</span> x; <span class="comment">//共享变量</span></span><br><span class="line">     </span><br><span class="line"><span class="comment">//线程1调用write()</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">()</span></span>{</span><br><span class="line">    x=<span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程2调用 read()</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span>{</span><br><span class="line">    System.out.println(x); </span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="线程启动规则（Thread-Start-Rule）">线程启动规则（Thread Start Rule）<a class="" href="#线程启动规则（Thread-Start-Rule）"></a></h3><p>定义：<code>Thread</code> 对象的 <code>start()</code> 方法先行发生（happen—before）于此线程的每一个动作。</p><p>说明：如果A线程调用 B线程的start()方法，那么A线程 在调用B.start()之前对共享变量的所有写操作对于B线程来说都是可见的。</p><p>如下代码，当先运行的线程为线程A，A线程先对共享变量v进行赋值，然后A线程调用B线程start()方法，那么B线程是可以看到v=10的这个操作的。</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">Thread threadB=<span class="keyword">new</span> Thread(()-&gt;{</span><br><span class="line">            System.out.println(v);</span><br><span class="line">        });</span><br><span class="line"></span><br><span class="line">v=<span class="number">10</span>;   <span class="comment">//此操作对于线程B来说是可见的</span></span><br><span class="line">threadB.start(); <span class="comment">//当前线程调用线程B的start()方法</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="线程终止规则（Thread-Termination-Rule）">线程终止规则（Thread Termination Rule）<a class="" href="#线程终止规则（Thread-Termination-Rule）"></a></h3><p>定义：线程中的所有操作都先行发生（happen-before）于对此线程的终止检测（可以通过 <code>Thread.join()</code> 方法结束、<code>Thread.isAlive()</code> 的返回值等手段检测到线程已经终止执行）。</p><p>说明：以join()为例，如果A线程调用B线程的Join()方法，那么当B线程的Join方法返回后，A线程可以看到B线程对共享变量的所有写操作。 以下面代码为例，当前线程调用了threadB的join()方法并返回后，线程设置x=1的操作对于当前线程是可见的。</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x; <span class="comment">//共享变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span>  Exception</span>{</span><br><span class="line"></span><br><span class="line">    Thread threadB=<span class="keyword">new</span> Thread(()-&gt;{</span><br><span class="line">        x=<span class="number">1</span>;</span><br><span class="line">    });</span><br><span class="line"></span><br><span class="line">    threadB.start();</span><br><span class="line">    threadB.join();<span class="comment">//这个操作返回之后，threadB操作 x=1 对于当前线程是可见的</span></span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="线程中断规则（Thread-Interruption-Rule）">线程中断规则（Thread Interruption Rule）<a class="" href="#线程中断规则（Thread-Interruption-Rule）"></a></h3><p>定义：对线程 <code>interrupt()</code> 方法的调用先行发生（ happen—before）于被中断线程的代码检测到中断事件的发生（可以通过 <code>Thread.interrupted()</code> 方法检测到是否有中断发生）。</p><p>说明：线程A调用了线程B的interrupt()方法，那么当线程B触发interrupt之后，线程A对所有共享变量的写操作对于线程B来说都是可见的。</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x; <span class="comment">//共享变量</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span>  Exception</span>{</span><br><span class="line"> </span><br><span class="line">    Thread threadB=<span class="keyword">new</span> Thread(()-&gt;{</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">this</span>.wait();</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            System.out.println(<span class="number">1</span>);<span class="comment">//此处是可以看到 x=1的操作的</span></span><br><span class="line">        }</span><br><span class="line">    });</span><br><span class="line"> </span><br><span class="line">    threadB.start();</span><br><span class="line">    x=<span class="number">1</span>;<span class="comment">//修改共享变量</span></span><br><span class="line">    threadB.interrupt();<span class="comment">//调用threadB中断方法</span></span><br><span class="line"> </span><br><span class="line">}</span><br><span class="line"> </span><br></pre></td></tr></tbody></table></figure><h3 id="对象终结规则（Finalizer-Rule）">对象终结规则（Finalizer Rule）<a class="" href="#对象终结规则（Finalizer-Rule）"></a></h3><p>一个对象的初始化完成（构造函数执行结束）先行发生（happen—before）于它的 <code>finalize()</code> 方法的开始。</p><p>说明：调用对象finalize()方法时，对象初始化完成的任意操作，对于调用finalize()线程来说都是可见的。</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> x; <span class="comment">//共享变量</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.x = <span class="number">8</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span>  Exception,Throwable</span>{</span><br><span class="line">       Test test=<span class="keyword">new</span> Test();</span><br><span class="line">        test.finalize(); <span class="comment">//x = 8操作对于此线程可见</span></span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="传递性（Transitivity）">传递性（Transitivity）<a class="" href="#传递性（Transitivity）"></a></h3><p>如果操作 A 先行发生于操作 B，操作 B 先行发生于操作C，那就可以得出操作 A 先行发生于操作 C 的结论。</p><p>传递性规则要与其他规则组合理解，以volatile规则+传递性规则为例，下面代码中</p><p>1、因为 y=1 happen-before x=2（顺序性原则）</p><p>2、而 x = 2 happen-before x = 3（volatile变量 规则）;</p><p>3、 而x = 3又 happen-before z=4（顺序性原则）。</p><p>4、所以最终得出 y=1 happen-before z=4(传递性原则);</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">         <span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">volatile</span>  <span class="keyword">int</span> y; </span><br><span class="line">          <span class="keyword">int</span> z;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">test1</span><span class="params">()</span> </span>{</span><br><span class="line">    y=<span class="number">1</span>;</span><br><span class="line">    x = <span class="number">2</span>; <span class="comment">//因为 y=1 happen-before x=2（顺序性原则） 所以y=1 对于x=2可见</span></span><br><span class="line"> </span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">test2</span><span class="params">()</span> </span>{</span><br><span class="line">    x = <span class="number">3</span>;  <span class="comment">//因为  x = 2 happen-before x=3（volatile 规则） 所以x = 2 对于x=3可见</span></span><br><span class="line">    z=<span class="number">4</span>;  <span class="comment">//因为  y=1 happen-before  x=2，而 x = 2 happen-before x = 3;  而x = 3又 happen-before  z=4（顺序性原则），所以 y=1 happen-before z=4(传递性原则);</span></span><br><span class="line"> </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>JVM 在进行代码优化时需要保证这些先行发生关系，先行发生原则不依赖任何同步器协助就可以在编码中直接利用。如果两个操作之间的关系不在此列，并且无法从这 8 条规则推导出来的话，它们就没有顺序性保障，JVM 可以对它们<strong>随意地进行重排序</strong>。</p><h3 id="利用先行发生原则分析程序代码">利用先行发生原则分析程序代码<a class="" href="#利用先行发生原则分析程序代码"></a></h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(<span class="keyword">int</span> value)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这是一组 getter/setter 方法，假设存在线程 A 和 B，线程 A 先调用了（时间上的先后）<code>setValue(1)</code> 方法，然后线程 B 调用了同一个对象的 <code>getValue()</code>，那么线程 B 收到的返回值是什么？利用先行发生原则进行分析：</p><ol><li><p>两个方法分别由线程 A 和线程 B 调用，不在同一线程中，所以<strong>程序次序规则</strong>在这里不适用。</p></li><li><p>由于没有同步块（<code>synchronized</code> 或 <code>java.util.concurrent.ReentrantLock</code>），自然不会发生 lock 和 unlock 操作，所以<strong>管程锁定规则</strong>不适用。</p></li><li><p>由于 <code>value</code> 变量没有被 <code>volatile</code> 关键字修饰，所以 <strong>Volatile 变量规则</strong>不适用。</p></li><li><p><strong>线程启动、终止、中断规则</strong>和<strong>对象终结规则</strong>也和这里完全没有关系。</p></li></ol><p>因为没有一个适用的先行发生规则，所以最后一条<strong>传递性</strong>也无从谈起，因此我们可以判定尽管线程 A 在操作时间上先于线程 B，但是无法确定线程 B 中 <code>getValue()</code> 方法的返回结果，换句话说，这里面的操作<strong>不是线程安全</strong>的。</p><p>修复这个问题：</p><ul><li><p>要么把 <code>getter()</code>、<code>setter()</code> 方法都定义为 <code>synchronized</code> 方法，这样就可以套用<strong>管程锁定规则</strong>来满足先行发生关系。</p></li><li><p>要么把 <code>value</code> 定义为 <code>volatile</code> 变量，由于 <code>setter()</code> 方法对 <code>value</code> 的修改不依赖 <code>value</code> 的原值，满足 <code>volatile</code> 关键字使用场景，这样就可以套用 <strong>Volatile 变量规则</strong>来满足先行发生关系。</p></li></ul><h2 id="因果关系（Causality）">因果关系（Causality）<a class="" href="#因果关系（Causality）"></a></h2><p>先行发生原则仅仅是 JMM 的一个必要非充分的规则约束集，早期的 JMM 规范在不引入**因果关系（Causality）**这一条件约束的情况下，会出现一个看似更加诡异的问题——无中生有（out of thin air）。</p><p><strong>场景 A</strong></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程1 执行 foo 方法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>{</span><br><span class="line">  r1 = x;</span><br><span class="line">  y=r1;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程2 执行 bar 方法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span></span>{</span><br><span class="line">  r2 = y;</span><br><span class="line">  x=r2;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有可能出现 r1 == r2 == 42</span></span><br></pre></td></tr></tbody></table></figure><p>场景 A 如果以顺序一致性方式执行，是完全不会有任何同步问题的，但 JMM 并没有选择顺序一致性。而单纯地根据先行发生原则约束来看，这里首先不构成任何先行发生关系，其次由于 <code>x</code>、<code>y</code> 变量均在多线程环境下读写，这里也必然存在访问冲突，两个条件综合来看，<code>x</code> 和 <code>y</code> 势必出现数据竞争。</p><p><strong>为什么值有可能为 42</strong></p><blockquote><p>However, in a future aggressive system, Thread 1 could speculatively write the value 42 to y, which would allow Thread 2 to read 42 for y and write it out to x, which would allow Thread 1 to read 42 for x, and justify its original speculative write of 42 for y.</p></blockquote><p>当 <code>x</code> 依赖 <code>y</code> 的值，<code>y</code> 也依赖 <code>x</code> 的值，构成了循环依赖，成为了**因果循环（causal cycle）**的场景。</p><p>当一个相当激进的编译器遇到这样的场景，可能就会做出不可思议的优化手段，它有可能推测 <code>y</code> 为任何值，当然可能就是 42，因为无论什么值，这个循环场景都能够自圆其说。</p><p>在这种自圆其说（self-justifying）的场景下，配合这套先行发生原则来约束，就会出现严重问题，说到底还是先行发生原则太弱，除非刻意给变量加上 <code>volatile</code> 关键字，进而构成先行发生关系，但是使用 <code>volatile</code> 是有代价的，似乎没必要，我们只是需要采取某种措施防止编译器过于激进的优化即可。</p><hr><p><strong>场景 B</strong></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程1 执行 foo 方法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>{</span><br><span class="line">  r1 = x;</span><br><span class="line">  <span class="keyword">if</span>(r1 != <span class="number">0</span>)</span><br><span class="line">    y = <span class="number">42</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程2 执行 bar 方法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span></span>{</span><br><span class="line">  r2 = y;</span><br><span class="line">  <span class="keyword">if</span>(r2 != <span class="number">0</span>)</span><br><span class="line">     x = <span class="number">42</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有可能出现 r1 == r2 == 42</span></span><br></pre></td></tr></tbody></table></figure><p>场景 B 同样不构成任何先行发生关系，也没有额外的同步动作，却可能出现直接把 <code>x</code>、<code>y</code> 的写入操作越过条件语句，不分青红皂白地提前执行。</p><p>但场景 B 更令人费解的点在于，按照逻辑来看，由于 <code>r1</code> 和 <code>r2</code> 均为 0，应该不存在任何 x，y 的写入操作，也就不会出现数据竞争，原则上不需要任何同步手段也不会有同步问题。而事实上，上面两个场景恰恰说明，单凭这套先行发生原则的约束也没办法保证场景 B 正确执行。</p><hr><p>庆幸的是，无论场景 A 还是场景 B ，在 JMM 里是<strong>绝对禁止</strong>的，而先行发生原则又无法对这两个场景做出约束，JMM 就借助了**因果关系（Causality）**来保证。</p><p>简单说，因果关系核心在于对数据流（数据赋值关系）和控制流（条件控制语句，如 <code>if</code>）的依赖关系的分析，比如场景 B，<code>x</code> 和 <code>y</code> 的赋值操作前提是 <code>r1</code> 和 <code>r2</code> 不为 0，这种就是基于控制流的因果关系分析。</p><p>那么既然场景 B 出现了 <code>r1 == r2 == 42</code> 的情况，就说明编译器破坏了这层因果关系，这显然不能被 JMM 所接受。基于因果关系，场景 A 也不会凭空推测出 42，因为程序中并没有 42 写入的行为。</p><hr><p><strong>因果关系的破坏</strong></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程 1 执行 foo</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>{</span><br><span class="line">  r1 = a;</span><br><span class="line">  r2 = a;</span><br><span class="line">  <span class="keyword">if</span>(r1 == r2)</span><br><span class="line">    b = <span class="number">2</span>;</span><br><span class="line">} </span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程 2 执行 bar</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span></span>{</span><br><span class="line">  r3 = b;</span><br><span class="line">  a = r3;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有可能出现 r1 == r2 == r3 == 2</span></span><br></pre></td></tr></tbody></table></figure><p>场景 C 有可能出现 <code>r1 == r2 == r3 == 2</code> 的结果是被「允许」的。基于编译器优化策略，场景 C 被编译器优化后的代码：</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 线程 1 执行 foo</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>{</span><br><span class="line">  b = <span class="number">2</span>;</span><br><span class="line">  r1 = a;</span><br><span class="line">  r2 = r1; </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程 2 执行 bar</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span></span>{</span><br><span class="line">  r3 = b;</span><br><span class="line">  a = r3;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li><p><code>foo()</code> 方法中变量 <code>a</code> 重复读被清理，<code>r2 = a</code> 被 <code>r2 = r1</code> 取代；</p></li><li><p><code>if(r1 == r2)</code> 必然为 <code>true</code>，那么条件判断多余，可以被清理；</p></li><li><p><code>b = 2</code> 此时就有可能被重排序到 <code>foo()</code> 方法的开始位置。</p></li></ul><p>这就是基于控制流依赖的因果关系被打破的典型例子，从 <code>foo()</code> 方法执行语句来看，重复读消除是合理的，避免读到不同的值，这直接导致 <code>if</code> 判断确实无论什么情况下都是 <code>true</code>，这样一来，这一层因果关系被打破了，不需要因为满足 <code>if</code> 条件 <code>b = 2</code> 才会被执行，这种打破是<strong>由开发者的编码逻辑</strong>决定的，合情合理。反观场景 B 才是由编译器自身激进优化的问题才被因果关系「拦下」的。</p><h2 id="JMM规范下对并发三大特征的实现">JMM规范下对并发三大特征的实现<a class="" href="#JMM规范下对并发三大特征的实现"></a></h2><p>JMM 就是是围绕着在并发过程中如何处理<strong>原子性</strong>、<strong>可见性</strong>和<strong>有序性</strong>这 3 个特征来建立的。</p><h4 id="原子性（Atomicity）">原子性（Atomicity）<a class="" href="#原子性（Atomicity）"></a></h4><p><strong>原子性（Atomicity）</strong> 操作是指不可再被划分（不会被分不同时间片中）**的操作指令，JMM 要求在没有任何的同步手段的前提下，Java 基本数据类型变量的读写必须具备原子性。</p><p>但是允许了两个特例存在，非 <code>volatile</code> 修饰的 64位 <code>double</code> 和 <code>long</code> 类型，这就是它们的<strong>非原子性协定</strong>。</p><p>不同版本的 Java 可能有不同的处理方式，一般对 <code>double</code> 和 <code>long</code> 的处理方式是，将一个 64 位拆分成两个 32 位分别原子性读写，这样一来多线程环境下就有问题了，很可能高 32 位和低 32 位分别被两个不同线程读写，可能出现读取到「半个变量」的诡异问题。</p><blockquote><p>「这种情况非常罕见，在目前商用 JVM 中不会出现，虽然 JMM 有非原子性协定，但还是强烈建议 JVM 将 <code>double</code> 和 <code>long</code> 类型的读写操作实现为原子操作。目前各种平台下的商用 JVM 几乎都选择把 64 位数据的读写操作作为原子操作来对待。读者只要知道这件事情就可以了，无须太过在意这些几乎不会发生的例外情况。」——《深入理解 Java 虚拟机》</p><p><a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-17.html#jls-17.7">Non-Atomic Treatment of <code>double</code> and <code>long</code></a></p></blockquote><p><strong>Java 实现原子性</strong></p><ul><li><p><code>synchronized</code> 关键字</p></li><li><p><code>sun.misc.Unsafe</code> 类中的一系列 <code>compareAndSwap()</code> 方法</p></li></ul><p><strong><code>synchronized</code> 关键字实现原子性</strong></p><p>JMM 提供了 lock 和 unlock 操作来满足这种需求，尽管 JVM 未把 lock 和 unlock 操作直接开放给用户使用，但是却依托于管程（monitor）提供了更高层次的字节码指令 <code>monitorenter</code> 和 <code>monitorexit</code> 来隐式地使用这两个操作，这两个字节码指令反映到 Java 代码中就是同步块——<code>synchronized</code> 关键字。</p><p>Java 中每个对象实例都关联着一个 monitor，这个 monitor 维护着一个计数器，<code>monitorenter</code> 加锁时计数器值 + 1，<code>monitorexit</code> 解锁时 - 1，当计数器为 0 表示没有任何线程占用该锁。计数器的数值表示该锁被加锁的次数，这是为了实现可以被同个线程多次加锁，即<strong>可重入</strong>特性，所以 <code>synchronized</code> 是不会把自己死锁的，因此在 <code>synchronized</code> 块之间的操作也具备原子性。</p><p><strong><code>compareAndSwap*()</code></strong> <strong>方法实现原子性</strong></p><p><code>sun.misc.Unsafe</code> 类中的一系列 <code>compareAndSwap*()</code> 方法也可以实现原子性操作，这些都是 native 方法，会调用 CPU 提供的原子汇编指令来实现。</p><h4 id="可见性（Visibility）">可见性（Visibility）<a class="" href="#可见性（Visibility）"></a></h4><p><strong>可见性（Visibility）</strong> 是指当一个线程修改了共享变量的值，其他线程能够立即得知这个修改。JMM 通过在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方式来实现可见性，反映到 Java 代码中就是 <code>volatile</code> 关键字。</p><p><strong>Java 实现可见性</strong></p><ul><li><p><code>volatile</code> 关键字</p></li><li><p><code>synchronized</code> 关键字</p></li><li><p><code>final</code> 关键字</p></li></ul><p><strong><code>volatile</code></strong> <strong>关键字实现可见性</strong></p><p><code>volatile</code> 关键字的语义：</p><ul><li><p><strong>保证此变量对所有线程的可见性</strong>：当一条线程修改了这个变量的值会立刻回写到主内存，新值对于其他线程来说是可以立即得知的，所有写操作都能立刻反应到其他线程中。而普通变量被修改后，什么时候被回写到主内存是不定的，另外一条线程B在线程A回写完成了之后再从主内存进行读取操作，新变量值才会对线程B可见。</p></li><li><p><strong>禁止此变量赋值操作指令重排序优化</strong>：普通的变量<strong>仅仅</strong>会保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果，这就是 Java 程序中<strong>线程内表现为串行的语义（Within-Thread As-If-Serial Semantics）</strong>，但普通的变量并不能保证赋值操作的顺序与程序代码中的执行顺序一致，所以在当前线程里看程序代码像是有序的，但在其他线程里看来实则是无序的。</p></li></ul><p><code>volatile</code> 关键字可以说是 JVM 提供的最轻量级的控制并发机制，下面这类场景就很适合使用 <code>volatile</code> 关键字来控制并发，当 <code>shutdown()</code> 方法被调用时，能保证所有线程中执行的 <code>doWork()</code> 方法都能停止下来。</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> shutdownRequested;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>{</span><br><span class="line">    shutdownRequested = <span class="keyword">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">while</span> (!shutdownRequested) {</span><br><span class="line">        <span class="comment">// do something...</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>但 <code>volatile</code> 仅仅只能够保证变量的可见性，在不符合以下两条规则的运算场景中，仍需要通过加锁来保证原子性：</p><ul><li><p>运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。</p></li><li><p>变量不需要与其他的状态变量共同参与不变约束。</p></li></ul><p>JMM 对 <code>volatile</code> 关键字专门定义了一些特殊的访问规则：</p><ul><li><p>要求在工作内存中，每次使用变量前都必须先从主内存刷新最新的值（固定的 load -&gt; use 顺序），用于保证能看见其他线程对变量所做的修改后的值。</p></li><li><p>要求在工作内存中，每次修改变量后都必须立刻同步回主内存中（固定的 assign -&gt; store 顺序），用于保证其他线程可以看到当前线程对变量所做的修改。</p></li></ul><p>在 <code>synchronized</code> 同步块中，对一个变量执行 unlock 操作前，必须先把该变量同步回主内存中（执行 store、write 操作），所以 <code>synchronized</code> 关键字也保证了该变量的可见性。</p><p>被 <code>final</code> 关键字修饰的字段在构造器中一旦初始化完成，<strong>并且构造器没有把</strong> <strong><code>this</code></strong> <strong>的引用传递出去</strong>，那再其他线程中就能看见 <code>final</code> 字段的值，且 <code>final</code> 字段的值不能再被修改，也算保证了该变量的可见性。</p><p><code>this</code> 引用逃逸是一件很危险的事情，其他线程有可能通过这个引用访问到「初始化了一半」的对象，例如《Java 并发编程实践》中的例子：</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThisEscape</span> </span>{</span><br><span class="line">　　<span class="function"><span class="keyword">public</span> <span class="title">ThisEscape</span><span class="params">(EventSource source)</span> </span>{</span><br><span class="line">　　　　source.registerListener(<span class="keyword">new</span> EventListener() {</span><br><span class="line">　　　　　　<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(Event e)</span> </span>{</span><br><span class="line">　　　　　　　　doSomething(e);</span><br><span class="line">　　　　　　}</span><br><span class="line">　　　　});</span><br><span class="line">　　}</span><br><span class="line"> </span><br><span class="line">　　<span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(Event e)</span> </span>{</span><br><span class="line">　　}</span><br><span class="line"> </span><br><span class="line">　　<span class="class"><span class="keyword">interface</span> <span class="title">EventSource</span> </span>{</span><br><span class="line">　　　　<span class="function"><span class="keyword">void</span> <span class="title">registerListener</span><span class="params">(EventListener e)</span></span>;</span><br><span class="line">　　}</span><br><span class="line"> </span><br><span class="line">　　<span class="class"><span class="keyword">interface</span> <span class="title">EventListener</span> </span>{</span><br><span class="line">　　　　<span class="function"><span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(Event e)</span></span>;</span><br><span class="line">　　}</span><br><span class="line"> </span><br><span class="line">　　<span class="class"><span class="keyword">interface</span> <span class="title">Event</span> </span>{</span><br><span class="line">　　}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这将导致 <code>this</code> 引用逸出，所谓逸出，就是在不该发布的时候发布了一个引用。在这个例子里面，当我们实例化 <code>ThisEscape</code> 对象时，会调用 <code>source</code> 的 <code>registerListener()</code> 方法，这时便启动了一个线程，而且这个线程持有了 <code>ThisEscape</code> 对象（调用了对象的 <code>doSomething()</code> 方法），但此时 <code>ThisEscape</code> 对象却没有实例化完成（还没有返回一个引用），造成了 <code>this</code> 引用逸出，即还没有完成的实例化 <code>ThisEscape</code> 对象的动作，却已经暴露了对象的引用。其他线程访问还没有构造好的对象，可能会造成意料不到的问题。只有当构造函数返回时，<code>this</code> 引用才应该从线程中逸出。构造函数可以将 <code>this</code> 引用保存到某个地方，只要其他线程不会在构造函数完成之前使用它。</p><h4 id="有序性（Ordering）">有序性（Ordering）<a class="" href="#有序性（Ordering）"></a></h4><p><strong>有序性（Ordering）</strong> 在 <code>volatile</code> 关键字的禁止指令重排序语义中是也有提到，编译器和 CPU 会进行代码优化，打乱原本的代码顺序，进行一些执行预测分析等操作，三种重排序类型：</p><ul><li><p><strong>编译器优化的重排序</strong>：编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。</p></li><li><p><strong>指令级并行的重排序</strong>：现代 CPU 采用了指令级并行技术（Instruction-Level Parallelism，ILP）来将多条指令重叠执行。如果不存在数据依赖性，CPU 可以改变语句对应机器指令的执行顺序。</p></li><li><p><strong>内存系统的重排序</strong>：由于 CPU 使用缓存和读写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。</p></li></ul><p><strong>Java 实现有序性</strong></p><p>在 Java 程序中就天然存在的有序性：</p><ul><li><p><strong>线程内表现为串行的语义</strong>：如果在本线程内观察，所有的操作都是有序的。</p></li><li><p><strong>指令重排序和工作内存与主内存同步延迟现象</strong>：如果在一个线程中观察另一个线程，所有的操作都是无序的。</p></li></ul><p>Java 语言也提供了 <code>volatile</code> 和 <code>synchronized</code> 两个关键字来保证线程间操作的有序性，<code>volatile</code> 关键字本身就包含了禁止指令重排序的语义，而被 <code>synchronized</code> 关键字锁住的变量在同一时刻只允许一条线程对其进行 lock 操作，这决定了持有同一个锁的两个同步块只能串行地进入，所以也保证了有序性。</p><p><strong>参考资料</strong></p><p><a href="http://www.cs.umd.edu/users/pugh/java/memoryModel/">The Java Memory Model</a></p><p><a href="http://www.cs.umd.edu/~pugh/java/memoryModel/jsr-133-faq.html">JSR 133 (Java Memory Model) FAQ</a></p><p><a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-17.html#jls-17.4">Chapter 17. Threads and Locks</a></p><p><a href="https://programs.team/jmm-model-of-concurrent-programming-underlying-principle-of-volatile.html">JMM model of concurrent programming &amp; underlying principle of Volatile</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发理论基础：指令重排序问题</title>
      <link href="/post/164942290/"/>
      <url>/post/164942290/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是指令的重排序">什么是指令的重排序<a class="" href="#什么是指令的重排序"></a></h2><p>我们平时所讲的指令重排很容易被当成动词去理解，其实正确的理解是当成名词，即指令重排现象。简单来说就是：</p><p><strong>在程序中写的代码，在执行时并不一定按照写的顺序。</strong></p><p>现象展示</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PossibleReordering</span> </span>{</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">    Thread one = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() {</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">            a = <span class="number">1</span>;</span><br><span class="line">            x = b;</span><br><span class="line">        }</span><br><span class="line">    });</span><br><span class="line">    </span><br><span class="line">    Thread other = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() {</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">            b = <span class="number">1</span>;</span><br><span class="line">            y = a;</span><br><span class="line">        }</span><br><span class="line">    });</span><br><span class="line">    one.start();other.start();</span><br><span class="line">    one.join();other.join();</span><br><span class="line">    System.out.println(“(” + x + “,” + y + “)”);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>很容易想到这段代码的运行结果可能为(1,0)、(0,1)或(1,1)，因为线程one可以在线程two开始之前就执行完了，也有可能反之，甚至有可能二者的指令是同时或交替执行的。然而，这段代码的执行结果也可能是(0,0). 因为，在实际运行时，代码指令可能并不是严格按照代码语句顺序执行的。得到(0,0)结果的语句执行过程，如下图所示。值得注意的是，a=1和x=b这两个语句的赋值操作的顺序被颠倒了，或者说，发生了指令“重排序”(reordering)。事实上，输出了这一结果，并不代表一定发生了指令重排序，内存可见性问题也会导致这样的输出。</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/2022/04/image-20220407162228967.png" alt="输出结果"></p><h2 id="指令重排的场景">指令重排的场景<a class="" href="#指令重排的场景"></a></h2><h3 id="编译器重排序">编译器重排序<a class="" href="#编译器重排序"></a></h3><p>以 Java 语言为例，Java既可以作为解释型语言去用，也可以作为编译型语言。但是主流的做法是当成编译型语言在用。这里先解释下编译期：像c/c<ins>只有一个编译期，就是调用gcc命令将c/c</ins>代码编译成汇编代码。但是Java中有两个编译期：</p><ol><li>调用javac命令将Java代码编译成Java字节码；</li><li>Unix派系平台上调用gcc命令将openjdk源码编译成汇编代码。</li></ol><p>编译期间，Java中所谓的指令重排主要是说编译openjdk时的指令重排，将Java代码编译成Java字节码是没有做指令重排的。即加不加volatile，生成的字节码文件是一样的。</p><p>代码如下：</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Complier</span> </span>{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">int</span> found = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">()</span> </span>{</span><br><span class="line">        found = <span class="number">1</span>;</span><br><span class="line">        a = <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>不加 volatile 时字节码文件：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">()</span></span>;</span><br><span class="line">  descriptor: ()V</span><br><span class="line">  flags: ACC_PUBLIC</span><br><span class="line">  Code:</span><br><span class="line">    stack=<span class="number">2</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       <span class="number">1</span>: iconst_1</span><br><span class="line">       <span class="number">2</span>: putfield      #<span class="number">2</span>                  <span class="comment">// Field found:I</span></span><br><span class="line">       <span class="number">5</span>: aload_0</span><br><span class="line">       <span class="number">6</span>: iconst_1</span><br><span class="line">       <span class="number">7</span>: putfield      #<span class="number">3</span>                  <span class="comment">// Field a:I</span></span><br><span class="line">      <span class="number">10</span>: <span class="keyword">return</span></span><br><span class="line">    LineNumberTable:</span><br><span class="line">      line <span class="number">12</span>: <span class="number">0</span></span><br><span class="line">      line <span class="number">13</span>: <span class="number">5</span></span><br><span class="line">      line <span class="number">14</span>: <span class="number">10</span></span><br><span class="line">    LocalVariableTable:</span><br><span class="line">      Start  Length  Slot  Name   Signature</span><br><span class="line">          <span class="number">0</span>      <span class="number">11</span>     <span class="number">0</span>  <span class="keyword">this</span>   Ltech/stack/moka/Complier;</span><br></pre></td></tr></tbody></table></figure><p>添加上 volatile 时字节码文件：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">()</span></span>;</span><br><span class="line">   descriptor: ()V</span><br><span class="line">   flags: ACC_PUBLIC</span><br><span class="line">   Code:</span><br><span class="line">     stack=<span class="number">2</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">        <span class="number">0</span>: aload_0</span><br><span class="line">        <span class="number">1</span>: iconst_1</span><br><span class="line">        <span class="number">2</span>: putfield      #<span class="number">2</span>                  <span class="comment">// Field found:I</span></span><br><span class="line">        <span class="number">5</span>: aload_0</span><br><span class="line">        <span class="number">6</span>: iconst_1</span><br><span class="line">        <span class="number">7</span>: putfield      #<span class="number">3</span>                  <span class="comment">// Field a:I</span></span><br><span class="line">       <span class="number">10</span>: <span class="keyword">return</span></span><br><span class="line">     LineNumberTable:</span><br><span class="line">       line <span class="number">12</span>: <span class="number">0</span></span><br><span class="line">       line <span class="number">13</span>: <span class="number">5</span></span><br><span class="line">       line <span class="number">14</span>: <span class="number">10</span></span><br><span class="line">     LocalVariableTable:</span><br><span class="line">       Start  Length  Slot  Name   Signature</span><br><span class="line">           <span class="number">0</span>      <span class="number">11</span>     <span class="number">0</span>  <span class="keyword">this</span>   Ltech/stack/moka/Complier;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>通过对比我们可以发现无论是否添加 volatile 关键字 change() 方法字节码文件都没有发生变化。JVM在运行的时候就是通过字段属性中的<code>Access flags</code>属性来判断操作的类属性有没有加volatile修饰。在Java 中指令重排是编译器优化中的一种，编译openjdk是启用了O2级编译器优化。进行了比如优化无效代码、编译期完成简单运算、处理编译期屏障等等。</p><h3 id="指令集并行的重排序">指令集并行的重排序<a class="" href="#指令集并行的重排序"></a></h3><p>这个是针对于CPU指令级别来说的，为了使处理器内部的运算单元能尽量被充分利用，处理器采用了指令集并行技术来讲多条指令重叠执行，如果不存在数据依赖性，处理器可以改变主句对应的机器指令执行顺序，对输入的代码进行乱序执行优化，处理器会在计算之后将乱序执行的结果重组，并确保这一结果和顺序执行结果是一致的，但是这个过程并不保证各个语句计算的先后顺序和输入代码中的顺序一致。在计算机工程领域中又叫<code>乱序执行</code>(<code>错序执行</code>，英语：<code>out-of-order execution</code>，简称<code>OoOE</code>或<code>OOE</code>）是一种应用在高性能<a href="https://zh.wikipedia.org/wiki/%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8">微处理器</a>中来利用<a href="https://zh.wikipedia.org/wiki/%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F">指令周期</a>以避免特定类型的延迟消耗的<a href="https://zh.wikipedia.org/wiki/%E8%8C%83%E5%BC%8F">范式</a>。在这种范式中，处理器在一个由输入数据可用性所决定的顺序中执行指令，而不是由程序的原始数据所决定。在这种方式下，可以避免因为获取下一条程序指令所引起的处理器等待，取而代之的处理下一条可以立即执行的指令。主要目的还是为了使处理器内部的运算单元能尽量被充分利用。对于处理器为什么要进行指令重排或者怎样进行执行重排具体的可以了解<code>处理器中的流水线技术</code>。</p><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="内存重排序">内存重排序<a class="" href="#内存重排序"></a></h3><p>因为CPU缓存使用 缓冲区的方式(Store Buffere )进行延迟写入，这个过程会造成多个CPU缓存可见性的问题，这种可见性的问题导致结果的对于指令的先后执行显示不一致，从表面结果上来看好像指令的顺序被改变了，内存重排序现象其实是造成可见性问题的主要原因所在，其原理可在<a href="./%E5%B9%B6%E5%8F%91%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%EF%BC%9A%E7%BC%93%E5%AD%98%E5%8F%AF%E8%A7%81%E6%80%A7%E3%80%81MESI%E3%80%81%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C.md">并发理论基础：缓存可见性、MESI、内存屏障</a>可中详细了解。</p><p>文章开始展示的指令重排现象很有可能是由于内存缓存可见性原因导致的。</p><h2 id="指令重排序的原则（as-if-serial语义）">指令重排序的原则（as-if-serial语义）<a class="" href="#指令重排序的原则（as-if-serial语义）"></a></h2><p>编译器和处理指令也并非什么场景都会进行指令重排序的优化，而是会遵循一定的原则，只有在它们认为重排序后不会对程序结果产生影响的时候才会进行重排序的优化，如果重排序会改变程序的结果，那这样的性能优化显然是没有意义的。而遵守as-if-serial 语义规则就是重排序的一个原则，as-if-serial 的意思是说，可以允许编译器和处理器进行重排序，但是有一个条件，就是不管怎么重排序都不能改变单线程执行程序的结果。</p><h3 id="单线程重排序">单线程重排序<a class="" href="#单线程重排序"></a></h3><p>比如下面这段代码来说，语句2和语句1、3之间没有任何依赖关系，而语句1和语句3却有着明确的依赖关系，遇到这样的语句（换成指令也一样）编译器就认为先执行语句2再执行语句1、3对程序结果是没有任何影响的，所以可以对语句2进行重排序，反之编译器不会对语句3重排序到语句1之前，因为语句3和语句1是有数据依赖关系的，如果对3进行重排序就有可能影响到最终的程序运行结果，这也就是as-if-serial语义所表达的，只要程序结果不会改变，那么就算我重排序了代码和指令，但从结果上来看我好像就是完全串行按顺序的把代码从头执行到尾。</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">a=<span class="number">1</span>;  <span class="comment">//1</span></span><br><span class="line">b=<span class="number">2</span>;  <span class="comment">//2</span></span><br><span class="line">c=a+<span class="number">1</span>; <span class="comment">//3   </span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>编译器优化后可能执行顺序如下</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">b=<span class="number">2</span>;   <span class="comment">//2</span></span><br><span class="line">a=<span class="number">1</span>;   <span class="comment">//1</span></span><br><span class="line">c=a+<span class="number">1</span>; <span class="comment">//3   </span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="重排序对多线程的影响"><strong>重排序对多线程的影响</strong><a class="" href="#重排序对多线程的影响"></a></h2><p>单线程的重排序很简单，因为可以通过语义分析就能知道前后代码的依赖性，但是多线程就不一样了，多线程环境里编译器和CPU指令优化根本无法识别多个线程之间存在的数据依赖性，比如说下面的程序代码如果两个方法在l两个不同的线程里面调用就可能出现问题。</p><p>就如文章开头展示的代码片段，由于两个线程中的代码没有依赖关系，编译期或者 CPU 很有可能对代码指令进行重新排序。从而造成了在多线程中的错误的现象。</p><h2 id="禁止重排序">禁止重排序<a class="" href="#禁止重排序"></a></h2><p>在复杂的多线程环境下，编译器和处理器是根本无法通过语义分析来知道代码指令的依赖关系的，所以这个问题只交给能写代码的人才能清楚的知道，这个时候编写代码的人就需要通过一种方式显示的告诉编译器和处理器哪些地方是存在逻辑依赖的，这些地方不能进行重排序。</p><p>所以在编译器层面 和CPU层面都提供了一套内存屏障来禁止重排序的指令，不过在Java中为了简化开发人员的工作，避免开发人员需要对底层的系统原理的深度理解，所以封装了一套规范，把这些复杂的指令操作与开发人员隔离开来，这就是我们常说的Java 内存模型(JMM)，JMM定义了几个happens before原则来指导并发程序编写的正确性。程序员可以通过Volatile、synchronized、final几个关键字告诉编译器和处理器哪些地方是不允许进行重排序的。</p><h2 id="内存屏障">内存屏障<a class="" href="#内存屏障"></a></h2><h3 id="处理器乱序规则">处理器乱序规则<a class="" href="#处理器乱序规则"></a></h3><p>上面我们说了处理器会发生指令重排,现在来简单的看看常见处理器允许的重排规则,换言之就是处理器可以对那些指令进行顺序调整:</p><table><thead><tr><th>处理器</th><th>Load-Load</th><th>Load-Store</th><th>Store-Store</th><th>Store-Load</th><th>数据依赖</th></tr></thead><tbody><tr><td>x86</td><td>N</td><td>N</td><td>N</td><td>Y</td><td>N</td></tr><tr><td>PowerPC</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td>N</td></tr><tr><td>ia64</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td><td>N</td></tr></tbody></table><p>表格中的Y表示前后两个操作允许重排,N则表示不允许重排.与这些规则对应是的禁止重排的内存屏障.</p><p>注意:处理器和编译都会遵循数据依赖性,不会改变存在数据依赖关系的两个操作的顺序.所谓的数据依赖性就是如果两个操作访问同一个变量,且这两个操作中有一个是写操作,那么久可以称这两个操作存在数据依赖性.举个简单例子:</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">a=<span class="number">100</span>;<span class="comment">//write</span></span><br><span class="line">b=a;<span class="comment">//read</span></span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line">a=<span class="number">100</span>;<span class="comment">//write</span></span><br><span class="line">a=<span class="number">2000</span>;<span class="comment">//write</span></span><br><span class="line">或者</span><br><span class="line">a=b;<span class="comment">//read</span></span><br><span class="line">b=<span class="number">12</span>;<span class="comment">//write</span></span><br></pre></td></tr></tbody></table></figure><p>以上所示的,两个操作之间不能发生重排,这是处理器和编译所必须遵循的.当然这里指的是发生在单个处理器或单个线程中.</p><h3 id="内存屏障的分类">内存屏障的分类<a class="" href="#内存屏障的分类"></a></h3><p>在开始看一下表格之前,务必确保自己了解Store和Load指令的含义.简单来说,Store就是将处理器缓存中的数据刷新到内存中,而Load则是从内存拷贝数据到缓存当中.</p><table><thead><tr><th>屏障类型</th><th>指令示例</th><th>说明</th></tr></thead><tbody><tr><td>LoadLoad Barriers</td><td>Load1;LoadLoad;Load2</td><td>该屏障确保Load1数据的装载先于Load2及其后所有装载指令的的操作</td></tr><tr><td>StoreStore Barriers</td><td>Store1;StoreStore;Store2</td><td>该屏障确保Store1立刻刷新数据到内存(使其对其他处理器可见)的操作先于Store2及其后所有存储指令的操作</td></tr><tr><td>LoadStore Barriers</td><td>Load1;LoadStore;Store2</td><td>确保Load1的数据装载先于Store2及其后所有的存储指令刷新数据到内存的操作</td></tr><tr><td>StoreLoad Barriers</td><td>Store1;StoreLoad;Load1</td><td>该屏障确保Store1立刻刷新数据到内存的操作先于Load2及其后所有装载装载指令的操作.它会使该屏障之前的所有内存访问指令(存储指令和访问指令)完成之后,才执行该屏障之后的内存访问指令</td></tr></tbody></table><p>StoreLoad Barriers同时具备其他三个屏障的效果,因此也称之为全能屏障,是目前大多数处理器所支持的,但是相对其他屏障,该屏障的开销相对昂贵.在x86架构的处理器的指令集中,<code>lock</code>指令可以触发StoreLoad Barriers.</p><h3 id="硬件层内存屏障">硬件层内存屏障<a class="" href="#硬件层内存屏障"></a></h3><p>硬件层提供了一系列的内存屏障 memory barrier / memory fence(Intel的提法)来提供一致性的能</p><p>力。拿X86平台来说，有几种主要的内存屏障:</p><ol><li>lfence，是一种Load Barrier 读屏障</li><li>sfence, 是一种Store Barrier 写屏障</li><li>mfence, 是一种全能型的屏障，具备lfence和sfence的能力</li><li>Lock前缀，Lock不是一种内存屏障，但是它能完成类似内存屏障的功能。Lock会对CPU总线和高速 缓存加锁，可以理解为CPU指令级的一种锁。它后面可以跟ADD, ADC, AND, BTC, BTR, BTS, CMPXCHG, CMPXCH8B, DEC, INC, NEG, NOT, OR, SBB, SUB, XOR, XADD, and XCHG等指令。</li></ol><p>内存屏障有两个能力:</p><ol><li>阻止屏障两边的指令重排序</li><li>刷新处理器缓存/冲刷处理器缓存</li></ol><p>对Load Barrier来说，在读指令前插入读屏障，可以让高速缓存中的数据失效，重新从主内存加载数据;对Store Barrier来说，在写指令之后插入写屏障，能让写入缓存的最新数据写回到主内存。 Lock前缀实现了类似的能力，它先对总线和缓存加锁，然后执行后面的指令，最后释放锁后会把高速缓存中的数据刷新回主内存。在Lock锁住总线的时候，其他CPU的读写请求都会被阻塞，直到锁释放。</p><blockquote><p>个人对于内存屏障的理解主要是内存屏障通过限制了 CPU 在操作变量时对内存读写的顺序而反映到 CPU 对于指令的执行顺序，可以结合<a href="./%E5%B9%B6%E5%8F%91%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%EF%BC%9A%E7%BC%93%E5%AD%98%E5%8F%AF%E8%A7%81%E6%80%A7%E3%80%81MESI%E3%80%81%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C.md">并发理论基础：缓存可见性、MESI、内存屏障</a>内存一致性协议的优化来整体理解。</p></blockquote><p><strong>参考资料</strong></p><p>[Memory Barriers: a Hardware View for Software Hackers](</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发理论基础：缓存可见性、MESI、内存屏障</title>
      <link href="/post/164926797/"/>
      <url>/post/164926797/</url>
      
        <content type="html"><![CDATA[<p>从“<strong><a href="./%E5%B9%B6%E5%8F%91%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%EF%BC%9A%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98%E4%BA%A7%E7%94%9F%E7%9A%84%E4%B8%89%E5%A4%A7%E6%A0%B9%E6%BA%90.md">并发问题的三大根源</a></strong>” 文中我们简单的介绍了造成共享变量可见性问题的根源是CPU缓存的问题，那么这里我们再详细的把这个话题展开讨论下，最终计算机领域是如何解决缓存缓存可见性问题的。</p><h2 id="CPU缓存导致的可见性问题">CPU缓存导致的可见性问题<a class="" href="#CPU缓存导致的可见性问题"></a></h2><p>我们现在都知道了CPU加缓存都是为了提升CPU的利用率， 但是也衍生了一个问题，多核CPU的情况下，每个CPU都有着自己独立的缓存，它们各自之间是不可见的，这就会导致对应CPU读取的数据都是自己缓存的，无法看到别人对共享数据的修改，从而导致并发BUG。</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/2022/04/image-20220406101618719.png" alt=""></p><p><strong>缓存一致性问题的思考</strong></p><p>导致缓存一致性问题的核心主要是两个问题：</p><p>问题一： 在一个CPU修改了内存数据的时候，其它CPU是不知道的，所以导致一个CPU改了，另外一个CPU看不见，从而使用了旧的数据，导致了程序不正确的结果。</p><p>问题二： 在多个CPU同时读取和修改CPU的时候，如何保证这几个CPU操作的顺序性，一旦不能保证整个修改操作的顺序，那么就可能导致先写后读的两个请求，结果反映到内存就成了先读后写的结果，从而没有读取到最新的数据，又或者两个写数据的请求顺序被调换了，那么就可能会造成脏写。</p><h2 id="基于总线的一致性解决方案">基于总线的一致性解决方案<a class="" href="#基于总线的一致性解决方案"></a></h2><p>CPU要和存储设备进行交互，必须要通过总线设备，在获取到总线控制权后才能启动数据信息的传输，而CPU要想从主存读写数据，那么就必须向总线发起一个总线事务（读事务或写事务）来从主存读取或者写入数据。</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/2022/04/image-20220406225621339.png" alt=""></p><h3 id="总线嗅探">总线嗅探<a class="" href="#总线嗅探"></a></h3><p>缓存一致性的第一个问题在于，在多CPU缓存的情况下，一个CPU修改了主存的共享变量，其它CPU是不知道的，所以解决这个问题最直接的办法就是使用通知机制，当一个CPU修改了主存的数据时，其它CPU都会收到相应的数据变更通知，收到通知的CPU如果发现自己也缓存了对应的数据，那么就会将自己缓存的数据所在缓存行标记为失效，当下次读取该数据时发现自己的缓存行已过期，那么就会选择从主存加载最新的数据。 而实现这个功能的机制就叫“总线嗅探”，总线嗅探是通过CPU侦听总线上发生的数据交换操作，当总线上发生了数据操作，那么总线就会广播对应的通知。</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/2022/04/image-20220406234333051.png" alt=""></p><h3 id="总线仲裁">总线仲裁<a class="" href="#总线仲裁"></a></h3><p>导致缓存不一致的另外一个问题在于，CPU操作共享数据的顺序性，想让并发的操作变得有序，那么常用的方式就是让操作的资源具备独占性，这也就是我们常用的的方式加锁，当一个CPU对操作的资源加了锁，那么其它CPU就只能等待，只有等前一个释放了锁（资源占用权），后面的才能获得执行权，从而保证整体操作的顺序性。</p><p>而实现这个机制的功能就叫“总线仲裁”，在多个CPU同时申请对总线的使用权时，为避免产生总线冲突，需由总线仲裁来合理地控制和管理系统中需要占用总线的申请者，在多个申请者同时提出总线请求时，以一定的优先算法仲裁哪个应获得对总线的使用权。</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/2022/04/image-20220406234700283.png" alt=""></p><h3 id="总线机制的性能问题">总线机制的性能问题<a class="" href="#总线机制的性能问题"></a></h3><p>完全基于总线来保证缓存数据的一致性虽然简单可行，但是却有很大的性能瓶颈，为了保证数据的正确性，发生在总线上的事务操作必须是排它顺序执行的，这也就造成了只要一个CPU占用了总线，那么其它的CPU就无法与主存进行通讯而只能等待前一个执行完成，总线资源的这种独占性我们也常称为总线锁，而基于总线加锁的波及范围太大,所以存在很大的性能问题。</p><p>在早期处理器提供一个 LOCK# 信号，CPU1在操作共享变量的时候会预先对总线加锁，此时CPU2就不能通过总线来读取内存中的数据了，但这无疑会大大降低CPU的执行效率。</p><h2 id="总线性能问题优化方案">总线性能问题优化方案<a class="" href="#总线性能问题优化方案"></a></h2><p>总线性能瓶颈在于基于在总线与主存打交道会造成阻塞，那么反过来想如果不通过总线与内存发生数据交互就可以避免总线加锁，所以优化这个问题的核心在于如何减少必须通过总线与主存交互的操作，换而言之就是“如非必要，就不要通过总线与主存打交。</p><p>至于如何减少CPU通过主线和主存打交道的次数，这里可以分为两个方向，一方面<strong>尽量避免通过主线从主存读取的请求</strong>。另一个方面是<strong>减少修改数据后而把数据同步到主存的频率</strong>。</p><h3 id="减少从主存读取数据频率">减少从主存读取数据频率<a class="" href="#减少从主存读取数据频率"></a></h3><p>减少从主存读取数据频率的核心思想在于：CPU读取一个自己缓存没有的数据时，不是直接向主存读取，而是优先从其它已经缓存了对应数据的CPU缓存获。</p><p>当一个CPU读取数据时，首先从自己的缓存里面读取对应的缓存行，如果此时自己的缓存里面没有，那么它会向总线发起一个读取事务， 此时其它CPU会收到一个来自总线读取的消息，如果其它CPU的缓存有持有对应缓存行的数据时，它会把缓存行的地址放到总线上， 那么读取数据的CPU只需要通过地址拷贝对应的缓存行到自己的CPU缓存即可。</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/2022/04/image-20220406235947952.png" alt=""></p><h3 id="减少数据同步主存频率">减少数据同步主存频率<a class="" href="#减少数据同步主存频率"></a></h3><p>如果当前数据只有自己一个人缓存了，那么就不存在多个CPU缓存的一致性问题， 所以无论当前CPU修改多少次当前缓存行的值，也不会影响到其他人，所以这种情况下的数据变更可以不必马上同步到主存去，而只有在其他CPU也需要读取对应的数据时候，那么此时数据就会由一个人独占变成共享了，可以这个时候再把数据同步到主存去。</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/2022/04/image-20220407001541622.png" alt=""></p><h2 id="MESI协议">MESI协议<a class="" href="#MESI协议"></a></h2><p>总线性能的优化思路已经有了，那么就需要为这个思路指定解决具体的实时方案了，读取数据的时候如果要从其它CPU缓存获取数据的话，首先得知道其他CPU有没有这个数据，然后其他CPU的这个数据又是不是最新的，同样修改数据的时候，又如何知道其他CPU有没有缓存同样的数据，只有在确认大家都没有的时候，我才能放心的修改数据并且不用考虑同步到主存上去，但是CPU之间有没办法直接通信，所以所以它们之间就必须商定一套机制，<strong>如何通过自己的数据状态就能知道其他CPU的缓存情况</strong>，<strong>从而做出对应的策略，而这套机制就是缓存一致性协议</strong>。</p><p>缓存一致性协议有多种，有MSI、MESI、MESOI，大家总体的思路是一样的，不同的是后面的协议通过增加了某些状态，从而在某些场景能进一步减少通过总线与主存打交道的操作，我们这里来了解的是其中比较出名的MESI。</p><h3 id="MESI状态描述">MESI状态描述<a class="" href="#MESI状态描述"></a></h3><p>了解了MESI协议的核心目的之后，我们再来看MESI对应的几个状态所代表的意思。MESI协议通过对共享数据进行不同状态的标识，来决定CPU何时把缓存的数据同步到主存，何时可以从缓存读取数据，何时又必须从主存读取数据。MESI 每个字母就代表着一种数据状态，分别是<code>Modified</code> 、<code>Exclusive</code> 、<code>Share</code> 、<code>Invalid</code>，每个CPU读取共享数据之前先要识别数据的对象状态，然后根据这几个状态分别执行不同的策略，下面我们分别了解下每个状态所代表的含义。</p><h4 id="Exclusive-（独占状态）">Exclusive （独占状态）<a class="" href="#Exclusive-（独占状态）"></a></h4><p>当CPU从内存把数据加载到缓存，如果此前没有其它任何CPU缓存了该缓存行，那么此缓存行就处于独占(E)状态。</p><p>如果当缓存行处于E状态时，那么说明其他CPU没有缓存该缓存对应内存行中的内容。并且当前缓存行中的内容是最新的。所以缓存在Exclusive 状态下是可以放心读取（因为肯定是最新的），而在修改的时候也可以直接修改，并且不需要马上同步到主存上去（因为除了自己没有第二个人缓存这个数据了）。</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/2022/04/image-20220407002637393.png" alt=""></p><p><strong>状态的改变</strong></p><p><strong>从Exclusive 到 Share：</strong> 当有除了自己之外其他CPU需要读取该数据时，此时数据状态会从Exclusive 变成Share。</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/2022/04/image-20220407003338175.png" alt=""></p><p><strong>从Exclusive 到 Modified：</strong> 当前缓存行修改了处于Exclusive 状态的数据时，数据状态会由Exclusive 变为Modifile。</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/2022/04/image-20220407003139026.png" alt=""></p><h4 id="Share（共享状态）">Share（共享状态）<a class="" href="#Share（共享状态）"></a></h4><p>如果前面有一个CPU缓存了该缓存行，那么当在第二CPU又对改缓存行数据进行读取的时候，此时数据状态会变为Share状态。</p><p>如果当前缓存行处于Share状态，那么说明当其它CPU也缓存了改缓存数据，但是这个数据还没有被人修改过，是最新的，所以缓存行在当前状态下是可以直接进行读取的，但是如果要修改当前缓存的数据，那么就必须先通知其它的CPU让它们的数据失效，否则的话其它CPU就会读取到旧数据。</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/2022/04/image-20220407003338175.png" alt=""></p><p><strong>状态的转换</strong></p><p><strong>从Share到 Modified:</strong> 当前缓存行需要修改处于Share状态的数据时，那么首先会发送一条Invalid指令给其他缓存了对应缓存的CPU，直到其他CPU都响应了Invalid ack指令后，再对数据进行修改，此时数据状态会由Share变为Modified。</p><p><strong>从Share到 Invalid:</strong> 其它CPU修改了当前缓存数据时，会收到一个对于该缓存行的Invalid指令，收到Invalid指令后会把缓存状态从Share变为Invalid，并响应这条Invalid指令的ACK，表示自己已经成功收到并除了Invalid指令。</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/2022/04/image-20220407004112706.png" alt=""></p><h4 id="Modified-（修改状态）">Modified （修改状态）<a class="" href="#Modified-（修改状态）"></a></h4><p>Modified是一个中间状态，处于Modified状态的数据说明该数据已经被修改，还没有同步到主存去，这个状态下的数据是最新的，并且其它CPU缓存都是Invalid状态。</p><ol><li><p>当数据处于Modify状态缓存的数据是最新的，可以直接读取。</p></li><li><p>当数据处于Modify状态，那么说明其它CPU的要么没有缓存该变量，要么其它缓存都是Invalid（失效）状态，所以也可以直接修改，并且可以不用马上同步到主存。</p></li><li><p>当数据处于Modify状态，如果其他CPU需要读取该缓存行，那么在这个之前当前CPU必须把当前缓存行的数据同步到主存才行，避免其他CPU从主存读取到旧的值。</p></li></ol><p><strong>状态的转换</strong></p><p><strong>从Modified 到Share：</strong> 当数据处于Modified状态下，其它CPU发起了改缓存变量的读取时，当前CPU首先会将Modified的变量同步到主存中，然后再把数据标记为共享状态。</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/2022/04/image-20220407005146126.png" alt=""></p><h4 id="Invalid（无效状态）">Invalid（无效状态）<a class="" href="#Invalid（无效状态）"></a></h4><p>如果当前缓存行数据正被其它CPU修改，那么在其他CPU修改之前，所有缓存了该数据的CPU都会收到一条来自于该缓存行数据的Invalid指令，收到了该指令的CPU都会把对应的缓存行标记为Invalid状态。</p><p>当数据处于Invalid状态，那么说明数据被别人修改了，自己缓存中的该数据已经失效，那么此时读取数据就必须从主存或者其它缓存了该缓存行的CPU获取，修改也同理。</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/2022/04/image-20220407004112706.png" alt=""></p><p><strong>状态转换</strong></p><p><strong>从Invalid到Share状态：</strong> 当缓存数据处于Invalid状态时，再次发起对该缓存的数据读取，因为数据已经失效了，所以会尝试通过总线从主存获取最新的数据，此时修改了该缓存行数据的CPU会收到通知，从而把缓存行最新的数据同步到主存去（同时也会把数据从Modified标记为Share）,读取到最新数据的缓存行也为Share状态。</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/2022/04/image-20220407005146126.png" alt=""></p><p>MESI 最终由4个状态表示着缓存数据处于的场景，在读取、修改操作时配合不同的数据状态，最终制定了一套大家可以协作保证数据一致性的机制。</p><h3 id="MESI性能优化空间">MESI性能优化空间<a class="" href="#MESI性能优化空间"></a></h3><p>在共享状态下，因为一个缓存行的数据在多个 CPU 核心的 Cache 里都有。所以，当我们想要更新 Cache 里面的数据的时候，不能直接修改，而是要先向所有的其他 CPU 核心广播一个请求，要求先把其他 CPU 核心里面的缓存行都变成无效的状态，等其他CPU都响应对于invalid 操作的ACK 后，修改数据的CPU才能更新当前 Cache 里面的数据。这个广播操作，一般叫作 RFO（Request For Ownership），也就是获取当前对应 Cache Block 数据的所有权，也就是所谓的缓存锁。</p><p>从广播指令，到收到所有其他CPU的ACK之后才能继续后面的操作，整个过程都处于阻塞状态，而对于CPU来说这个时间是很漫长的，所以就从两个方向进行了优化。</p><ul><li>一方面是在CPU等待其他CPU 回复的过程中可以去干一些其它的事情，所以就有了Store Buffere 。</li><li>另一方面是尽量缩短其他CPU回复invalid ack的时间，所以就有了Invalidate Queue。</li></ul><h4 id="Store-Buffer">Store Buffer<a class="" href="#Store-Buffer"></a></h4><p>修改数据的时候，必须先广播invalid指令给其它CPU，然后等其它CPU收到消息并把自己缓存行标记为失效，最后再响应ACK后，再进行数据修改。 这个过程对于人来说时间很短，但对于CPU来说，可能相当于我们打开电饭煲开关，然后坐在那里等饭熟，既漫长，又无聊，而且还感觉很傻。 所以在等待饭熟（其它CPU响应ACK）的这段时间，何不去做点其它事呢，所以就有了store Buffere。</p><p>此时，CPU广播了通知之后，不再傻等着其它CPU回复了，而是把广播invalid指令发出去以后，然后直接把要修改的数据放到 Store Bufferes里，然后就去干其它事情了，当等到其他CPU都响应了ACK之后，然后再回头从Store Bufferes读取出来执行最后的数据修改操作。</p><h4 id="Store-Forward-存储转发">Store Forward(存储转发)<a class="" href="#Store-Forward-存储转发"></a></h4><p>Store Bufferes 的确提高了CPU的资源利用率，不过优化了带来了新的问题，回到上面CPU修改数据的第一步，如果第一步完成了之后（这个时候数据还在strore Bufferes中，自己的缓存中还是旧值），如果此时CPU-1接到了一个读取a共享变量的指令，那么CPU这时候会从自己的缓存中去读取共享变量的数据，而当前缓存中的数据并不是最新的，那么这是一个很明显的问题。所以没办法，要解决这个问题就必须要求CPU读取数据时得先看Store Buferes里面有没有，如果有则直接读取Store Buferes里的值，如果没有才能读取自己缓存里面的数据，这也就是所谓的“Store Forward”。</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/2022/04/image-20220407010520384.png" alt=""></p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/2022/04/image-20220407015701789.png" alt=""></p><h4 id="Invalidate-Queue（失效队列）">Invalidate Queue（失效队列）<a class="" href="#Invalidate-Queue（失效队列）"></a></h4><p>从CPU广播，到其他CPU收到广播消息、到其他CPU标记自己的缓存行为invalid，到响应消息，这个过程最慢的一环在于CPU标记自己的缓存行为invalid的过程，尤其是CPU在执行其它指令的期间并不能马上来处理invalid的广播消息，所以就有了失效队列的优化。</p><p>收到广播的CPU为了尽快响应 invalid ACK，所以就增加了一个失效队列，当收到其他CPU广播的invalid 消息后，不一定要马上处理，而是把放这个“失效队列里面”，然后就马上返回 invalid ack 。然后当自己有时间的时候再去处理失效队列里的消息，最后通过这种异步的方式，加快了CPU整个修改数据的过程。</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/2022/04/image-20220407011217707.png" alt=""></p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/2022/04/image-20220407015639904.png" alt=""></p><h3 id="MESI-优化带来的问题">MESI 优化带来的问题<a class="" href="#MESI-优化带来的问题"></a></h3><p>任何优化都是有代价的，这里经过了 store buffer 和invalid queue 优化后性能的确是有了提升，不过随之而来的也面临着一个问题，最初的MESI虽然整个过程是同步进行的，但是这样可以确保每个操作都真正意义上的执行了，从而保证了数据的强一致性。</p><p>但是加入了store buffer之后，就使得在修改操作完成后并不能保证缓存和内存的数据得到即时更新。 而在加入invalid queue之后，也使得其它CPU在修改了共享变量之后，并不能即时的把数据标记失效，这就可能造成在某一段时间内，不通过处理器之间还是会存在数据的不一致，整个数据变更的过程变成了弱一致性，而这两个问题就是导致并发问题的根源。</p><h2 id="内存屏障">内存屏障<a class="" href="#内存屏障"></a></h2><p>从上面得出的结论来看，我估计你会想到内存屏障会是个什么东西了，内存屏障就可以简单的认为它就是用来禁用我们的CPU缓存优化的，使用了内存屏障后，写入数据时候会保证所有的指令都执行完毕，这样就能保证修改过的数据能即时的暴露给其他的CPU。在读取数据的时候保证所有的“无效队列”消息都已经被读取完毕，这样就保证了其他CPU修改的数据消息都能被当前CPU知道，然后根据Invalid消息判断自己的缓存是否处于无效状态，这样就读取数据的时候就能正确的读取到最新的数据。</p><h3 id="Store-Barrier-写屏障">Store Barrier(写屏障)<a class="" href="#Store-Barrier-写屏障"></a></h3><p>强制所有在store屏障指令之前的store指令，都在该store屏障指令执行之前被执行，并把store缓冲区的数据都刷到CPU缓存。</p><p>结合上面的场景，这个指令其实就是告诉CPU，执行这个指令的时候需要把store buffer的数据都同步到内存中去。</p><h3 id="Load-Barrier-读屏障">Load Barrier(读屏障)<a class="" href="#Load-Barrier-读屏障"></a></h3><p>强制所有在load屏障指令之后的load指令，都在该load屏障指令执行之后被执行，并且一直等到load缓冲区被该CPU读完才能执行之后的load指令。</p><p>这个指令的意思是，在读取共享变量的指令前，先处理所有在失效队列中的消息，这样就保证了在读取数据之前所有失效的消息都得到了执行，从而保证自己是读取到的树是最新的。</p><h3 id="Full-Barrier（全能屏障）">Full Barrier（全能屏障）<a class="" href="#Full-Barrier（全能屏障）"></a></h3><p>包含了Store Barrier 和Load Barrier的功能。</p><h2 id="JMM对内存屏障的支持">JMM对内存屏障的支持<a class="" href="#JMM对内存屏障的支持"></a></h2><p>内存屏障提供了一套解决CPU缓存优化而导致的顺序性和可见性问题的方案，但是由于不同的硬件系统提供给的“内存屏障”指令都不一样，所以作为软件开发人员来说需要熟悉每个内存屏障的指令实在没必要，所以我们的JAVA语言把不同的内存屏障指令统一进行了封装，让我们的程序员不需要关心到系统的底层，只需要关心他们的自己的程序逻辑开发和如何使用这套规范即可，而封装这套解决方案的模型就是我们常说的Java内存模型JMM(Java Memory Model)。</p><h2 id="MESI和CAS关系">MESI和CAS关系<a class="" href="#MESI和CAS关系"></a></h2><p>在x86架构上，CAS被翻译为<code>lock cmpxchg...</code>，当两个core同时执行针对同一地址的CAS指令时,其实他们是在试图修改每个core自己持有的Cache line,</p><p>假设两个core都持有相同地址对应cacheline,且各自cacheline 状态为S, 这时如果要想成功修改,就首先需要把S转为E或者M, 则需要向其它core invalidate 这个地址的cacheline,则两个core都会向ring bus发出 invalidate这个操作, 那么在ringbus上就会根据特定的设计协议仲裁是core0,还是core1能赢得这个invalidate, 胜者完成操作, 失败者需要接受结果, invalidate自己对应的cacheline,再读取胜者修改后的值, 回到起点.。</p><p>对于我们的CAS操作来说, 其实锁并没有消失,只是转嫁到了ring bus的总线仲裁协议中. 而且大量的多核同时针对一个地址的CAS操作会引起反复的互相invalidate 同一cacheline, 造成pingpong效应, 同样会降低性能。当然如果真的有性能问题，这可能会在ns级别体现了,一般的应用程序中使用CAS应该不会引起性能问题。</p><h2 id="总结：">总结：<a class="" href="#总结："></a></h2><p>好了最后我们把这些知识串在一起，以便我们理解这么多技术概念的衍生关系和内在逻辑。</p><p><strong>1、缓存可见性的问题：</strong> 解决缓存可见性问题，本质上是要解决一个CPU修改了数据如何让其他CPU知道，然后多个CPU同时修改缓存数据如何保证他们操作的有序性。</p><p><strong>2、通过总线保证一致性</strong>：通过总线嗅探机制，一个CPU修改了缓存其它CPU会收到对应的通知，从而解决了一个CPU修改了数据其他CPU不知道的问题，通过总线仲裁来保证多个CPU同时修改数据的顺序性，并且总线天然的独占性也保证了多个操作的互斥。</p><p><strong>3、MESI协议：</strong> 因为通过总线来从主存读取数据的性能太慢，所以需要减少通过总线去读取主存的数据，尽量保证读取数据从自己或其他CPU缓存获得，修改数据尽量把多个操作合并为一个操作，所以MESI就通过对缓存数据的4个状态标记，来标识当前缓存行所处于的场景，针对不同的场景来执行不同的策略，最后达到缓存数据的一致性。</p><p><strong>4、MESI协议的优化</strong>：MESI在修改数据的时候必须先广播，然后等待其他所有CPU都把数据标记失效后，才能进行数据的修改操作，这个过程比较耗费时间，所以为了提升CPU的利用率，同时减少广播等待的时间，就增加了store buffer 和失效队列来进行优化。</p><p><strong>5、内存屏障：</strong> 虽然对于MESI优化，提升了整体的性能，但是同样也带来了一个问题，由原来的数据强一致性变成了弱一致性，从而导致在某些时候CPU缓存任然会存在不一致的情况。所以就需要一种机制来手动的禁用这种因为MESI优化带来的某些场景数据不一致的情况。 但是我们还是要乐观一点，因为绝大部分情况我们程序都不会存在问题，所以这种优化还是有意义的，这种个别的场景就需要我们的程序员来识别，然后通过内存屏障来保证数据的一致性。</p><p><strong>6、JMM：</strong> 因为内存屏障是操作系统级别的指令，而不同的操作系统，内存屏障的指令又不一样，为了避免程序员花费太多的精力在这些内存屏障指令上，所以Java就封装了一套Java的内存屏障，把不同操作系统的指令都封装在内，对程序员暴露的是一套统一的指令规范。Java的内存模型(JMM)中的规范。</p><p><strong>7、CAS：</strong> CAS  为 CPU 直接执行的指令，利用的是 ring bus 的总线仲裁协议，相较于操作系统级别的锁因为不涉及到内核态和用户态的切换，所以性能会很高。</p><p>参考：</p><p><a href="https://gitee.com/yuanjianchen/programming-resources/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA/hwViewForSwHackers.pdf">Memory Barriers: a Hardware View for Software Hackers</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发理论基础：原子性问题</title>
      <link href="/post/164913260/"/>
      <url>/post/164913260/</url>
      
        <content type="html"><![CDATA[<p>我们再回顾一下，原子性问题的根源是CPU切换线程执行指令所导致的，当前一个对共享变量的操作没有完成之前，CPU又切换到另外一个线程来操作对应的共享变量，那么最终产生的结果就可能出现问题。</p><p><strong>比如如果现在有两个线程都在执行number=number+1，他们最终的结果可能还是为1,因为PU执行流程可能会如下：</strong></p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/2022/04/image-20220405100021442.png" alt=""></p><h2 id="如解决原子性问题">如解决原子性问题<a class="" href="#如解决原子性问题"></a></h2><p>从上面的案例看，原子性问题的丢失完全是因为CPU切换线程执行指令导致的，那么是否意味着只要禁止CPU切换线程执行指令就可以呢，结果是行不通的，禁止CPU切换指令在单核CPU的确可以解决这个问题，但是多核CPU的场景下，CPU可以同时调度多个线程执行指令，那么该问题还是存在的。</p><p>所以我们必须另找出路，回过头来思考，我们会发现一个共性，就是不管是线程切换还是多核CPU同时执行指令，其实根本原因就是，对于共享变量在修改操作，在一个线程没有完成之前，另外一个线程是可以同时介入操作,所以才会导致一个线程的结果可能被另外一个线程覆盖。如果从这个角度来考虑的话，那么是不是只要达成一个线程在操作共享变量的过程中，另外一个线程是不能介入操作，只有等前面一个线程执行完之后，后面的线程才可以操作，<strong>也就是让两个线程对于共享变量的操作是互斥的，那么问题就可以解决，而让两个线程操作互斥我们常用的手段就是“加锁”。</strong></p><h2 id="互斥锁">互斥锁<a class="" href="#互斥锁"></a></h2><p>能保证多个线程（进程、操作者）对于共享变量（共享资源）的操作是互斥的也就是我们常说的“互斥锁”，锁是一个通用的概念在很多领域都有锁的机制、使用锁的目的也很简单，就是“保证操作的原子性”。</p><p>锁这个名字虽然很形象，但是类比到我们现实世界往往容易造成困惑，比如现实世界的门锁，我们开门的必须是用钥匙，而不是需要获取锁，而且现实世界一个锁会有多个钥匙，这在编程领域是不允许的，所以我更愿意把锁的意思解释成“使用权”。每个操作者需要操作共享资源时，必须首先获得这个共享资源的使用权才可以进行操作，而当一个人拥有了共享资源的使用权之后，另外一个人是想要操作共享资源就之后就只能等待前者操作结束后释放共享资源的使用权。</p><p>当我们对某个共享资源加锁之后，如果线程想要访问共享资源，那么它首先要拿到这个对象的锁，当某一个线程获取到锁时，它便可以访问共享资源， 没有获取到锁的线程只能等待，直到上一个线程执行完毕之后释放锁再进行下轮锁的竞争，因为只有一把锁，所以永远只会有一个线程操作该资源。加了锁之后那么最后执行的流程就如下：</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/2022/04/image-20220405115127263.png" alt=""></p><h2 id="管程模型">管程模型<a class="" href="#管程模型"></a></h2><p>使用互斥锁是为了线程共享资源的互斥性，对于共享资源的操作只允许有一个线程进行。但是在锁的获得与释放线程之间需要如何进行配合和协调又是一个问题，这也就是线程“同步”问题，所以解决共享变量的访问过程的原子性其实需要解决两个问题，一个是线程之间的互斥，二是线程之间的协调同步。对于这两个问题计算机领域有有一种成熟的方法论来解决，它就是管程。</p><p>汤小丹等人的《计算机操作系统》书中是这样说的</p><blockquote><p>在利用管程实现进程同步时，当某进程通过管程请求获得临界资源而未能满足时，管程便调用wait原语使该进程等待，并将其排在等待队列上。 仅当另一个进程访问完成并释放该资源后，管程才又调用signal原语，唤醒等待队列中的队首进程。 但是，考虑这样一种情况：当一个进程调用了管程后，在管程中时被阻塞或挂起，直到阻塞或挂起的原因解除； 在此期间，如果该进程不释放管程，则其它进程就无法进入管程，被迫长时间等待。为了解决这个问题，引入条件变量condition。 通常，一个进程被被阻塞或挂起的条件（原因）可有多个，因此在管程中设置了多个条件变量，对这些条件变量的访问智能在管程中进行。</p></blockquote><p>管程是操作系统的资源管理模块，由代表共享资源的数据结构 以及 对该共享数据结构 实施操作的一组过程所组成。</p><p>管程是一个抽象的概念模型，为了解决多个进程或线程同时访问一个共享资源时能达到"互斥"和"同步"的效果，它定义了管理共享资源的访问过程的模型，任何语言都可用通过都可以通过这套模型编写出安全的并发程序，管程实现必须达到下面几点要求：</p><p>1、管程中的共享变量对于外部都是不可见的，只能通过管程才能访问对应的共享资源(意思是共享变量的操作必须通过管程，无法通过其他途径操作)。</p><p>2、管程是互斥的，某个时刻只能允许一个进程或线程访问共享资源(线程对于管程的访问是互斥的)。</p><p>3、管程中需要有线程等待队列和相应等待和唤醒操作（没获得锁的线程放入一个队列中等待，等前一个线程释放锁后可以通过某种机制唤醒等待队列中的线程）。</p><p>4、必须有一种办法使进程无法继续运行时被阻塞(在程序要求的逻辑条件不满足的时候，可以使其阻塞)。</p><h3 id="我们来理解下上面几个条件："><strong>我们来理解下上面几个条件：</strong><a class="" href="#我们来理解下上面几个条件："></a></h3><p>首先第1点 和第2点我们都能理解，只能通过管程访问共享资源，并且每次只能有一个线程获得管程的执行权，这两个要求理解起来很简单，其实就是为了让线程之间达到互斥的效果。</p><p>然后看第3点要求，管程中要有等待队列和响应的等待和唤醒操作，这个也好理解，等待队列和唤醒可以使线程之间达到同步有序的执行。</p><p>第4点是比较让人费解的，什么时候线程会无法继续运行呢？为什么要在这个时候提供线程可以进入阻塞的方法。</p><p><strong>咱们看一个案例：</strong></p><p>场景：假如我们正在开发一个互联网项目；</p><p>角色：项目参与人员有产品经理、开发人员、测试人员参与；</p><p>限制：只有一个办公室可以使用，一个办公室一次只能容纳一个角色进入。</p><p>节点： 每个角色负责对应的节点，产品经理产品文档、开发人员产出项目代码、测试人员测试代码质量、产品进行验收。</p><p>条件：开发人员必须有了产品文档之后再产出项目代码、测试人员在开发人员开发完毕了之后进入测试、产品人员在测试完毕了之后进行验收。</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/2022/04/image-20220405120048884.png" alt=""></p><p>在这个场景里面，多个角色就是系统的多个线程，办公室是一个共享资源同一时刻只能有一个角色进入，这个场景里面就有一个阻塞场景，就是当一个开发人员抢到了办公室钥匙之后，进入到办公室，结果发现产品的需求都没有出来，这个时候开发人员是没有办法进行工作的，所以只能一直等，等到有产品文档之后继续下一步，但是这个时候产品是没办法进入办公室工作的，因为锁在开发人员手里，所以开发人员一直等不到需求文档，而产品经理一直进入不了办公室，导致死锁。</p><p>那么这里就需要有一种方式，当开发人员发现条件不成立的时候，此时开发人员可以主动的放弃办公室的锁，然后告诉办公室门口的产品经理，让产品经理先进办公室完成工作，开发人员自己则进入一个等待队列，当产品经理完成了工作之后，产品经理通知开发人员，然后自己放弃房间钥匙，等待需求验收再开始下一轮的工作。</p><p>最后以这种条件阻塞的方式让获得锁的线程可以主动让出锁，并等待其他线程唤醒再来检测条件，避免了某一个线程因为条件不满足导致任务无法进行，而因为别的线程无法进入到管程里，导致这个条件永远也无法改变锁造成的死锁问题。</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/2022/04/bVbCCfd.png" alt="MESA 管程模型"></p><h3 id="JAVA中的管程"><strong>JAVA中的管程</strong><a class="" href="#JAVA中的管程"></a></h3><p>通过上面的管程我们再来看JAVA里面的管程，JAVA是通过Synchronized关键字，和wait()、notify、notifyAll() 方法实现了整个管程模型， 与上面标准的管程模型不同的是，JAVA的Monitor属于一种简单的管程模型，因为它并没有使用多个条件变量的队列，不管是竞争锁产生的阻塞，还是拿到锁因为某个条件不合格导致的阻塞，统一都放入一个队列了。</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/2022/04/bVbCCfo.png" alt="Java 中的管程示意图"></p><p>对于 AQS 框架来说，其实现原理便是上图多条件变量管程模型。对于 Synchronized 和 AQS 对于管程的实现会专门分析。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发理论基础：并发与并行</title>
      <link href="/post/164912916/"/>
      <url>/post/164912916/</url>
      
        <content type="html"><![CDATA[<p>并发问题应该算是最让程序员头疼的问题了，无论工作还是面试过程中一谈到并发问题就显得非常高深。随着互联网的普及造成的巨大的用户量，并发问题又无法避免。在我们学习并发编程之前首先要明白什么是编发，了解并发的概念是我们后续学习的基础。</p><p>谈到并发的概念不得不提的就是并行概念。<strong>并发和并行最开始都是操作系统中的概念，表示的是CPU执行多个任务的方式</strong>。关于并发与并行的区别：</p><ol><li>解释一：并行是指两个或者多个事件在同一时刻发生；而并发是指两个或多个事件在同一时间间隔发生。</li><li>解释二：并行是在不同实体上的多个事件，并发是在同一实体上的多个事件**。**</li><li>解释三：在一台处理器上“同时”处理多个任务，在多台处理器上同时处理多个任务。如hadoop分布式集群</li></ol><p>所以并发编程的目标是充分的利用处理器的每一个核，以达到最高的处理性能。</p><h3 id="所谓-同时-进行">所谓"同时"进行<a class="" href="#所谓-同时-进行"></a></h3><p>我们现在使用的操作系统，是可以"同时"做很多件事儿的。比如我们可以一边看电影，一边聊QQ；一边听歌，一边打游戏。但是，这所谓的"同时"，在操作系统底层可能并不是真正的意义上的"同时"。</p><p>实际上，对于单CPU的计算机来说，在CPU中，同一时间是只能干一件事儿的。为了看起来像是“同时干多件事”，像Windows这种操作系统是把CPU的时间划分成长短基本相同的时间区间，即”时间片”，通过操作系统的管理，把这些时间片依次轮流地分配给各个应用使用。这样，给用户的感觉是他在同时的进行听歌和打游戏，实际上，在操作系统中，CPU是在游戏进程和音乐播放器进程之间来回切换执行的。</p><p>操作系统时间片的使用是有规则的：<strong>某个作业在时间片结束之前,整个任务还没有完成，那么该作业就被暂停下来，放弃CPU，等待下一轮循环再继续做。此时CPU又分配给另一个作业去使用。</strong></p><p>由于计算机的处理速度很快，只要时间片的间隔取得适当，那么一个用户作业从用完分配给它的一个时间片到获得下一个CPU时间片，中间有所”停顿”，但用户察觉不出来。所以，在单CPU的计算机中，我们看起来“同时干多件事”，其实是通过CPU时间片技术，并发完成的。</p><blockquote><p>如果对操作系统并发的执行任务看起来和每个任务顺序执行没有什么效率上的提升，那么为什么还要并发执行程序有疑问的话可以看一下<a href="./%E5%B9%B6%E5%8F%91%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%EF%BC%9A%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98%E4%BA%A7%E7%94%9F%E7%9A%84%E4%B8%89%E5%A4%A7%E6%A0%B9%E6%BA%90.md">并发理论基础：并发问题产生的三大根源</a></p></blockquote><h3 id="并发">并发<a class="" href="#并发"></a></h3><p><strong>并发（Concurrent），在操作系统中，是指一个时间段中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理机上运行。</strong></p><p>就想前面提到的操作系统的时间片分时调度。打游戏和听音乐两件事情在<strong>同一个时间段内</strong>都是在同一台电脑上完成了<strong>从开始到结束的动作</strong>。那么，就可以说听音乐和打游戏是并发的。</p><h3 id="并行"><strong>并行</strong><a class="" href="#并行"></a></h3><p><strong>并行（Parallel），当系统有一个以上CPU时，当一个CPU执行一个进程时，另一个CPU可以执行另一个进程，两个进程互不抢占CPU资源，可以同时进行，这种方式我们称之为并行(Parallel)。</strong></p><p>这里面有一个很重要的点，那就是系统要有多个CPU才会出现并行。在有多个CPU的情况下，才会出现真正意义上的『同时进行』。</p><h3 id="并发与并行"><strong>并发与并行</strong><a class="" href="#并发与并行"></a></h3><p>例如A，B两个人在吃午饭。A在吃饭的整个过程中，吃了米饭、吃了蔬菜、吃了牛肉。吃米饭、吃蔬菜、吃牛肉这三件事其实就是并发执行的。对于A来说，整个过程中看似是同时完成的的。但其实A是在吃不同的东西之间来回切换的。</p><p>在吃饭过程中，A吃了米饭、蔬菜、牛肉。B也吃了米饭、蔬菜和牛肉。A，B两个人之间的吃饭就是并行的。两个人之间可以在同一时间点一起吃牛肉，或者一个吃牛肉，一个吃蔬菜。之间是互不影响的。</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/2022/04/1620.jpeg" alt="img"></p><p>所以，<strong>并发是指在一段时间内宏观上多个程序同时运行。并行指的是同一个时刻，多个任务确实真的在同时运行。</strong></p><h3 id="并发和并行的区别"><strong>并发和并行的区别</strong><a class="" href="#并发和并行的区别"></a></h3><p>并发，指的是多个事情，在同一时间段内同时发生了。   并行，指的是多个事情，在同一时间点上同时发生了。</p><p>并发的多个任务之间是互相抢占资源的。   并行的多个任务之间是不互相抢占资源的、</p><p>只有在多CPU的情况中，才会发生并行。否则，看似同时发生的事情，其实都是并发执行的。</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/2022/04/1620-20220405111309946.jpeg" alt="img"></p><p>就像上面这张图，只有一个咖啡机的时候，一台咖啡机其实是在并发被使用的。而有多个咖啡机的时候，多个咖啡机之间才是并行被使用的。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发理论基础：并发问题产生的三大根源</title>
      <link href="/post/164912852/"/>
      <url>/post/164912852/</url>
      
        <content type="html"><![CDATA[<p>在我们去解决并发问题之前首先要理解什么是并发问题，造成并发问题的根源什么，所有并发处理的工具只是针对这些根源问题的其中一种解决方案。所以我们在学习并发解决方案或者编写并发程序时，我们首先要深入理解并发问题的根源是什么。</p><p>或许我们都知道并发问题的三大源头：</p><ul><li>原子性</li><li>可见性</li><li>有序性</li></ul><p>但是这三大源头到底是什么意思，怎么产生的呢？</p><h2 id="起因：如何最大化的利用CPU"><strong>起因：如何最大化的利用CPU</strong><a class="" href="#起因：如何最大化的利用CPU"></a></h2><p>CPU运算速度和IO速度的不平衡一直是计算机优化的一个课题，我们都知道CPU运算速度要以百倍千倍程度快于IO的速度，而在进行任务的执行的时候往往都会需要进行数据的IO，正因为这种速度上的差异，所以当CPU和IO一起协作的时候就产生问题了，CPU执行速度非常快，一个任务执行时候大部分时间都是在等待IO工作完成，在等待IO的过程中CPU是无法进行其它工作的，所以这样就使得CPU的资源根本无法合理的运用起来。</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/2022/04/image-20220405102318932.png" alt=""></p><p>CPU就相当于我们计算机的大脑，如何把CPU资源合理的利用起来就直接关系到我们计算机的效率和性能，所以为了这个课题计算机分别从缓存、任务切换、指令排序优化这几个方向进行了优化 。</p><h2 id="一、进程和线程的产生">一、进程和线程的产生<a class="" href="#一、进程和线程的产生"></a></h2><p>在最原始的系统里计算机内存中只能允许运行一个程序，这个时候的CPU的能力完全是过剩的，因为CPU在接收到一个任务之后绝大部分时间都是处在IO等待中，CPU根本就利用不起来，所以这个时候就需要一种同时运行多个程序的方法，这样的话当CPU执行一个任务IO等待的时候可以切换到另外一个任务上去执行指令，不必在IO上浪费时间，那么CPU就能很大程度的利用起来，所以基于这种思路就产生了进程和线程。</p><p>有了进程后，一个内存可以划分出不同的内存区域分别由多个进程管理，当一个进程IO阻塞的时候可以切换到另外一个进程执行指令，为了合理公平的把CPU分配到各个进程，CPU把自己的时间分为若干个单位的片段，每在一个进程上执行完一个单位的时间就切换到另外一个进程上去执行指令，这就是CPU的时间片概念。有了进程后我们的电脑就可以同时运行多个程序了，我们可以一边看着电影一边聊天，在CPU的利用率又进一步提升了CPU的利用率。</p><p>因为进程做任务切换需要切换内存映射地址，而一个进程创建的所有线程，都是共享一个内存空间的，所以线程做任务切换成本就很低了，现代的操作系统都基于更轻量的线程来调度，现在我们提到的“任务切换”都是指“线程切换”。</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/2022/04/image-20220405094832493.png" alt=""></p><h2 id="并发问题根源之一：CPU切换线程执导致的原子性问题">并发问题根源之一：CPU切换线程执导致的原子性问题<a class="" href="#并发问题根源之一：CPU切换线程执导致的原子性问题"></a></h2><p>首先我们先理解什么叫原子性，<strong>原子性就指是把一个操作或者多个操作视为一个整体，在执行的过程不能被中断的特性叫原子性</strong>。</p><p>因为IO、内存、CPU缓存他们的操作速度有着巨大的差距，假如CPU需要把CPU缓存里的一个变量写入到磁盘里面，CPU可以马上发出一条对应的指令，但是指令发出后的很长时间CPU都在等待IO的结束，而在这个等待的过程中CPU是空闲的。</p><p>所以为了提升CPU的利用率，操作系统就有了进程和时间片的概念，同一个进程里的所有线程都共享一个内存空间，CPU每执行一个时间段就会切换到另外一个进程处理指令，而这执行的时间长度是是以时间片（比如每个时间片为1毫秒）为单位的，通过这种方式让CPU切换着不同的进程执行，让CPU更好的利用起来，同时也让我们不同的进程可以同时运行，我们可以一边操作word文档，一边用QQ聊天。</p><p>后来操作系统又在CPU切换进程执行的基础上做了进一步的优化，以更细的维度“线程”来切换任务执行，更加提高了CPU的利用率。但正是这种CPU可以在不同线程中切换执行的方式会使得我们程序执行的过程中产生原行性问题。</p><p><strong>比如说我们以一个变量赋值为例：</strong></p><p>语句1：<code>int number=0;</code></p><p>语句2：<code>number=number+1;</code></p><p>在执行语句2的时候，我们的直觉<code>number=number+1</code> 是一个不可分割的整体，但是实际CPU操作过程中并非如此，我们的编译器会把<code>number=number+1 </code>拆分成多个指令交给CPU执行。</p><p><strong><code>number=number+1</code>的指令可能如下：</strong></p><p>指令1：CPU把number从内存拷贝到CPU缓存。</p><p>指令2：把number进行+1的操作。</p><p>指令3：把number回写到内存。</p><p>在这个时候如果有多线程同时去操作number变量，就很有可能出现问题，因为CPU会在执行上面任何一个指令的时候切换线程执行指令，这个时候就可能出现执行结果与我们预期结果不符合的情况。=</p><p><strong>比如如果现在有两个线程都在执行<code>number=number+1</code>，结果CPU执行流程可能会如下：</strong></p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/2022/04/image-20220405100021442.png" alt=""></p><p><strong>执行细节：</strong></p><ol><li>CPU先执行线程A的执行，把number=0拷贝到CUP寄存器。</li><li>然后CPU切换到线程B执行指令。</li><li>线程B 把number=0拷贝到CUP寄存器。</li><li>线程B 执行number=number+1 操作得到number=1。</li><li>线程B把number执行结果回写到缓存里面。</li><li>然后CPU切换到线程A执行指令。</li><li>线程A执行number=number+1 操作得到numbe=1。</li><li>线程A把number执行结果回写到缓存里面。</li><li>最后内存里面number的值为1。</li></ol><h2 id="二、高速缓存的产生">二、高速缓存的产生<a class="" href="#二、高速缓存的产生"></a></h2><p>为了减少CPU等待IO的时间，让CPU有更多的时间是花在运算上，最简单的思路就是减少IO等待的时间，基于这个思路所以就有了高速缓存增加了高速缓存（L1,L2,L3,主存）。</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/2022/04/image-20220405101141999.png" alt=""></p><p>在计算机系统中，CPU高速缓存是用于减少处理器访问内存所需的时间，其容量远小于内存，但其访问速度却是内存IO的几十上百倍。当处理器发出内存访问请求时，会先查看高速缓存内是否有请求数据。如果存在（命中），则不需要访问内存直接返回该数据；如果不存在（失效），则要先把内存中的相应数据载入缓存，再将其返回处理器。</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/2022/04/slide_10.jpg" alt="Overview of Processor Techniques A brief look at CDA 3101 and CDA ppt  download"></p><h2 id="并发问题根源之二：缓存导致的可见性问题">并发问题根源之二：缓存导致的可见性问题<a class="" href="#并发问题根源之二：缓存导致的可见性问题"></a></h2><p>在有了高速缓存之后，CPU的执行操作数据的过程会是这样的，CPU首先会从内存把数据拷贝到CPU缓存区。</p><p>然后CPU再对缓存里面的数据进行更新等操作，最后CPU把缓存区里面的数据更新到内存。</p><p>磁盘、内存、CPU缓存会按如下形式协作。</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/2022/04/image-20220405102806334.png" alt=""></p><p>缓存导致的可见性问题就是指我们在操作CPU缓存过程中，由于多个CPU缓存之间独立不可见的特性，导致共享变量的操作结果无法预期。</p><p>在单核CPU时代，因为只有一个核心控制器，所以只会有一个CPU缓存区，这时各个线程访问的CPU缓存也都是同一个，在这种情况一个线程把共享变量更新到CPU缓存后另外一个线程是可以马上看见的，因为他们操作的是同一个缓存，所以他们操作后的结果不存在可见性问题。</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/2022/04/image-20220405103215021.png" alt=""></p><p>而随着CPU的发展，CPU逐渐发展成了多核，CPU可以同时使用多个核心控制器执行线程任务，当然CPU处理同时处理线程任务的速度也越来越快了，但随之也产生了一个问题，多核CPU每个核心控制器工作的时候都会有自己独立的CPU缓存，每个核心控制器都执行任务的时候都是操作的自己的CPU缓存，CPU1与CPU2它们之间的缓存是相互不可见的。</p><p>这种情况下多个线程操作共享变量就因为缓存不可见而带来问题，多线程的情况下线程并不一定是在同一个CUP上执行，它们如果同时操作一个共享变量，但因为在不同的CPU执行所以他们只能查看和更新自己CPU缓存里的变量值，线程各自的执行结果对于别的线程来说是不可见的，所以在并发的情况下会因为这种缓存不可见的情况会导致问题出现。</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://pic1.zhimg.com/80/v2-8cba245715f22fac30ebb4f397ead0d4_720w.png" alt="img"></p><p><strong>比如下面的程序：</strong></p><p>两个线程同时调用addNumber() 方法对number属性进行+1 ，循环10W次，等两个线程执行结束后，我们的预期结果number的值应该是20000，可是我们在多核CPU的环境下执行结果并非我们预期的值。</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCase</span> </span>{</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">private</span>  <span class="keyword">int</span> number=<span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNumber</span><span class="params">()</span></span>{</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100000</span>;i++){</span><br><span class="line">  number=number+<span class="number">1</span>;</span><br><span class="line">         }</span><br><span class="line"> </span><br><span class="line">     }</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">         TestCase testCase=<span class="keyword">new</span> TestCase();</span><br><span class="line">          Thread threadA=<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() {</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">  testCase.addNumber();</span><br><span class="line">              }</span><br><span class="line">          });</span><br><span class="line"> </span><br><span class="line">         Thread threadB=<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() {</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">  testCase.addNumber();</span><br><span class="line">             }</span><br><span class="line">         });</span><br><span class="line">         threadA.start();</span><br><span class="line">         threadB.start();</span><br><span class="line">         threadA.join();</span><br><span class="line">         threadB.join();</span><br><span class="line">        System.out.println(<span class="string">"number="</span>+testCase.number);</span><br><span class="line">     }</span><br><span class="line"> }</span><br></pre></td></tr></tbody></table></figure><p><strong>打印结果：</strong></p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://pic4.zhimg.com/80/v2-74b01ba2c951ea3f49da8c662455eed7_720w.png" alt="img"></p><h2 id="三、指令优化（重排序）"><strong>三、指令优化（重排序）</strong><a class="" href="#三、指令优化（重排序）"></a></h2><p>进程和线程本质上是增加并行的任务数量来提升CPU的利用率，缓存是通过把IO时间减少来提升CPU的利用率，而指令顺序优化的初衷的初衷就是想通过调整CPU指令的执行顺序和异步化的操作来提升CPU执行指令任务的效率。</p><p>指令顺序优化可能发生在编译、CPU指令执行、缓存优化几个阶，其优化原则就是只要能保证重排序后不影响单线程的运行结果，那么就允许指令重排序的发生。其重排序的大体逻辑就是优先把CPU比较耗时的指令放到最先执行，然后在这些指令执行的空余时间来执行其他指令，就像我们做菜的时候会把熟的最慢的菜最先开始煮，然后在这个菜熟的时间段去做其它的菜，通过这种方式减少CPU的等待，更好的利用CPU的资源。</p><h2 id="并发问题根源之三：指令优化导致的重排序问题">并发问题根源之三：指令优化导致的重排序问题<a class="" href="#并发问题根源之三：指令优化导致的重排序问题"></a></h2><p>下面的程序代码如果init（）方法的代码经过了指令重排序后，两个方法在两个不同的线程里面调用就可能出现问题。</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> value;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> flag;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span>  <span class="title">init</span><span class="params">()</span></span>{</span><br><span class="line">       value=<span class="number">8</span>;     <span class="comment">//语句1</span></span><br><span class="line">       flag=<span class="keyword">true</span>;  <span class="comment">//语句2</span></span><br><span class="line">   }</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getValue</span><span class="params">()</span></span>{</span><br><span class="line">       <span class="keyword">if</span>(flag){</span><br><span class="line">           System.out.println(value);</span><br><span class="line">       }</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure><p>根据上面代码，如果程序代码运行都是按顺序的，那么getValue() 中打印的value值必定是等于8的，不过如果init(）方法经过了指令重排序，那么结果就不一定了。根据重排序原则，init()方法进行指令重排序重排序后并不会影响其运行结果，因为语句1和语句2之间没有依赖关系。 所以进行重排序后代码执行顺序可能如下。</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">flag=<span class="keyword">true</span>;  <span class="comment">//语句2  </span></span><br><span class="line">value=<span class="number">8</span>;     <span class="comment">//语句1</span></span><br></pre></td></tr></tbody></table></figure><p>如果init()方法经过了指令重排序后，这个时候两个线程分别调用 init()和getValue()方法，那么就有可能出现下图的情况，导致最终打印出来的value数据等于0。</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/2022/04/image-20220405103325395.png" alt=""></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>说一说我理解的Java</title>
      <link href="/post/164885530/"/>
      <url>/post/164885530/</url>
      
        <content type="html"><![CDATA[<p>大四校招时第一次接触 Java，了解到 Java 或者说编程也是全靠培训机构，对 Java 的第一印象就是 <code>速成</code> 、<code>高薪</code>, 就业一年就能月薪一万。所以当时就在金钱的诱惑下来到了北京学习 Java 。</p><p>所以刚开始学习的时候，有好多问题在困扰我：</p><blockquote><p>Java 是什么？为什么叫 Java？Java 能干什么？为什么 main 方法要这么写？</p></blockquote><p>后面随着学习和学习和看书，大部分都是从Java的发展史开始讲，总之就是那些什么Java历史悠久，Java很优秀，Java越来越牛，用的人越来越多，什么编程语言排行榜常年第一，大致都是这些，然后再扯些其他的，接着就上起了<code>Hello World！</code>就这样，Java生涯的第一个程序开始了，意思是“你好，世界！”</p><p>不过这些问题始终困扰着我，我也始终不知道这些答案。不过我学会了百度：</p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/2022/04/image-20220402052905975.png" alt=""><p>百度百科是这样介绍 Java 的：</p><blockquote><p>Java是一门<a href="https://baike.baidu.com/item/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1">面向对象</a>的编程语言，不仅吸收了<a href="https://baike.baidu.com/item/C%2B%2B">C++</a>语言的各种优点，还摒弃了C++里难以理解的多继承、<a href="https://baike.baidu.com/item/%E6%8C%87%E9%92%88/2878304">指针</a>等概念，因此Java语言具有功能强大和简单易用两个特征。Java语言作为静态面向对象编程语言的代表，极好地实现了面向对象理论，允许程序员以优雅的思维方式进行复杂的编程 [1] 。</p></blockquote><p>Java具有简单性、面向对象、<a href="https://baike.baidu.com/item/%E5%88%86%E5%B8%83%E5%BC%8F/19276232">分布式</a>、<a href="https://baike.baidu.com/item/%E5%81%A5%E5%A3%AE%E6%80%A7/4430133">健壮性</a>、<a href="https://baike.baidu.com/item/%E5%AE%89%E5%85%A8%E6%80%A7/7664678">安全性</a>、平台独立与可移植性、<a href="https://baike.baidu.com/item/%E5%A4%9A%E7%BA%BF%E7%A8%8B/1190404">多线程</a>、动态性等特点 [2] 。Java可以编写<a href="https://baike.baidu.com/item/%E6%A1%8C%E9%9D%A2%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/2331979">桌面应用程序</a>、Web应用程序、<a href="https://baike.baidu.com/item/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/4905336">分布式系统</a>和<a href="https://baike.baidu.com/item/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F/186978">嵌入式系统</a>应用程序等 [3] 。</p><p>大眼一看，呃… 说的真好（下次不要再说了），不过总觉得有点官方啊，继续搜索其他的文章，看看别人怎么介绍Java的，随便点开一篇文章，看，这位博主这样说：</p><blockquote><p>Java是一种可以撰写跨平台应用程序的、面向对象的程序设计语言。简单说，Java就是一种语言，不过是一种针对jvm的语言，Java编译后是字节码，而jvm会把这些字节码解释成机器码，然后做出相应的动作。</p></blockquote><p>百度百科那个说到了C和C++，还有什么面向对象，分布式，还有什么静态面向对象编程，觉得有点不懂，看这位博主写的，貌似懂了一些，不过啥是jvm啊？</p><p>越搜索涉及到的名词越来越多。然后这个问题就不了了之了，就剩下了对工作一年就能月薪一万的期待。</p><p>后面伴随着工作了解到越来越多的知识，回想起来这个问题，也不禁勾起了对过往的回忆，如果过去的我问现在的我，那么我将要怎么向过去的我说明白呢。</p><p><strong>首先，Java 是什么？</strong></p><p>Java 是一种语言，就像汉语，英语，法语等语言一样，只不过汉语这些语言是我们人与人之间沟通交流的语言，而 Java 就是我们与计算机沟通的语言。</p><p><strong>我们为什么要与计算机沟通呢？</strong></p><p>因为计算机是一台特别聪明的机器，特别适合进行大数据量的计算和重复性的计算，能特别高的提升我们人类的生产力。所以我们需要计算机来帮我们做一些我们不擅长的事情。</p><p><strong>那与计算机沟通是不是只有 Java 呢？</strong></p><p>就像人类沟通交流有许多的语言一样，和计算机沟通交流也有许多的语言，会有很多种不同的分类。</p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/2022/04/3f6426f24591e2eea3924b1731d1bc0d-20220402061739399.png" alt="编程语言"><p>对于这么多语言我们不用去管它，重点还是 Java。</p><p><strong>那为什么有这么多语言呢？</strong></p><p>计算机虽然比较聪明但是特别死板，想让它帮忙做一些事情，需要把事情拆解成一步一步的很小的步骤让它去做，但是有很多事情的一些步骤都是一样的，这样我们让计算机帮我做一些事情就会特别累。所以会有一些语言会把一些步骤整合到一块，变得比较简单，然后请几个翻译来把我们说的这种比较简单的翻译成计算机能理解的语言。这样我们就向翻译说一些比较简单的指令就可以了。所以这些语言包含了我们在各种场景下使用的简单的语言，也包含了这些语言的翻译。</p><p>一种语言或者也可以说成是一种工具，计算机能根据我们的指定搞定各种各样的事情，我们给计算机下达指令也是靠这些语言，同时计算机在做不同的事情的时候用到指令不同，所以对不同指令整合在一起的语言也是有所差异的。</p><p><strong>那为什么叫 Java 呢？</strong></p><p>Java 叫 Java是因为创始人员团队中其中一名成员由于灵感想到的，他想起自己在Java岛（爪哇岛）上曾喝过一种美味的咖啡。嗯。大佬起名就是这么随意。</p><p><strong>Java 能干什么？</strong></p><p>说 Java 能干什么，也可以换个说法说我们想让计算机干什么。话虽这么说，但是 Java 有自己擅长的事情和自己不擅长的事情。</p><p>Java其实有三个版本分类：</p><ol><li>JavaSE</li><li>JavaME</li><li>JavaEE</li></ol><p>你可以大致的这样理解，JavaSE是Java的核心基础，包含的就是基础知识，自学Java刚开始都是从这个开始的，JavaME呢？不知道大家之前玩过那种游戏没，就是在安卓手机还没有的时候，我们会下载一些jar结尾的游戏文件来安装，打开之后都会先有这个图标：</p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/2022/04/images.png" alt="Java" style="zoom:50%;"><p>你可以简单理解这就是JavaME搞出来的，不过后来出来了安卓，就代替了它，所以不用太管它，至于JavaEE，可以称为企业级应用开发，这部分会学各种框架，各种高级玩意儿，也是我们后期主要学习的东西，我们可以利用这部分知识开发各种网站啊，桌面应用啊，一些工具啊，甚至游戏都可以，当然，很多应用都是使用到了java的综合技术来实现的。不过在游戏，桌面应用，科学计算等一些场景有更擅长的语言和工具，Java 目前更多的还是用于企业级软件开发。不过“铁打的思想，流水的语言”，语言终归是工具，怎么用，能干嘛，这取决于用的人，如果你足够牛，那么你可以：</p><blockquote><p>用java改变世界！</p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis入门-Redis概念和基础</title>
      <link href="/post/164885535/"/>
      <url>/post/164885535/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Redis是一种支持key-value等多种数据结构的存储系统。可用于缓存，事件发布或订阅，高速队列等场景。支持网络，提供字符串，哈希，列表，队列，集合结构直接存取，基于内存，可持久化。</p></blockquote><h2 id="什么是Redis">什么是Redis<a class="" href="#什么是Redis"></a></h2><p>Redis是一款内存高速缓存数据库。Redis全称为：<strong>Remote Dictionary Server</strong>（远程数据服务），使用C语言编写，Redis是一个key-value存储系统（键值存储系统），支持丰富的数据类型，如：String、list、set、zset、hash。</p><p>Redis是一种支持key-value等多种数据结构的存储系统。可用于缓存，事件发布或订阅，高速队列等场景。支持网络，提供字符串，哈希，列表，队列，集合结构直接存取，基于内存，可持久化。</p><h3 id="官方资料">官方资料<a class="" href="#官方资料"></a></h3><p>Redis官网:http://redis.io/</p><p>Redis官方文档:http://redis.io/documentation</p><p>Redis教程:http://www.w3cschool.cn/redis/redis-intro.html</p><p>Redis下载:http://redis.io/download</p><h2 id="为什么要使用Redis">为什么要使用Redis<a class="" href="#为什么要使用Redis"></a></h2><blockquote><p>一个产品的使用场景肯定是需要根据产品的特性，先列举一下Redis的特点：</p></blockquote><ul><li>读写性能优异<ul><li>Redis能读的速度是110000次/s,写的速度是81000次/s （测试条件见下一节）。</li></ul></li><li>数据类型丰富<ul><li>Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。</li></ul></li><li>原子性<ul><li>Redis的所有操作都是原子性的，同时Redis还支持对几个操作全并后的原子性执行。</li></ul></li><li>丰富的特性<ul><li>Redis支持 publish/subscribe, 通知, key 过期等特性。</li></ul></li><li>持久化<ul><li>Redis支持RDB, AOF等持久化方式</li></ul></li><li>发布订阅<ul><li>Redis支持发布/订阅模式</li></ul></li><li>分布式<ul><li>Redis Cluster</li></ul></li></ul><p>（PS: 具体再结合下面的使用场景理解下）</p><blockquote><p>下面是官方的bench-mark根据如下条件获得的性能测试（<strong>读的速度是110000次/s,写的速度是81000次/s</strong>）</p></blockquote><ul><li>测试完成了50个并发执行100000个请求。</li><li>设置和获取的值是一个256字节字符串。</li><li>Linux box是运行Linux 2.6,这是X3320 Xeon 2.5 ghz。</li><li>文本执行使用loopback接口(127.0.0.1)。</li></ul><h2 id="Redis的使用场景">Redis的使用场景<a class="" href="#Redis的使用场景"></a></h2><blockquote><p>redis应用场景总结redis平时我们用到的地方蛮多的，下面就了解的应用场景做个总结：</p></blockquote><h3 id="热点数据的缓存">热点数据的缓存<a class="" href="#热点数据的缓存"></a></h3><p>缓存是Redis最常见的应用场景，之所有这么使用，主要是因为Redis读写性能优异。而且逐渐有取代memcached，成为首选服务端缓存的组件。而且，Redis内部是支持事务的，在使用时候能有效保证数据的一致性。</p><p>作为缓存使用时，一般有两种方式保存数据：</p><ul><li>读取前，先去读Redis，如果没有数据，读取数据库，将数据拉入Redis。</li><li>插入数据时，同时写入Redis。</li></ul><p>方案一：实施起来简单，但是有两个需要注意的地方：</p><ul><li>避免缓存击穿。（数据库没有就需要命中的数据，导致Redis一直没有数据，而一直命中数据库。）</li><li>数据的实时性相对会差一点。</li></ul><p>方案二：数据实时性强，但是开发时不便于统一处理。</p><p>当然，两种方式根据实际情况来适用。如：方案一适用于对于数据实时性要求不是特别高的场景。方案二适用于字典表、数据量不大的数据存储。</p><h3 id="限时业务的运用">限时业务的运用<a class="" href="#限时业务的运用"></a></h3><p>redis中可以使用expire命令设置一个键的生存时间，到时间后redis会删除它。利用这一特性可以运用在限时的优惠活动信息、手机验证码等业务场景。</p><h3 id="计数器相关问题">计数器相关问题<a class="" href="#计数器相关问题"></a></h3><p>redis由于incrby命令可以实现原子性的递增，所以可以运用于高并发的秒杀活动、分布式序列号的生成、具体业务还体现在比如限制一个手机号发多少条短信、一个接口一分钟限制多少请求、一个接口一天限制调用多少次等等。</p><h3 id="分布式锁">分布式锁<a class="" href="#分布式锁"></a></h3><p>这个主要利用redis的setnx命令进行，setnx："set if not exists"就是如果不存在则成功设置缓存同时返回1，否则返回0 ，这个特性在很多后台中都有所运用，因为我们服务器是集群的，定时任务可能在两台机器上都会运行，所以在定时任务中首先 通过setnx设置一个lock， 如果成功设置则执行，如果没有成功设置，则表明该定时任务已执行。 当然结合具体业务，我们可以给这个lock加一个过期时间，比如说30分钟执行一次的定时任务，那么这个过期时间设置为小于30分钟的一个时间就可以，这个与定时任务的周期以及定时任务执行消耗时间相关。</p><p>在分布式锁的场景中，主要用在比如秒杀系统等。</p><h3 id="延时操作">延时操作<a class="" href="#延时操作"></a></h3><p>比如在订单生产后我们占用了库存，10分钟后去检验用户是否真正购买，如果没有购买将该单据设置无效，同时还原库存。 由于redis自2.8.0之后版本提供Keyspace Notifications功能，允许客户订阅Pub/Sub频道，以便以某种方式接收影响Redis数据集的事件。 所以我们对于上面的需求就可以用以下解决方案，我们在订单生产时，设置一个key，同时设置10分钟后过期， 我们在后台实现一个监听器，监听key的实效，监听到key失效时将后续逻辑加上。</p><p>当然我们也可以利用rabbitmq、activemq等消息中间件的延迟队列服务实现该需求。</p><h3 id="排行榜相关问题">排行榜相关问题<a class="" href="#排行榜相关问题"></a></h3><p>关系型数据库在排行榜方面查询速度普遍偏慢，所以可以借助redis的SortedSet进行热点数据的排序。</p><p>比如点赞排行榜，做一个SortedSet, 然后以用户的openid作为上面的username, 以用户的点赞数作为上面的score, 然后针对每个用户做一个hash, 通过zrangebyscore就可以按照点赞数获取排行榜，然后再根据username获取用户的hash信息，这个当时在实际运用中性能体验也蛮不错的。</p><h3 id="点赞、好友等相互关系的存储">点赞、好友等相互关系的存储<a class="" href="#点赞、好友等相互关系的存储"></a></h3><p>Redis 利用集合的一些命令，比如求交集、并集、差集等。</p><p>在微博应用中，每个用户关注的人存在一个集合中，就很容易实现求两个人的共同好友功能。</p><h3 id="简单队列">简单队列<a class="" href="#简单队列"></a></h3><p>由于Redis有list push和list pop这样的命令，所以能够很方便的执行队列操作。</p><h2 id="参考文章">参考文章<a class="" href="#参考文章"></a></h2><ul><li>https://baike.baidu.com/item/Redis/6549233?fr=aladdin</li><li>https://zhuanlan.zhihu.com/p/29665317</li><li>https://www.jianshu.com/p/40dbc78711c8</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MySQL数据类型</title>
      <link href="/post/164885534/"/>
      <url>/post/164885534/</url>
      
        <content type="html"><![CDATA[<h2 id="字段类型">字段类型<a class="" href="#字段类型"></a></h2><h3 id="整型">整型<a class="" href="#整型"></a></h3><p>TINYINT, SMALLINT, MEDIUMINT, INT, BIGINT 分别使用 8, 16, 24, 32, 64 位存储空间，一般情况下越小的列越好。</p><p>INT(11) 中的数字只是规定了交互工具显示字符的个数，对于存储和计算来说是没有意义的。</p><h3 id="浮点数">浮点数<a class="" href="#浮点数"></a></h3><p>FLOAT 和 DOUBLE 为浮点类型，DECIMAL 为高精度小数类型。CPU 原生支持浮点运算，但是不支持 DECIMAl 类型的计算，因此 DECIMAL 的计算比浮点类型需要更高的代价。</p><p>FLOAT、DOUBLE 和 DECIMAL 都可以指定列宽，例如 DECIMAL(18, 9) 表示总共 18 位，取 9 位存储小数部分，剩下 9 位存储整数部分。</p><h3 id="字符串">字符串<a class="" href="#字符串"></a></h3><p>主要有 CHAR 和 VARCHAR 两种类型，一种是定长的，一种是变长的。</p><p>VARCHAR 这种变长类型能够节省空间，因为只需要存储必要的内容。但是在执行 UPDATE 时可能会使行变得比原来长，当超出一个页所能容纳的大小时，就要执行额外的操作。MyISAM 会将行拆成不同的片段存储，而 InnoDB 则需要分裂页来使行放进页内。</p><p>VARCHAR 会保留字符串末尾的空格，而 CHAR 会删除。</p><h3 id="时间和日期">时间和日期<a class="" href="#时间和日期"></a></h3><p>MySQL 提供了两种相似的日期时间类型: DATETIME 和 TIMESTAMP。</p><h4 id="1-DATETIME">1. DATETIME<a class="" href="#1-DATETIME"></a></h4><p>能够保存从 1001 年到 9999 年的日期和时间，精度为秒，使用 8 字节的存储空间。</p><p>它与时区无关。</p><p>默认情况下，MySQL 以一种可排序的、无歧义的格式显示 DATETIME 值，例如“2008-01-16 22:37:08”，这是 ANSI 标准定义的日期和时间表示方法。</p><h4 id="2-TIMESTAMP">2. TIMESTAMP<a class="" href="#2-TIMESTAMP"></a></h4><p>和 UNIX 时间戳相同，保存从 1970 年 1 月 1 日午夜(格林威治时间)以来的秒数，使用 4 个字节，只能表示从 1970 年 到 2038 年。</p><p>它和时区有关，也就是说一个时间戳在不同的时区所代表的具体时间是不同的。</p><p>MySQL 提供了 FROM_UNIXTIME() 函数把 UNIX 时间戳转换为日期，并提供了 UNIX_TIMESTAMP() 函数把日期转换为 UNIX 时间戳。</p><p>默认情况下，如果插入时没有指定 TIMESTAMP 列的值，会将这个值设置为当前时间。</p><p>应该尽量使用 TIMESTAMP，因为它比 DATETIME 空间效率更高。</p><h2 id="选择优化的数据类型">选择优化的数据类型<a class="" href="#选择优化的数据类型"></a></h2><ul><li>更小的通常更好；更小的数据类型通常更快，因为它们占用更少的磁盘、内存和CPU缓存，并且处理时需要的CPU周期也更少；</li><li>简单就好；例如，整形比字符串操作代价更低；实用内建类型而不是字符串来存储日期和时间；用整形存储IP地址等；</li><li>尽量避免NULL；如果查询中包含可为NULL的列，对MySQL来说更难优化，因为可为NULL 的列使得索引、索引统计和值比较都更复杂。尽管把可为NULL的列改为NOT NULL带来的性能提升比较小，但如果计划在列上创建索引，就应该尽量避免设计成可为NULL的列；</li></ul><h3 id="字符串类型">字符串类型<a class="" href="#字符串类型"></a></h3><h4 id="VARCHAR-和-CHAR">VARCHAR 和 CHAR<a class="" href="#VARCHAR-和-CHAR"></a></h4><p>VARCHAR是最常见的字符串类型。VARCHAR节省了存储空间，所以对性能也有帮助。但是，由于行是可变的，在UPDATE时可能使行变得比原来更长，这就导致需要做额外的工作。如果一个行占用的空间增长，并且在页内没有更多的空间可以存储，MyISAM会将行拆成不同的片段存储；InnoDB则需要分裂页来使行可以放进页内。</p><p>下面这些情况使用VARCHAR是合适的：字符串的最大长度比平均长度大很多；列的更新很少，所以碎片不是问题；使用了像UTF-8这样复杂的字符集，每个字符都使用不同的字节数进行存储。</p><p>当存储CHAR值时，MySQL会删除所有的末尾空格。CHAR值会根据需要采用空格进行填充以方便比较。</p><p>CHAR适合存储很短的字符串，或者所有值都接近同一个长度，如密码的MD5值。对于经常变更的数据，CHAR也比VARCHAR更好，因为CHAR不容易产生碎片（行间碎片？）。</p><h4 id="VARCHAR-5-和VARCHAR-200">VARCHAR(5)和VARCHAR(200)<a class="" href="#VARCHAR-5-和VARCHAR-200"></a></h4><blockquote><p>使用VARCHAR(5)和VARCHAR(200)存储"hello"的空间开销是一样的。那么使用更短的列有什么优势吗？</p></blockquote><p>事实证明有很大的优势。更长的列会消耗更多的内存，因为MySQL通常会分配固定大小的内存块来保存内部值。尤其是使用内存临时表进行排序或其他操作时会特别糟糕。在利用磁盘临时表进行排序时也同样糟糕。</p><p>所以最好的策略是只分配真正需要的空间。</p><h4 id="BLOB-和-TEXT">BLOB 和 TEXT<a class="" href="#BLOB-和-TEXT"></a></h4><p>BLOB和TEXT都是为存储很大的数据而设计的数据类型，分别采用二进制和字符方式存储。</p><p>与其他类型不同，MySQL把每个BLOB和TEXT值当做一个独立的对象去处理。当BLOB和TEXT值太大时，InnoDB会使用专门的“外部”存储区域来进行存储，此时每个值在行内需要1~4个字节存储一个指针，然后在外部存储区域存储实际的值。</p><p>MySQL对BLOB和TEXT列进行排序与其他类型是不同的：它只对每个列的最前max_sort_length个字节而不是整个字符串做排序。同样的，MySQL也不能将BLOB或TEXT列全部长度的字符串进行索引。</p><h3 id="选择表示符（identifier）">选择表示符（identifier）<a class="" href="#选择表示符（identifier）"></a></h3><p>整数类型通常是标识列的最佳选择，因为它们很快并且可以使用AUTO_INCREMENT。 如果可能，应该避免使用字符串类型作为标识列，因为它们很耗空间，并且比数字类型慢。 对于完全随机的字符串也需要多加注意，例如MD5(),SHA1()或者UUID()产生的字符串。这些函数生成的新值会任意分布在很大的空间内，这会导致INSERT以及一些SELECT语句变得很慢：</p><ul><li>因为插入值会随机的写入到索引的不同位置，所以使得INSERT语句更慢。这会导致叶分裂、磁盘随机访问。</li><li>SELECT语句会变的更慢，因为逻辑上相邻的行会分布在磁盘和内存的不同地方。</li><li>随机值导致缓存对所有类型的查询语句效果都很差，因为会使得缓存赖以工作的局部性原理失效。</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>集合框架总览</title>
      <link href="/post/164885512/"/>
      <url>/post/164885512/</url>
      
        <content type="html"><![CDATA[<h2 id="知识体系结构">知识体系结构<a class="" href="#知识体系结构"></a></h2><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/2022/04/java_collections_overview.png" alt="java_collections_overview"></p><h2 id="介绍">介绍<a class="" href="#介绍"></a></h2><p>容器，就是可以容纳其他Java对象的对象。*Java Collections Framework(JCF)*为Java开发者提供了通用的容器，其始于JDK 1.2，优点是:</p><ul><li>降低编程难度</li><li>提高程序性能</li><li>提高API间的互操作性</li><li>降低学习难度</li><li>降低设计和实现相关API的难度</li><li>增加程序的重用性</li></ul><p>Java容器里只能放对象，对于基本类型(int, long, float, double等)，需要将其包装成对象类型后(Integer, Long, Float, Double等)才能放到容器里。很多时候拆包装和解包装能够自动完成。这虽然会导致额外的性能和空间开销，但简化了设计和编程。</p><h2 id="Collection">Collection<a class="" href="#Collection"></a></h2><blockquote><p>容器主要包括 Collection 和 Map 两种，Collection 存储着对象的集合，而 Map 存储着键值对(两个对象)的映射表。</p></blockquote><h3 id="Set">Set<a class="" href="#Set"></a></h3><h4 id="TreeSet">TreeSet<a class="" href="#TreeSet"></a></h4><p>基于红黑树实现，支持有序性操作，例如根据一个范围查找元素的操作。但是查找效率不如 HashSet，HashSet 查找的时间复杂度为 O(1)，TreeSet 则为 O(logN)。</p><h4 id="HashSet">HashSet<a class="" href="#HashSet"></a></h4><p>基于哈希表实现，支持快速查找，但不支持有序性操作。并且失去了元素的插入顺序信息，也就是说使用 Iterator 遍历 HashSet 得到的结果是不确定的。</p><h4 id="LinkedHashSet">LinkedHashSet<a class="" href="#LinkedHashSet"></a></h4><p>具有 HashSet 的查找效率，且内部使用双向链表维护元素的插入顺序。</p><h3 id="List">List<a class="" href="#List"></a></h3><h4 id="ArrayList">ArrayList<a class="" href="#ArrayList"></a></h4><p>基于动态数组实现，支持随机访问。</p><h4 id="Vector">Vector<a class="" href="#Vector"></a></h4><p>和 ArrayList 类似，但它是线程安全的。</p><h4 id="LinkedList">LinkedList<a class="" href="#LinkedList"></a></h4><p>基于双向链表实现，只能顺序访问，但是可以快速地在链表中间插入和删除元素。不仅如此，LinkedList 还可以用作栈、队列和双向队列。</p><h3 id="Queue">Queue<a class="" href="#Queue"></a></h3><h4 id="LinkedList-2">LinkedList<a class="" href="#LinkedList-2"></a></h4><p>可以用它来实现双向队列。</p><h4 id="PriorityQueue">PriorityQueue<a class="" href="#PriorityQueue"></a></h4><p>基于堆结构实现，可以用它来实现优先队列。</p><h2 id="Map">Map<a class="" href="#Map"></a></h2><h3 id="TreeMap">TreeMap<a class="" href="#TreeMap"></a></h3><p>基于红黑树实现。</p><h3 id="HashMap">HashMap<a class="" href="#HashMap"></a></h3><p>基于哈希表实现。</p><h3 id="HashTable">HashTable<a class="" href="#HashTable"></a></h3><p>和 HashMap 类似，但它是线程安全的，这意味着同一时刻多个线程可以同时写入 HashTable 并且不会导致数据不一致。它是遗留类，不应该去使用它。现在可以使用 ConcurrentHashMap 来支持线程安全，并且 ConcurrentHashMap 的效率会更高，因为 ConcurrentHashMap 引入了分段锁。</p><h3 id="LinkedHashMap">LinkedHashMap<a class="" href="#LinkedHashMap"></a></h3><p>使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用(LRU)顺序。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 集合框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java 集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>概述</title>
      <link href="/post/164885658/"/>
      <url>/post/164885658/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是数据结构">什么是数据结构<a class="" href="#什么是数据结构"></a></h1><h2 id="数据">数据<a class="" href="#数据"></a></h2><p>数据是描述客观世界中的数字、字符以及一切能输入到计算机中，并且能够被计算机程序处理的符号集合。是信息的载体。</p><h2 id="数据元素">数据元素<a class="" href="#数据元素"></a></h2><p>数据元素是能够独立、完整的描述问题世界中的实体的最小数据单位，它是数据这个集合中一个个的元素。数据元素也成为数据节点，或者简称为节点。</p><h2 id="数据对象">数据对象<a class="" href="#数据对象"></a></h2><p>一个数据对象被定义为具有相同性质的数据元素的集合。它是数据这个集合的一个子集。</p><h2 id="结构">结构<a class="" href="#结构"></a></h2><p>数据元素之间存在这某种联系，这种联系称为结构。数据结构是具有某种结构的数据的集合。</p><p>数据结构的一个形式化的描述。数据结构是一个二元组</p><p><code>Data-Structure=(D,R)</code></p><p>其中 D 是数据元素的有限集合，R 是 D 上关系的集合。</p><h3 id="逻辑结构">逻辑结构<a class="" href="#逻辑结构"></a></h3><p>数据元素之间的逻辑关系，称为数据的逻辑结构。</p><h4 id="集合结构">集合结构<a class="" href="#集合结构"></a></h4><p>集合结构中的数据元素除了同属于一个集合外，它们之间没有其他关系。各个数据元素是“平等”的，它们的共同属性是“同属于一个集合”。</p><h4 id="线性结构">线性结构<a class="" href="#线性结构"></a></h4><p>线性结构中的数据元素是一对一的关系。除了第一个元素和最后一个元素之外，其余元素有且仅有一个前驱元素及有且仅有一个后继元素，即所有的元素依次排列在一个线性序列中。</p><h4 id="树形结构">树形结构<a class="" href="#树形结构"></a></h4><p>树形结构中的数据元素之间存在一种一对多的层次关系</p><h4 id="图形结构">图形结构<a class="" href="#图形结构"></a></h4><p>图形结构的数据元素是多对多的关系</p><h3 id="物理结构">物理结构<a class="" href="#物理结构"></a></h3><p>数据结构在计算机中的表示称为数据的物理结构，也称为数据的存储结构。</p><h4 id="顺序储存结构">顺序储存结构<a class="" href="#顺序储存结构"></a></h4><p>在计算机储存器中用一片连续的储存单元（储存单元之前不能有间隔）依次存放数据元素信息，数据元素的逻辑关系通过数据元素的存储地址直接反应。</p><p>顺序存储结构的优点是简单，易理解，并且实际占用最少的存储空间；缺点是需要占用一片地址连续的整块空间，并且存储分配要事先进行；另外，对于一些操作的时间效率较低也是这种存储结构的主要缺陷之一。</p><h4 id="链式结构">链式结构<a class="" href="#链式结构"></a></h4><p>链式存储结构是指在计算机存储器中用一片地址任意的（连续的或者不连续的）存储单元依次存放数据元素的信息，一般称每个数据元素占用的若干存储单元的组合为一个链结点。每个链结点中不仅要存放一个数据元素的数据信息，还要存放一个指出这个元素在逻辑关系中的直接后继元素所在链结点的地址，该地址被称为指针。这就是说，数据元素之间的逻辑关系通过指针间接地反映。由于不要求存储空间地址连续，因此，逻辑上相邻的数据元素在物理上不一定相邻。链式存储结构也称链表结构，简称链表。</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/2021/12/202112292354image-20211229235446067.png" alt="连接结构"></p><p>链式存储结构的优点是存储空间不必事先分配，在需要存储空间时可以临时申请，不会造成存储空间的浪费。所以像插人和删除这样操作的时间效率采用链式存储结构远比采用顺序存储结构要高。但在这种存储结构中，不仅数据元素本身的数据信息需要占用存储空间，而且指针也有存储空间的开销，因此，从这一点来说，链式存储结构要比顺序存储结构的空间开销大。</p><blockquote><p>数据的逻辑结构可以独立于数据的存储结构，这是因为数据的逻辑结构设计是在数据分析阶段进行的，而数据的存储结构设计是在数据的设计阶段进行的。反之，数据的存储结构不能独立于数据的逻辑结构，这是因为数据的存储结构是数据的逻辑结构在计算机存储中的映像。</p></blockquote><h1 id="算法">算法<a class="" href="#算法"></a></h1><p>算法是用来解决某个课题的一些指令的集合。简单来说，算法就是解决问题的方法</p><h2 id="算法的基本特征：">算法的基本特征：<a class="" href="#算法的基本特征："></a></h2><ul><li>输入</li><li>输出</li><li>有穷性</li><li>确定性</li><li>有效性</li></ul><h2 id="算法效率的度量方法">算法效率的度量方法<a class="" href="#算法效率的度量方法"></a></h2><h3 id="事后统计方法">事后统计方法<a class="" href="#事后统计方法"></a></h3><p>这种方法主要是通过设计好的测试程序和数据，利用计算机计时器对不同算法编制的程序的运行时间进行比较，从而确定算法效率的高低。这种方法显然是有很大缺陷的：</p><ul><li>必须依据算法事先编制好程序，这通常需要花费大量的时间和精力。如果编制出来发现它根本是很糟糕的算法，不是竹篮打水一场空吗？</li><li>时间的比较依赖计算机硬件和软件等环境因素，有时会掩盖算法本身的优劣。要知道，现在的一台四核处理器的计算机，跟当年286、386、486等老爷爷辈的机器相比，在处理算法的运算速度上，是不能相提并论的；而所用的操作系统、编译器、运行框架等软件的不同，也可以影响它们的结果；就算是同一台机器，CPU使用率和内存占用情况不一样，也会造成细微的差异。</li><li>算法的测试数据设计困难，并且程序的运行时间往往还与测试数据的规模有很大关系，效率高的算法在小的测试数据面前往往得不到体现。比如10个数字的排序，不管用什么算法，差异几乎是零。而如果有一百万个随机数字排序，那不同算法的差异就非常大了。那么我们为了比较算法，到底用多少数据来测试，这是很难判断的问题</li></ul><h3 id="事前分析估算方法">事前分析估算方法<a class="" href="#事前分析估算方法"></a></h3><p>在计算机程序编制前，依据统计方法对算法进行估算。</p><h3 id="时间复杂度">时间复杂度<a class="" href="#时间复杂度"></a></h3><p>在进行算法分析时，语句总的执行次数T(n)是关于问题规模n的函数，进而分析T(n)随n的变化情况并确定T(n)的数量级。算法的时间复杂度，也就是算法的时间量度，记作：T(n)=O(f(n))。它表示随问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同，称作算法的渐近时间复杂度，简称为时间复杂度。其中f(n)是问题规模n的某个函数。</p><p>这样用大写O( )来体现算法时间复杂度的记法，我们称之为大O记法。</p><h3 id="空间复杂度">空间复杂度<a class="" href="#空间复杂度"></a></h3><p>算法的空间复杂度通过计算算法所需的存储空间实现，算法空间复杂度的计算公式记作：S(n)=O(f(n))，其中，n为问题的规模，f(n)为语句关于n所占存储空间的函数。</p><p>因此，数据结构课程所要研究的主要内容可以简要地归纳为以下3个方面。</p><ol><li>研究数据元素之间固有的客观联系（逻辑结构）。</li><li>研究数据在计算机内部的存储方法（存储结构）。</li><li>研究在数据的各种结构（逻辑的和物理的）的基础上如何对数据实施有效的操作或处理（算法）。</li></ol><h1 id="课后题">课后题<a class="" href="#课后题"></a></h1><h2 id="选择题">选择题<a class="" href="#选择题"></a></h2><ol><li><p>以下关于数据结构的叙述中,错误的是</p><ul class="task-checkbox-list"><li class="task-checkbox-list-item"><input type="checkbox" id="cbx_0" disabled="true"><label for="cbx_0"> A. 数据结构涉及数据的逻辑结构存储结构和施加其上的操作3个方面</label></li><li class="task-checkbox-list-item"><input type="checkbox" id="cbx_1" disabled="true"><label for="cbx_1"> B. 施加在数据结构上的操作的具体实现与数据的存储结构有关</label></li><li class="task-checkbox-list-item"><input type="checkbox" id="cbx_2" disabled="true"><label for="cbx_2"> C. 定义数据的逻辑结构时可以不考虑数据的存储结构</label></li><li class="task-checkbox-list-item"><input type="checkbox" id="cbx_3" checked="true" disabled="true"><label for="cbx_3"> <mark>D. 数据结构相同,对应的存储结构也必然相同</mark></label></li></ul></li><li><p>以下关于数据结构的叙述中,<mark>正确</mark>的是</p><ul class="task-checkbox-list"><li class="task-checkbox-list-item"><input type="checkbox" id="cbx_4" disabled="true"><label for="cbx_4"> A.数据的存储结构独立于该数据的逻辑结构</label></li><li class="task-checkbox-list-item"><input type="checkbox" id="cbx_5" checked="true" disabled="true"><label for="cbx_5"> <mark>B.数据的逻辑结构独立于该数据的存储结构</mark></label></li><li class="task-checkbox-list-item"><input type="checkbox" id="cbx_6" disabled="true"><label for="cbx_6"> C.数据的逻辑结构唯一地决定了该数据的存储结构</label></li><li class="task-checkbox-list-item"><input type="checkbox" id="cbx_7" disabled="true"><label for="cbx_7"> D.数据结构仅由数据的逻辑结构和存储结构决定</label></li></ul></li><li><p>数据结构研究的内容不涉及</p><ul class="task-checkbox-list"><li class="task-checkbox-list-item"><input type="checkbox" id="cbx_8" disabled="true"><label for="cbx_8"> A.数据如何组织</label></li><li class="task-checkbox-list-item"><input type="checkbox" id="cbx_9" disabled="true"><label for="cbx_9"> B.数据如何存储</label></li><li class="task-checkbox-list-item"><input type="checkbox" id="cbx_10" checked="true" disabled="true"><label for="cbx_10"> <mark>C.采用何种语言描述算法</mark></label></li><li class="task-checkbox-list-item"><input type="checkbox" id="cbx_11" disabled="true"><label for="cbx_11"> D.数据的运算如何实现</label></li></ul></li><li><p>在数据结构中,数据元素之间存在的逻辑关系称为</p><ul class="task-checkbox-list"><li class="task-checkbox-list-item"><input type="checkbox" id="cbx_12" checked="true" disabled="true"><label for="cbx_12"> <mark>A.数据的逻辑结构</mark></label></li><li class="task-checkbox-list-item"><input type="checkbox" id="cbx_13" disabled="true"><label for="cbx_13"> B.数据的存储结构</label></li><li class="task-checkbox-list-item"><input type="checkbox" id="cbx_14" disabled="true"><label for="cbx_14"> C.对数据实施的基本操作</label></li><li class="task-checkbox-list-item"><input type="checkbox" id="cbx_15" disabled="true"><label for="cbx_15"> D.对数据实施的算法</label></li></ul></li><li><p>从逻辑上可以把数据结构分为</p><ul class="task-checkbox-list"><li class="task-checkbox-list-item"><input type="checkbox" id="cbx_16" disabled="true"><label for="cbx_16"> A.动态结构和静态结构</label></li><li class="task-checkbox-list-item"><input type="checkbox" id="cbx_17" checked="true" disabled="true"><label for="cbx_17"> <mark>B.线性结构和非线性结构</mark></label></li><li class="task-checkbox-list-item"><input type="checkbox" id="cbx_18" disabled="true"><label for="cbx_18"> C.内部结构和外部结构</label></li><li class="task-checkbox-list-item"><input type="checkbox" id="cbx_19" disabled="true"><label for="cbx_19"> D.紧凑结构和非紧凑结构</label></li></ul></li><li><p>数据的存储结构包括</p><ul class="task-checkbox-list"><li class="task-checkbox-list-item"><input type="checkbox" id="cbx_20" disabled="true"><label for="cbx_20"> A.顺序存储结构和链式存储结构</label></li><li class="task-checkbox-list-item"><input type="checkbox" id="cbx_21" disabled="true"><label for="cbx_21"> B.顺序存储结构、链式存储结构和索引存储结构</label></li><li class="task-checkbox-list-item"><input type="checkbox" id="cbx_22" disabled="true"><label for="cbx_22"> C.顺序存储结构、链式存储结构和散列存储结构</label></li><li class="task-checkbox-list-item"><input type="checkbox" id="cbx_23" checked="true" disabled="true"><label for="cbx_23"> <mark>D.顺序存储结构、链式存储结构、索引存储结构和散列存储结构</mark></label></li></ul></li><li><p>描述数据的存储结构时不需要知道</p><ul class="task-checkbox-list"><li class="task-checkbox-list-item"><input type="checkbox" id="cbx_24" checked="true" disabled="true"><label for="cbx_24"> <mark>A.计算机内存芯片的有关参数</mark></label></li><li class="task-checkbox-list-item"><input type="checkbox" id="cbx_25" disabled="true"><label for="cbx_25"> B.数据元素如何构成</label></li><li class="task-checkbox-list-item"><input type="checkbox" id="cbx_26" disabled="true"><label for="cbx_26"> C.数据元素的类型</label></li><li class="task-checkbox-list-item"><input type="checkbox" id="cbx_27" disabled="true"><label for="cbx_27"> D.使用何种算法描述语言</label></li></ul></li><li><p>在选择何种存储结构时,一般不考虑</p><ul class="task-checkbox-list"><li class="task-checkbox-list-item"><input type="checkbox" id="cbx_28" disabled="true"><label for="cbx_28"> A.对数据可以实施哪些操作</label></li><li class="task-checkbox-list-item"><input type="checkbox" id="cbx_29" disabled="true"><label for="cbx_29"> B.所用编程语言实现这种结构是否方便</label></li><li class="task-checkbox-list-item"><input type="checkbox" id="cbx_30" checked="true" disabled="true"><label for="cbx_30"> <mark>C.数据元素的值如何</mark></label></li><li class="task-checkbox-list-item"><input type="checkbox" id="cbx_31" disabled="true"><label for="cbx_31"> D.数据元素的数目多少</label></li></ul></li><li><p>若数据采用顺序存储结构,则要求</p><ul class="task-checkbox-list"><li class="task-checkbox-list-item"><input type="checkbox" id="cbx_32" disabled="true"><label for="cbx_32"> A.存储的是属于线性结构的数据</label></li><li class="task-checkbox-list-item"><input type="checkbox" id="cbx_33" disabled="true"><label for="cbx_33"> B.根据数据元素值的大小有序地存放各数据元素</label></li><li class="task-checkbox-list-item"><input type="checkbox" id="cbx_34" disabled="true"><label for="cbx_34"> C.按照存储单元地址由低到高的顺序存放各数据元素</label></li><li class="task-checkbox-list-item"><input type="checkbox" id="cbx_35" checked="true" disabled="true"><label for="cbx_35"> <mark>D.用地址连续的存储空间依次存储元素,并能隐含地表示元素之间的逻辑关系</mark></label></li></ul></li><li><p>若数据采用链式存储结构,则要求</p><ul class="task-checkbox-list"><li class="task-checkbox-list-item"><input type="checkbox" id="cbx_36" checked="true" disabled="true"><label for="cbx_36"> <mark>A.每个链结点占用一片地址连续的存储空间</mark></label></li><li class="task-checkbox-list-item"><input type="checkbox" id="cbx_37" disabled="true"><label for="cbx_37"> B.所有的链结点占用一片地址连续的存储空间</label></li><li class="task-checkbox-list-item"><input type="checkbox" id="cbx_38" disabled="true"><label for="cbx_38"> C.链结点的最后那个域一定是指针域</label></li><li class="task-checkbox-list-item"><input type="checkbox" id="cbx_39" disabled="true"><label for="cbx_39"> D.每个链结点有多少个后继结点,链结点中就应该设置多少个指针域</label></li></ul></li><li><p>对于索引存储结构而言,</p><ul class="task-checkbox-list"><li class="task-checkbox-list-item"><input type="checkbox" id="cbx_40" checked="true" disabled="true"><label for="cbx_40"> <mark>A.它是利用数据元素的索引关系来确定数据元素存储位置的一种存储结构</mark></label></li><li class="task-checkbox-list-item"><input type="checkbox" id="cbx_41" disabled="true"><label for="cbx_41"> B.它不一定包括索引表与基本数据两个部分</label></li><li class="task-checkbox-list-item"><input type="checkbox" id="cbx_42" disabled="true"><label for="cbx_42"> C.索引表中只包括数据元素本身</label></li><li class="task-checkbox-list-item"><input type="checkbox" id="cbx_43" disabled="true"><label for="cbx_43"> D.索引表中的索引项的排列是任意的</label></li></ul></li><li><p>对于散列存储结构而言,</p><ul class="task-checkbox-list"><li class="task-checkbox-list-item"><input type="checkbox" id="cbx_44" disabled="true"><label for="cbx_44"> A.必须使用一对一的散列函数</label></li><li class="task-checkbox-list-item"><input type="checkbox" id="cbx_45" disabled="true"><label for="cbx_45"> B.它是根据元素的种类确定元素的存储位置</label></li><li class="task-checkbox-list-item"><input type="checkbox" id="cbx_46" checked="true" disabled="true"><label for="cbx_46"> <mark>C.它是根据函数关系确定元素的存储位置的一种存储结构</mark></label></li><li class="task-checkbox-list-item"><input type="checkbox" id="cbx_47" disabled="true"><label for="cbx_47"> D.相邻存储单元中存放的元素,其值一定是连续的</label></li></ul></li><li><p>算法指的是</p><ul class="task-checkbox-list"><li class="task-checkbox-list-item"><input type="checkbox" id="cbx_48" disabled="true"><label for="cbx_48"> A.用计算机语言描述的程序</label></li><li class="task-checkbox-list-item"><input type="checkbox" id="cbx_49" disabled="true"><label for="cbx_49"> B.解决问题的计算方法</label></li><li class="task-checkbox-list-item"><input type="checkbox" id="cbx_50" disabled="true"><label for="cbx_50"> C.对数据进行的查找或者排序的方法</label></li><li class="task-checkbox-list-item"><input type="checkbox" id="cbx_51" checked="true" disabled="true"><label for="cbx_51"> <mark>D.解决问题的一系列有限的基本步骤</mark></label></li></ul></li><li><p>下面关于算法与程序的叙述中,错误的是</p><ul class="task-checkbox-list"><li class="task-checkbox-list-item"><input type="checkbox" id="cbx_52" disabled="true"><label for="cbx_52"> A.程序是用计算机语言表达的算法</label></li><li class="task-checkbox-list-item"><input type="checkbox" id="cbx_53" disabled="true"><label for="cbx_53"> B.流程图是一种图形化的算法</label></li><li class="task-checkbox-list-item"><input type="checkbox" id="cbx_54" disabled="true"><label for="cbx_54"> C.程序就是算法,但算法不一定是程序</label></li><li class="task-checkbox-list-item"><input type="checkbox" id="cbx_55" checked="true" disabled="true"><label for="cbx_55"> <mark>D.算法与程序都独立于具体的计算机与具体的程序设计语言</mark></label></li></ul></li><li><p>算法的时间复杂度主要与</p><ul class="task-checkbox-list"><li class="task-checkbox-list-item"><p><input type="checkbox" id="cbx_56" disabled="true"><label for="cbx_56"> A.编译程序的质量有关</label></p></li><li class="task-checkbox-list-item"><p><input type="checkbox" id="cbx_57" disabled="true"><label for="cbx_57"> B.程序设计语言有关</label></p></li><li class="task-checkbox-list-item"><p><input type="checkbox" id="cbx_58" checked="true" disabled="true"><label for="cbx_58"> <mark>C.所解决的问题的规模有关</mark></label></p></li><li class="task-checkbox-list-item"><p><input type="checkbox" id="cbx_59" disabled="true"><label for="cbx_59"> D.计算机的硬件性能有关</label></p></li></ul></li><li><p>对算法进行分析的前提是</p><ul class="task-checkbox-list"><li class="task-checkbox-list-item"><input type="checkbox" id="cbx_60" checked="true" disabled="true"><label for="cbx_60"> <mark>A.算法是正确的</mark></label></li><li class="task-checkbox-list-item"><input type="checkbox" id="cbx_61" disabled="true"><label for="cbx_61"> B.算法尽可能简单</label></li><li class="task-checkbox-list-item"><input type="checkbox" id="cbx_62" disabled="true"><label for="cbx_62"> C.算法运行的时间要短</label></li><li class="task-checkbox-list-item"><input type="checkbox" id="cbx_63" disabled="true"><label for="cbx_63"> D.算法占用的空间要少</label></li></ul></li><li><p>算法分析的目的是</p><ul class="task-checkbox-list"><li class="task-checkbox-list-item"><input type="checkbox" id="cbx_64" disabled="true"><label for="cbx_64"> A.研究算法中的输入与输出之间的关系</label></li><li class="task-checkbox-list-item"><input type="checkbox" id="cbx_65" disabled="true"><label for="cbx_65"> B.找出数据结构的合理性</label></li><li class="task-checkbox-list-item"><input type="checkbox" id="cbx_66" checked="true" disabled="true"><label for="cbx_66"> <mark>C.分析算法的效率,以求改进算法</mark></label></li><li class="task-checkbox-list-item"><input type="checkbox" id="cbx_67" disabled="true"><label for="cbx_67"> D.分析算法的可读性和简明性</label></li></ul></li><li><p>算法分析的主要任务是</p><ul class="task-checkbox-list"><li class="task-checkbox-list-item"><input type="checkbox" id="cbx_68" disabled="true"><label for="cbx_68"> A.分析算法是否具有较好的可读性</label></li><li class="task-checkbox-list-item"><input type="checkbox" id="cbx_69" checked="true" disabled="true"><label for="cbx_69"> <mark>B.分析算法的执行时间与问题规模之间的关系</mark></label></li><li class="task-checkbox-list-item"><input type="checkbox" id="cbx_70" disabled="true"><label for="cbx_70"> C.分析算法中是否存在语法错误</label></li><li class="task-checkbox-list-item"><input type="checkbox" id="cbx_71" disabled="true"><label for="cbx_71"> D.分析算法的功能是否符合设计要求</label></li></ul></li><li><p>计算算法的时间复杂度是属于一种</p><ul class="task-checkbox-list"><li class="task-checkbox-list-item"><input type="checkbox" id="cbx_72" disabled="true"><label for="cbx_72"> A.事前统计的方法</label></li><li class="task-checkbox-list-item"><input type="checkbox" id="cbx_73" checked="true" disabled="true"><label for="cbx_73"> <mark>B.事前分析估算的方法</mark></label></li><li class="task-checkbox-list-item"><input type="checkbox" id="cbx_74" disabled="true"><label for="cbx_74"> C.事后统计的方法</label></li><li class="task-checkbox-list-item"><input type="checkbox" id="cbx_75" disabled="true"><label for="cbx_75"> D.事后分析估算的方法</label></li></ul></li><li><p>若某算法的时间复杂度采用大O形式表示是O(n<sup>2</sup>),则表明该算法的</p><ul class="task-checkbox-list"><li class="task-checkbox-list-item"><input type="checkbox" id="cbx_76" disabled="true"><label for="cbx_76"> A.问题规模是n<sup>2</sup></label></li><li class="task-checkbox-list-item"><input type="checkbox" id="cbx_77" disabled="true"><label for="cbx_77"> B.执行时间等于n<sup>2</sup></label></li><li class="task-checkbox-list-item"><input type="checkbox" id="cbx_78" disabled="true"><label for="cbx_78"> C.问题规模与n<sup>2</sup>成正比</label></li><li class="task-checkbox-list-item"><input type="checkbox" id="cbx_79" checked="true" disabled="true"><label for="cbx_79"> <mark>D.执行时间与n<sup>2</sup>成正比</mark></label></li></ul></li></ol><h2 id="填空题">填空题<a class="" href="#填空题"></a></h2><ol><li>“数据结构”课程研究的主要内容包括 <u><mark>逻辑结构</mark></u>、<u><mark>存储结构</mark></u> 和 <u><mark>算法</mark></u> 这3个方面。</li><li>数据的逻辑结构是指<u><mark>数据元素在客观世界中存在的逻辑关系</mark></u>，而存储结构是指<u><mark>具有某种逻辑关系的数据在计算机存储器中的存储映像</mark></u>。</li><li>数据的逻辑结构可以分为<u><mark>线性结构</mark></u>和<u><mark>非线性结构</mark></u>两大类。</li><li>线性结构是指结构中数据元素之间存在的逻辑关系是 <u><mark>一对一</mark></u>的关系。</li><li>非线性结构是指结构中数据元素之间存在的逻辑关系是 <u><mark>一对多</mark></u>或者 <u><mark>多对一</mark></u>,甚至是<u><mark>多对多</mark></u>的关系。</li><li>逻辑上相邻的数据元素在物理位置上也相邻是 <u><mark>顺序</mark></u>存储结构的特点之一。</li><li>逻辑上相邻的数据元素在物理位置上不要求相邻是 <u><mark>链式</mark></u>存储结构的特点之一。</li><li>顺序存储结构利用数据元素的 <u><mark>存储地址</mark></u>直接地反映数据元素之间的逻辑结构</li><li>链式存储结构利用链结点的 <u><mark>指针</mark></u>间接地反映数据元素之间的逻辑结构。</li><li>若某算法的功能是完成对n个数据元素的处理,所需要的时间是T(n)=100nlog<sub>2</sub>n+200n+300,则该算法的时间复杂度用大O形式表示为 <u><mark>O(nlog<sub>2</sub>n)</mark></u></li></ol><h2 id="简答题">简答题<a class="" href="#简答题"></a></h2><ol><li><p>通常说,数据结构可以表示为一个二元组(D,R),其中DR分别代表什么?</p><p>D 代表数据元素的又穷集合。R 代表 D 上关系的集合。</p></li><li><p>通常情况下,数据的结构包括哪两种结构?</p><p>数据的逻辑结构和数据的存储结构。</p></li><li><p>数据的逻辑结构和数据的存储结构之间的关系是什么?</p><p>数据的逻辑结构面向所解决的问题，反映了数据内部的构成方式；而数据的存储结构面向计算机，目标是将数据及其逻辑关系存储到计算机存储器中。一般情况下，一种逻辑结构可以采用多种存储结构来存储，而采用不同的存储结构，其对数据处理的效率往往不同。</p></li><li><p>数据的逻辑结构是否可以独立于数据的存储结构来考虑?反之,数据的存储结构是否可以独立于数据的逻辑结构来考虑?</p><p>数据的逻辑结构可以独立于数据的存储结构，这是因为数据的逻辑结构设计是在数据分析阶段进行的，而数据的存储结构设计是在数据的设计阶段进行的。反之，数据的存储结构不能独立于数据的逻辑结构，这是因为数据的存储结构是数据的逻辑结构在计算机存储中的映像。</p></li><li><p>具有某种逻辑结构数据在不同的存储结构下对其实施某种操作,其操作的时间效率可能不同。这种说法正确吗?请举例说明。</p><p>这种说法正确。例如在长度为 n 的线性表中进行插入或者删除操作，当线性表采用顺序存储结构时，需要平均移动奖金一半的数据元素的位置，操作的时间复杂度为 O(n)，而在链式存储结构下，则不需要移动元素数据的位置，操作时间复杂度为 O(1)，与线性表的长度无关。</p></li><li><p>算法的基本特性之一是由算法的外部提供n≥0个有限量作为算法的输入。这里的0个输入表示什么意思?</p><p>这里的 0 个输入是指算法的输入不是通过键盘或者其他设备输入的，而是由算法的内部确定初始条件，或者通过算法内部诸如赋值语句等方式给出所需要的变量的初始值，被认为是一种特殊的输入。因此，在某些特殊情况下，一个算法可以没有输入。</p></li><li><p>“一个算法是正确的”是什么意思?</p><p>是指当输入一组合理的数据时，能够在有限的运行时间内得出正确的结果，对于不合理的输入数据，能够给出相应的警告提示信息。</p></li><li><p>衡量一个算法质量优劣的基本标准是什么?</p><p>衡量一个算法优劣的基本标准通常包括 5 个方面，分别是算法的正确性，算法的易读性，算法的健壮性，算法的可移植性及算法的时空效率。尤其第 5 个方面是要重点考虑的。</p></li><li><p>影响一个算法的时间效率的主要因素有哪些?</p><p>影响一个算法的时间效率的主要因素包括两个方面。其中解决问题的规模大小是影响算法时间效率的重要因素之一。两一个影响算法时间效率的重要原因是算法中执行基本操作的次数。</p></li><li><p>已知在同一运行环境下实现相同功能的两个算法A和B,其中算法A的时间复杂度为O(2<sup>n),算法B的时间复杂度为O(n</sup>2),仅就时间复杂度而言,哪一个算法更好?</p><p>分别对算法 A 和算法 B 的时间复杂度取对数，得到 nlog2 和 2logn，显然，当 n&lt;4时，算法 A 的时间复杂度不大于算法 B 的时间复杂度；当 n=4时，两个算法的时间复杂度相同；当 n&gt;4 时，算法 B 要好于算法 A。</p></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据结构教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>八、指针</title>
      <link href="/post/164885489/"/>
      <url>/post/164885489/</url>
      
        <content type="html"><![CDATA[<p>指针是 C 中最复杂的部分。</p><p>在这一节中，我们以最简单但又不模糊的方式介绍它们。</p><p>指针是某个内存块的地址，这个内存块包含一个变量。</p><p>像这样声明一个整数时：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> age = <span class="number">37</span>;</span><br></pre></td></tr></tbody></table></figure><p>我们可以使用 <code>&amp;</code> 运算符获取内存中该变量的地址值：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"%p"</span>, &amp;age); <span class="comment">/* 0x7ffeef7dcb9c */</span></span><br></pre></td></tr></tbody></table></figure><p>我在 <code>printf()</code> 内声明 <code>%p</code> 格式来打印地址值。</p><p>我们可以将该地址赋给一个变量：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> address = &amp;age;</span><br></pre></td></tr></tbody></table></figure><p>当在声明中使用 <code>int *address</code> 时，我们并没有在声明一个整数值，而是在声明一个 <strong>指向一个整数的指针</strong>。</p><p>我们可以使用指针运算符获取该地址指向的变量的值：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> age = <span class="number">37</span>;</span><br><span class="line"><span class="keyword">int</span> *address = &amp;age;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%u"</span>, *address); <span class="comment">/* 37 */</span></span><br></pre></td></tr></tbody></table></figure><p>我们又一次使用指针运算符，但是由于这次它不是一个声明，所以它表示“该指针指向的变量的值”。</p><p>在这个示例中，我们声明了一个 <code>age</code> 变量，但是我们使用了一个指针来初始化它的值：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">int</span> *address = &amp;age;</span><br><span class="line">*address = <span class="number">37</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%u"</span>, *address);</span><br></pre></td></tr></tbody></table></figure><p>在使用 C 时，很多东西都建立在这个简单的概念之上。所以我们需要自己运行一下上面的示例，来对加强对指针的了解。</p><p>指针可以迫使我们考虑内存地址以及数据是如何组织的。</p><p>数组就是一个例子。当我们声明一个数组时：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> prices[<span class="number">3</span>] = { <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span> };</span><br></pre></td></tr></tbody></table></figure><p><code>prices</code> 变量实际上是一个指向数组首个元素的指针。在这种情况下，可以使用这个 <code>printf()</code> 函数获取第一个数组元素的值：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"%u"</span>, *prices); <span class="comment">/* 5 */</span></span><br></pre></td></tr></tbody></table></figure><p>我们可以通过给 <code>prices</code> 指针加一来获取第二个元素：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"%u"</span>,`_ `(prices + <span class="number">1</span>)); <span class="comment">/* 4 */</span></span><br></pre></td></tr></tbody></table></figure><p>这种做法对于所有的其它值也适用。</p><p>我们还可以进行很多字符串操作，因为字符串的底层就是数组。</p><p>指针还有很多其它的使用场景，包括传递对象或函数的引用，从而避免消耗更多的资源来进行复制。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> C语言入门手册 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十、输入与输出</title>
      <link href="/post/164031793/"/>
      <url>/post/164031793/</url>
      
        <content type="html"><![CDATA[<p>C 是一门小型语言，并且 C 的“内核”并不包含任何输入/输出（I/O）功能。</p><p>当然，这并不是 C 所独有的。语言内核与 I/O 无关是很常见的。</p><p>在 C 中，输入/输出由 C 的标准库通过一组定义在 <code>stdio.h</code> 头文件中的函数向我们提供。</p><p>你可以在 C 文件顶部使用：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br></pre></td></tr></tbody></table></figure><p>导入这个库。</p><p>这个库给我们提供了很多其它的函数：</p><ul><li><code>printf()</code></li><li><code>scanf()</code></li><li><code>sscanf()</code></li><li><code>fgets()</code></li><li><code>fprintf()</code></li></ul><p>在描述这个函数干啥之前，我想先花一分钟讲一下 <strong>I/O 流</strong>。</p><p>在 C 中，我们有三种类型的 I/O 流：</p><ul><li><code>stdin</code>（标准输入）</li><li><code>stdout</code>（标准输出）</li><li><code>stderr</code>（标准错误）</li></ul><p>借助 I/O 函数，我们始终可以和流一起工作。流是一个高级接口，可以代表一个设备或文件。从 C 的角度来看，我们在从文件读取和命令行读取没有任何差异：不论如何，它都是一个 I/O 流。</p><p>那是我们需要牢记的一件事情。</p><p>某些函数是为与特定的流一起工作而设计的，就像 <code>printf()</code>一样，我们用它来将字符串打印到 <code>stdout</code>。使用它更加通用的版本 <code>fprintf()</code> 时，我们可以指定我们要写到的流。</p><p>由于我最开始谈论的是 <code>printf()</code>，咱们现在就介绍它吧。</p><p><code>printf()</code> 是你在学习 C 编程时最先使用的函数之一。</p><p>在它最简单的使用形式中，你给它传递一个字符串字面量：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"hey!"</span>);</span><br></pre></td></tr></tbody></table></figure><p>并且程序会将该字符串的内容打印到屏幕上。</p><p>你可以打印一个变量的值。但是这有点棘手，因为你需要添加一个特殊的字符，一个占位符，它会根据变量的类型变化。例如，我们为有符号十进制整数使用 <code>%d</code>：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> age = <span class="number">37</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"My age is %d"</span>, age);</span><br></pre></td></tr></tbody></table></figure><p>通过使用逗号，我现在可以打印多个变量：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> age_yesterday = <span class="number">37</span>;</span><br><span class="line"><span class="keyword">int</span> age_today = <span class="number">36</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Yesterday my age was %d and today is %d"</span>, age_yesterday, age_today);</span><br></pre></td></tr></tbody></table></figure><p>还有其它像 <code>%d</code> 一样的格式指示符：</p><ul><li><code>%c</code> 用于字符</li><li><code>%s</code> 用于字符串</li><li><code>%f</code> 用于浮点数</li><li><code>%p</code> 用于指针</li></ul><p>还有很多。</p><p>我们可以在 <code>printf()</code> 中使用转义字符，比如 <code>\n</code> 可以用来让输出创建一个新行。</p><h3 id="scanf"><code>scanf()</code><a class="" href="#scanf"></a></h3><p><code>printf()</code> 被用作输出函数。我现在想介绍一个输入函数，这样我们就能完成所有的 I/O 操作：<code>scanf()</code>。</p><p>这个函数被用来从用户运行的程序，从命令行获取一个值。</p><p>我们必须先定义一个变量，它将被用来存放我们从输入中获取的值：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> age;</span><br></pre></td></tr></tbody></table></figure><p>然后我们调用 <code>scanf()</code>，传入两个参数：变量的格式（类型），和变量的地址：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;age);</span><br></pre></td></tr></tbody></table></figure><p>如果我们想在输入时获取一个字符串，还记得字符串名是一个指向第一个字符的指针，所以你不需要在它前面加上 <code>&amp;</code>：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>, name);</span><br></pre></td></tr></tbody></table></figure><p>这里是一个小程序，它同时使用了 <code>printf()</code> 和 <code>scanf()</code>：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line">  <span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Enter your name: "</span>);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%s"</span>, name);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"you entered %s"</span>, name);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> C语言入门手册 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十一、变量作用域</title>
      <link href="/post/164885498/"/>
      <url>/post/164885498/</url>
      
        <content type="html"><![CDATA[<p>当你在 C 程序中定义一个变量时，根据你声明它的位置，它会有一个不同的 <strong>作用域（scope）</strong>。</p><p>这意味着它将会在某些地方可用，而在其它地方不可用。</p><p>该位置决定了两种类型的变量：</p><ul><li><strong>全局变量（global variables）</strong></li><li><strong>局部变量（local variables）</strong></li></ul><p>这就是区别：在函数内部声明的变量就是局部变量，比如这个：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line">  <span class="keyword">int</span> age = <span class="number">37</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>局部变量只有在函数内才能访问，它们会在函数结束后不复存在。它们会被从内存中清除掉（有一些例外）。</p><p>定义在函数外部的变量就是全局变量，比如这个示例：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> age = <span class="number">37</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>全局变量可以从程序中的任何一个函数访问，它们在整个程序的执行过程中都是可用的，直到程序结束。</p><p>我提到过局部变量在函数结束之后就不再可用。</p><p>原因是局部变量默认是在 <strong>栈（stack）</strong> 上声明的，除非你使用指针在堆中显式地分配它们。但是这样一来，你就不得不自己管理内存了。</p><h2 id="静态变量">静态变量<a class="" href="#静态变量"></a></h2><p>在函数内部，你可以使用 <code>static</code> 关键字初始化一个 <strong>静态变量（static variable）</strong>。</p><p>我说了“在函数内部”，因为全局变量默认就是静态的，所以没有必要再添加这个关键字。</p><p>什么是静态变量？静态变量在没有声明初始值的时候会被初始化为 0，并且它会在函数调用中保持该值。</p><p>考虑这个函数：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">incrementAge</span><span class="params">()</span> </span>{</span><br><span class="line">  <span class="keyword">int</span> age = <span class="number">0</span>;</span><br><span class="line">  age++;</span><br><span class="line">  <span class="keyword">return</span> age;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>如果我们调用一次 <code>incrementAge()</code>，我们将会得到返回值 <code>1</code>。如果我们再调用一次，我们总是会得到 1，因为 <code>age</code> 是一个局部变量并且在每次调用该函数的时候都会被重新初始化为 <code>0</code>。</p><p>如果我们将该函数改为：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">incrementAge</span><span class="params">()</span> </span>{</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> age = <span class="number">0</span>;</span><br><span class="line">  age++;</span><br><span class="line">  <span class="keyword">return</span> age;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>现在我们每调用一次这个函数，我们就会得到一个增加了的值：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, incrementAge());</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, incrementAge());</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, incrementAge());</span><br></pre></td></tr></tbody></table></figure><p>将会给我们：</p><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></tbody></table></figure><p>我们也可以在 <code>static int age = 0;</code> 中省略初始化 <code>age</code> 为 0 的代码，只写 <code>static int age;</code>，因为静态变量在创建时会自动设置为 0。</p><p>我们也可以有静态数组。这时，每一个数组元素都被初始化为 0：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">incrementAge</span><span class="params">()</span> </span>{</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> ages[<span class="number">3</span>];</span><br><span class="line">  ages[<span class="number">0</span>]++;</span><br><span class="line">  <span class="keyword">return</span> ages[<span class="number">0</span>];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="全局变量">全局变量<a class="" href="#全局变量"></a></h2><p>在这一节中，我想多谈论一点 <strong>全局变量与局部变量</strong> 之间的差异。</p><p><strong>局部变量</strong> 被定义在函数内部，只在该函数内可用。</p><p>就像这样：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line">  <span class="keyword">char</span> j = <span class="number">0</span>;</span><br><span class="line">  j += <span class="number">10</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%u"</span>, j); <span class="comment">//10</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>j</code> 在 <code>main</code> 函数之外的任何地方都不可用。</p><p><strong>全局变量</strong> 定义在所有函数的外部，就像这样：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line">  i += <span class="number">10</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%u"</span>, i); <span class="comment">//10</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>全局变量可以被程序内的任何函数访问。该访问并不只局限于读取全局变量的值：任何函数都可以更新全局变量的值。</p><p>因此，全局变量是一种在函数间共享相同数据的一种方式。</p><p>局部变量的主要不同在于，分配给局部变量的内存会在函数结束之后立即释放。</p><p>全局变量只在程序结束时才会释放。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> C语言入门手册 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十三、命令行参数</title>
      <link href="/post/164885499/"/>
      <url>/post/164885499/</url>
      
        <content type="html"><![CDATA[<p>在 C 程序中，你可能需要在命令启动时从命令行接收参数。</p><p>对于简单的需求而言，你只需要将 <code>main()</code> 函数的签名从</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br></pre></td></tr></tbody></table></figure><p>修改为</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br></pre></td></tr></tbody></table></figure><p><code>argc</code> 是一个整数，包含从命令行提供的参数的数量。</p><p><code>argv</code> 是一个字符串数组。</p><p>当程序开始运行时，我们用这两个参数给主函数提供参数。</p><p>注意 <code>argv</code> 数组中总是至少有一个元素：程序的名字。</p><p>咱们以我们用来运行程序的 C 编译器作为示例吧，就像这样：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">gcc hello.c -o hello</span><br></pre></td></tr></tbody></table></figure><p>如果这就是我们的程序，我们的 <code>argc</code> 将会是 4，<code>argv</code> 将是一个包含以下内容的数组：</p><ul><li><code>gcc</code></li><li><code>hello.c</code></li><li><code>-o</code></li><li><code>hello</code></li></ul><p>咱们写一个打印它收到的参数的程序吧：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>{</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; argc; i++) {</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, argv[i]);</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>如果我们的程序名为 <code>hello</code>，并且我们像这样运行它：<code>./hello</code>，我们就会得到以下输出：</p><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">./hello</span><br></pre></td></tr></tbody></table></figure><p>如果我们传递一些随机参数，就像这样：<code>./hello a b c</code>，我们竟会在终端中得到这个输出：</p><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">./hello</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br></pre></td></tr></tbody></table></figure><p>对于简单的需求而言，这个系统工作得很好。对于更加复杂的需求，有一些常用的包，比如 <strong>getopt</strong>。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> C语言入门手册 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十二、类型定义和结构体</title>
      <link href="/post/164885500/"/>
      <url>/post/164885500/</url>
      
        <content type="html"><![CDATA[<p>C 中的 <code>typedef</code> 关键字允许你定义新的类型。</p><p>我们可以从 C 内置的类型开始创建自己的类型，使用这个语法：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> existingtype NEWTYPE</span><br></pre></td></tr></tbody></table></figure><p>按照惯例，我们创建的新类型通常是大写的。</p><p>这样可以更加容易区分它，并且可以立即识别出它是一种类型。</p><p>例如，我们可以定义一个新的 <code>NUMBER</code> 类型，它还是 <code>int</code>：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> NUMBER</span><br></pre></td></tr></tbody></table></figure><p>一旦你这么做了之后，你就可以定义新的 <code>NUMBER</code> 变量了：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">NUMBER one = <span class="number">1</span>;</span><br></pre></td></tr></tbody></table></figure><p>现在你可能会问：为什么？为什么不直接使用内置的 <code>int</code> 类型呢？</p><p>嗯，当两个东西搭配在一起的时候，<code>typedef</code> 会变得真的很有用：枚举类型和结构体。</p><h2 id="枚举类型">枚举类型<a class="" href="#枚举类型"></a></h2><p>使用 <code>typedef</code> 和 <code>enum</code> 关键字，我们可以定义具有指定值的类型。</p><p>这是 <code>typedef</code> 关键字最重要的使用场景之一。</p><p>这是枚举类型的语法：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> {</span></span><br><span class="line">  <span class="comment">//值……</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>按照惯例，我们创建的枚举类通常是大写的。</p><p>这里是一个简单的示例：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> {</span></span><br><span class="line">  <span class="literal">true</span>,</span><br><span class="line">  <span class="literal">false</span></span><br><span class="line">} BOOLEAN;</span><br></pre></td></tr></tbody></table></figure><p>C 自带 <code>bool</code> 类型，所以这个示例并不实用，但是它会让你领悟到其中的精髓。</p><p>另一个示例是定义一周中的那几个日子：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> {</span></span><br><span class="line">  monday,  </span><br><span class="line">  tuesday,</span><br><span class="line">  wednesday,</span><br><span class="line">  thursday,</span><br><span class="line">  friday,</span><br><span class="line">  saturday,</span><br><span class="line">  sunday</span><br><span class="line">} WEEKDAY;</span><br></pre></td></tr></tbody></table></figure><p>这里是使用这个枚举类的一个简单程序：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> {</span></span><br><span class="line">  monday,  </span><br><span class="line">  tuesday,</span><br><span class="line">  wednesday,</span><br><span class="line">  thursday,</span><br><span class="line">  friday,</span><br><span class="line">  saturday,</span><br><span class="line">  sunday</span><br><span class="line">} WEEKDAY;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line">  WEEKDAY day = monday;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (day == monday) {</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"It's monday!"</span>); </span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"It's not monday"</span>); </span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>枚举定义中的每个枚举项在内部都与一个整数配对。所以在这个示例中 <code>monday</code> 是 0，<code>tuesday</code> 是 1，以此类推。</p><p>这意味着对应的条件可以是 <code>if (day == 0)</code> 而不是 <code>if (day == monday)</code>，但是对于我们人类来说，使用名字比数字更合理，所以它是一个非常便利的语法。</p><h2 id="结构体">结构体<a class="" href="#结构体"></a></h2><p>利用 <code>struct</code> 关键字，我们可以使用基本的 C 类型创建复杂的数据结构。</p><p>结构体是一组由不同类型的值组成的集合。C 中的数组被限制为一种类型，所以结构体在很多用例中会显得非常有趣。</p><p>这里是结构体的语法：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &lt;</span>structname&gt; {</span><br><span class="line">  <span class="comment">//变量……</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>示例：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">person</span> {</span></span><br><span class="line">  <span class="keyword">int</span> age;</span><br><span class="line">  <span class="keyword">char</span> *name;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>通过将变量添加到右花括号之后，分号之前，你可以声明类型为该结构体的变量，就像这样：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">person</span> {</span></span><br><span class="line">  <span class="keyword">int</span> age;</span><br><span class="line">  <span class="keyword">char</span> *name;</span><br><span class="line">} flavio;</span><br></pre></td></tr></tbody></table></figure><p>或者多个变量也行，就像这样：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">person</span> {</span></span><br><span class="line">  <span class="keyword">int</span> age;</span><br><span class="line">  <span class="keyword">char</span> *name;</span><br><span class="line">} flavio, people[<span class="number">20</span>];</span><br></pre></td></tr></tbody></table></figure><p>这次我声明一个名为 <code>flavio</code> 的 <code>person</code> 变量，以及一个具有 20 个 <code>person</code> 的名为 <code>people</code> 的数组。</p><p>我们也可以稍后再声明变量，使用这个语法：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">person</span> {</span></span><br><span class="line">  <span class="keyword">int</span> age;</span><br><span class="line">  <span class="keyword">char</span> *name;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">person</span> <span class="title">flavio</span>;</span></span><br></pre></td></tr></tbody></table></figure><p>我们可以在声明的时候初始化一个结构体：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">person</span> {</span></span><br><span class="line">  <span class="keyword">int</span> age;</span><br><span class="line">  <span class="keyword">char</span> *name;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">person</span> <span class="title">flavio</span> =</span> { <span class="number">37</span>, <span class="string">"Flavio"</span> };</span><br></pre></td></tr></tbody></table></figure><p>一旦定义了结构体，我们就可以使用一个点（<code>.</code>）来访问它里面的值了：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">person</span> {</span></span><br><span class="line">  <span class="keyword">int</span> age;</span><br><span class="line">  <span class="keyword">char</span> *name;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">person</span> <span class="title">flavio</span> =</span> { <span class="number">37</span>, <span class="string">"Flavio"</span> };</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s, age %u"</span>, flavio.name, flavio.age);</span><br></pre></td></tr></tbody></table></figure><p>我们也可以使用点语法改变结构体中的值：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">person</span> {</span></span><br><span class="line">  <span class="keyword">int</span> age;</span><br><span class="line">  <span class="keyword">char</span> *name;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">person</span> <span class="title">flavio</span> =</span> { <span class="number">37</span>, <span class="string">"Flavio"</span> };</span><br><span class="line"></span><br><span class="line">flavio.age = <span class="number">38</span>;</span><br></pre></td></tr></tbody></table></figure><p>结构体非常有用，因为它们既可以作为函数的参数，也可以作为函数的返回值，以及它们内部的嵌入变量。每个变量都有一个标签。</p><p>注意到结构体是 <strong>复制传递</strong> 的，这一点很重要，除非，当然你可以传递一个指向结构体的指针，这种情况下它就是引用传递。</p><p>使用 <code>typedef</code>，我们可以简化处理结构体时的代码。</p><p>咱们看一个示例：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">  <span class="keyword">int</span> age;</span><br><span class="line">  <span class="keyword">char</span> *name;</span><br><span class="line">} PERSON;</span><br></pre></td></tr></tbody></table></figure><p>按照惯例，我们使用 <code>typedef</code> 创建的结构体通常是大写的。</p><p>现在，我们可以像这样声明一个新的 <code>PERSON</code> 变量：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">PERSON flavio;</span><br></pre></td></tr></tbody></table></figure><p>并且我们可以用这种方式在声明的时候初始化它们：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">PERSON flavio = { <span class="number">37</span>, <span class="string">"Flavio"</span> };</span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> C语言入门手册 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十五、预处理器</title>
      <link href="/post/164885501/"/>
      <url>/post/164885501/</url>
      
        <content type="html"><![CDATA[<p>预处理器是一个工具，当我们用 C 编程时，它对我们有很大的帮助。它是 C 标准的一部分，就像语言本身、编译器和标准库一样。</p><p>它解析我们的程序，确保编译器在处理之前获得所有需要的东西。</p><p>在实践中，它是做什么的呢？</p><p>例如，它查找你使用 <code>#include</code> 指令包含的所有头文件。</p><p>它还查看你使用 <code>#define</code> 定义的每个常量并将其替换为实际的值。</p><p>这只是一个开始。我提到了这两个操作，是因为它们是最常见的两个。预处理器能做的事情还有很多。</p><p>你有注意到 <code>#include</code> 和 <code>#define</code> 在开头有一个 <code>#</code> 吗？那在预处理器指令中是很常见的。如果某一行以 <code>#</code> 开始，它就会被预处理器关照。</p><h3 id="条件">条件<a class="" href="#条件"></a></h3><p>我们能做的一件事情是使用条件让表达式决定程序的编译方式。</p><p>例如，我们可以检查 <code>DEBUG</code> 常量是否为 0：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> DEBUG = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG == 0</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"I am NOT debugging\n"</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"I am debugging\n"</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="符号常量">符号常量<a class="" href="#符号常量"></a></h3><p>我们可以定义一个 <strong>符号常量（symbolic constant）</strong>：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VALUE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI 3.14</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NAME <span class="meta-string">"Flavio"</span></span></span><br></pre></td></tr></tbody></table></figure><p>当我们在自己的程序中使用 NAME 或 PI 或 VALUE 时，预处理器会在执行程序之前将名字替换成对应的值。</p><p>符号常量非常有用，因为我们可以给值名字，而不用在编译时创建变量。</p><h3 id="宏">宏<a class="" href="#宏"></a></h3><p>我们还可以使用 <code>#define</code> 定义 <strong>宏（macro）</strong>。宏与符号常量之间的差别在于：宏可以接受一个参数，并且通常包含代码，而符号常量只是一个值：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> POWER(x) ((x) * (x))</span></span><br></pre></td></tr></tbody></table></figure><p>注意参数两侧的括号：当宏在预编译过程中被替换时，这是一个避免问题的好方法。</p><p>然后我们可以在代码中使用它，像这样：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"%u\n"</span>, POWER(<span class="number">4</span>)); <span class="comment">//16</span></span><br></pre></td></tr></tbody></table></figure><p>它与函数之间的一个大差别就是：宏不会声明参数或返回值的类型，这在一些场景中可能很方便。</p><p>然而，宏的定义被限制成只有一行。</p><h3 id="If-defined">If defined<a class="" href="#If-defined"></a></h3><p>我们可以使用 <code>#ifdef</code> 来检查某个符号常量或宏是否被定义过：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VALUE 1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> VALUE</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Value is defined\n"</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Value is not defined\n"</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>我们也可以使用 <code>#ifndev</code> 检查对立面（宏未定义）。</p><p>我们还可以使用 <code>#if defined</code> 和 <code>#if !defined</code> 来达到同样的目的。</p><p>像这样将一些代码块包裹到单个块中是很常见的：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure><p>这样可以临时防止程序运行，也可以使用一个 DEBUG 符号常量：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG 0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG</span></span><br><span class="line">  <span class="comment">// 当 DEBUG 不为 0 时，代码才会被发给编译器</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure><h3 id="你可以使用的预定义的符号常量">你可以使用的预定义的符号常量<a class="" href="#你可以使用的预定义的符号常量"></a></h3><p>预处理器还定义了很多你可以直接使用的符号常量，它们的名字的前后有两个下划线作为标识，包括：</p><ul><li><strong><code>__LINE__</code></strong> 代表源代码文件中的当前行</li><li><strong><code>__FILE__</code></strong> 代表文件的名字</li><li><strong><code>__DATE__</code></strong> 表示编译日期，格式为 <code>Mmm gg aaaa</code></li><li><strong><code>__TIME__</code></strong> 表示编译实践，格式为 <code>hh:mm:ss</code></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> C语言入门手册 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十四、头文件</title>
      <link href="/post/164885502/"/>
      <url>/post/164885502/</url>
      
        <content type="html"><![CDATA[<p>简单的程序可以直接放在单个文件中。但是当你的程序变大，将它放在单个文件中就不可能了。</p><p>你可以将程序一些部分移动到一个单独的文件中，然后创建一个 <strong>头文件</strong>。</p><p>头文件看起来就像普通的 C 文件一样，但是它是以 <code>.h</code> 而不是 <code>.c</code> 结尾的。它里面的内容是 <strong>声明</strong>，而不是函数的实现和程序的其它部分。</p><p>你已经在第一次使用 <code>printf()</code> 函数或其它 I/O 函数的时候使用过头文件了，如果你要使用它，需要输入以下内容：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br></pre></td></tr></tbody></table></figure><p><code>#include</code> 是一个预处理器指令。</p><p>该预处理器会在标准库中寻找 <code>stdio.h</code> 文件，因为你使用了花括号包裹它。若要包含你自己的头文件，你需要使用引号（<code>"</code>），就像这样：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"myfile.h"</span></span></span><br></pre></td></tr></tbody></table></figure><p>上述代码会让预处理器在当前文件夹内寻找 <code>myfile.h</code>。</p><p>你也可以使用文件夹结构的库：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"myfolder/myfile.h"</span></span></span><br></pre></td></tr></tbody></table></figure><p>咱们看一个示例。这个程序计算自给定年份以来的年数：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calculateAge</span><span class="params">(<span class="keyword">int</span> year)</span> </span>{</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> CURRENT_YEAR = <span class="number">2020</span>;</span><br><span class="line">  <span class="keyword">return</span> CURRENT_YEAR - year;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%u"</span>, calculateAge(<span class="number">1983</span>));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>假设我想将 <code>caculateAge</code> 函数移到一个单独的文件中。</p><p>我创建一个名为 <code>calculate_age.c</code> 的文件：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calculateAge</span><span class="params">(<span class="keyword">int</span> year)</span> </span>{</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> CURRENT_YEAR = <span class="number">2020</span>;</span><br><span class="line">  <span class="keyword">return</span> CURRENT_YEAR - year;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>我还创建了一个名为 <code>calculate_age.h</code> 的文件，我在其中放入了 <em>函数原型</em>，除了函数体，它与 <code>.c</code> 文件中的函数完全相同：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calculateAge</span><span class="params">(<span class="keyword">int</span> year)</span></span>;</span><br></pre></td></tr></tbody></table></figure><p>现在在主 <code>.c</code> 文件中，我们可以移除 <code>calculateAge()</code> 函数的定义，并且我们可以导入 <code>calculate_age.h</code>，它会让 <code>calculateAge()</code> 函数可用：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"calculate_age.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%u"</span>, calculateAge(<span class="number">1983</span>));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>别忘了编译多个文件组成的程序，你需要在命令行中列出它们，就像这样：</p><figure class="highlight sh"><table><tbody><tr><td class="code"><pre><span class="line">gcc -o main main.c calculate_age.c</span><br></pre></td></tr></tbody></table></figure><p>如果配置更加复杂，一个告诉编译器如何编译该程序的 Makefile 是必需的。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> C语言入门手册 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>九、函数</title>
      <link href="/post/164885483/"/>
      <url>/post/164885483/</url>
      
        <content type="html"><![CDATA[<p>我们通过函数将代码组织成子例程，这样就可以：</p><ol><li>给它一个名字</li><li>在需要它们的时候进行调用</li></ol><p>从你的第一个程序（“Hello, World!”）开始，你就在使用 C 函数了：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello, World!"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>main()</code> 函数是一个非常重要的函数，它是 C 程序的入口点。</p><p>这是另一个函数：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(<span class="keyword">int</span> value)</span> </span>{</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%u"</span>, value);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>函数有 4 个重要的方面：</p><ol><li>它们有一个名字，所以我们可以在之后调用它们</li><li>它们声明一个返回值</li><li>它们可以有参数</li><li>它们有一个函数体，用花括号包裹</li></ol><p>函数体是一组指令，任何时候，只要函数被调用，这组指令就会被执行。</p><p>如果函数没有返回值，你可以在函数名前面使用关键字 <code>void</code>。否则你就要声明该函数的返回值类型（整数为 <code>int</code>，浮点数为 <code>float</code>，字符串为 <code>const char *</code>，等等）。</p><p>函数返回值的数量不能超过一个。</p><p>函数可以有参数。它们是可选的。如果函数没有参数，我们就在括号内插入 <code>void</code>，就像这样：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在这种情况下，当我们调用该函数时，括号内没有任何东西：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">doSomething();</span><br></pre></td></tr></tbody></table></figure><p>如果有一个参数，我们就声明该参数的类型和名字，就像这样：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(<span class="keyword">int</span> value)</span> </span>{</span><br><span class="line">   <span class="comment">/* ... */</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>当我们调用该函数时，我们会在括号内传递对应的参数，就像这样：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">doSomething(<span class="number">3</span>);</span><br></pre></td></tr></tbody></table></figure><p>我们可以有多个参数，为此我们使用逗号对它们进行分隔，在声明和调用时都是这样：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(<span class="keyword">int</span> value1, <span class="keyword">int</span> value2)</span> </span>{</span><br><span class="line">   <span class="comment">/* ... */</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">doSomething(<span class="number">3</span>, <span class="number">4</span>);</span><br></pre></td></tr></tbody></table></figure><p>参数是通过 <strong>拷贝</strong> 传递的。这意味着如果你修改 <code>value1</code>，它的值是在局部作用域内修改的。函数外的那个值，即我们在调用时传入的值，并不会改变。</p><p>如果你传入的参数为一个 <strong>指针</strong>，你可以修改该变量的值，因为你现在可以使用它的内存地址直接访问它。</p><p>你不能为参数定义默认值。C++ 是可以的（Arduino Language 程序也可以），但是 C 不行。</p><p>确保你在调用函数之前定义了该函数，否则编译器将会给出一个警告和一个错误：</p><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">➜  ~ gcc hello.c -o hello; ./hello</span><br><span class="line">hello.c:13:3: warning: implicit declaration of</span><br><span class="line">      function 'doSomething' is invalid in C99</span><br><span class="line">      [-Wimplicit-function-declaration]</span><br><span class="line">  doSomething(3, 4);</span><br><span class="line">  ^</span><br><span class="line">hello.c:17:6: error: conflicting types for</span><br><span class="line">      'doSomething'</span><br><span class="line">void doSomething(int value1, char value2) {</span><br><span class="line">     ^</span><br><span class="line">hello.c:13:3: note: previous implicit declaration</span><br><span class="line">      is here</span><br><span class="line">  doSomething(3, 4);</span><br><span class="line">  ^</span><br><span class="line">1 warning and 1 error generated.</span><br></pre></td></tr></tbody></table></figure><p>你收到的警告与顺序有关，我之前有提到过这个。</p><p>错误与另一件事情有关。因为 C 没有在调用函数之前没有“看到”该函数的声明，所以它必须进行假设。并且，它假设该函数返回 <code>int</code>。然而该函数返回的是 <code>void</code>，因此出现了错误。</p><p>如果你将该函数的定义修改为：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">doSomething</span><span class="params">(<span class="keyword">int</span> value1, <span class="keyword">int</span> value2)</span> </span>{</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, value1, value2);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>你就只会得到警告，错误消失了：</p><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">➜  ~ gcc hello.c -o hello; ./hello</span><br><span class="line">hello.c:14:3: warning: implicit declaration of</span><br><span class="line">      function 'doSomething' is invalid in C99</span><br><span class="line">      [-Wimplicit-function-declaration]</span><br><span class="line">  doSomething(3, 4);</span><br><span class="line">  ^</span><br><span class="line">1 warning generated.</span><br></pre></td></tr></tbody></table></figure><p>不管是何种情况，确保你在使用函数之前声明了它。要么将函数上移，要么在头文件中加入该函数的原型。</p><p>在函数内部，你可以声明变量：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(<span class="keyword">int</span> value)</span> </span>{</span><br><span class="line">  <span class="keyword">int</span> doubleValue = value * <span class="number">2</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>变量在调用该函数的那一刻创建，并且在函数退出的时候销毁。它对函数外面来说是不可见的。</p><p>在函数内部，你可以调用函数自己。这被称为 <strong>递归</strong>，它提供了特有的机会。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> C语言入门手册 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>七、字符串</title>
      <link href="/post/164885418/"/>
      <url>/post/164885418/</url>
      
        <content type="html"><![CDATA[<p>在 C 中，字符串是一种特殊的数组：字符串是由 <code>char</code> 值组成的数组：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> name[<span class="number">7</span>];</span><br></pre></td></tr></tbody></table></figure><p>可以像初始化一个普通的数组那样初始化一个字符串：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> name[<span class="number">7</span>] = { <span class="string">"F"</span>, <span class="string">"l"</span>, <span class="string">"a"</span>, <span class="string">"v"</span>, <span class="string">"i"</span>, <span class="string">"o"</span> };</span><br></pre></td></tr></tbody></table></figure><p>或者使用更加方便的字符串字面量（也被称为字符串常量），一组用双引号引起来的字符：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> name[<span class="number">7</span>] = <span class="string">"Flavio"</span>;</span><br></pre></td></tr></tbody></table></figure><p>为什么“Flavio”是 6 个字符长，但是定义了一长度为 7 的数组？这是因为字符串中的最后一个字符必须是 <code>0</code>，它是字符串的终止符号，我们必须给它留个位置。</p><p>我们可以分别输出数组长度为 6 和 7 的情况：</p><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">Flavio )��</span><br><span class="line">Flavio </span><br></pre></td></tr></tbody></table></figure><p>关于操作字符串，C 提供了一个非常重要的标准库：<code>string.h</code>。</p><p>这个库是必不可少的，因为它抽象了很多与字符串有关的底层细节，给我们提供了一组非常有用的函数。</p><p>我们可以在程序中加载这个库，需要在文件顶部加上：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br></pre></td></tr></tbody></table></figure><p>这样就可以访问函数：</p><ul><li><code>strcpy()</code>：将一个字符串复制到另一个字符串</li><li><code>strcat()</code>：将一个字符串追加到另一个字符串</li><li><code>strcmp()</code>：比较两个字符串是否相等</li><li><code>strncmp()</code>：比较两个字符串的前 <code>n</code> 个字符</li><li><code>strlen()</code>：计算字符串的长度</li></ul><p>还有很多很多其它的函数可以调用。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> C语言入门手册 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>六、数组</title>
      <link href="/post/164885490/"/>
      <url>/post/164885490/</url>
      
        <content type="html"><![CDATA[<p>数组是存储多个变量的变量。在 C 中，数组中的每个值都必须有 <strong>相同的类型</strong>。</p><h1 id="一维数组">一维数组<a class="" href="#一维数组"></a></h1><p>我们可以像这样定义一个 <code>int</code> 型的数组：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> prices[<span class="number">5</span>];</span><br></pre></td></tr></tbody></table></figure><p>数组的大小是必须声明的。C 没有提供开箱即用的动态数组（想要使用这种开箱即用数组类型，必须使用像链表这样的数据结构）。</p><p>我们可以使用常量定义数组的大小：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> SIZE = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> prices[SIZE];</span><br></pre></td></tr></tbody></table></figure><p>也可以在定义数组的时候进行初始化：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> prices[<span class="number">5</span>] = { <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> };</span><br></pre></td></tr></tbody></table></figure><p>也可以在定义数组之后为其赋值：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> prices[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">prices[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">prices[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">prices[<span class="number">2</span>] = <span class="number">3</span>;</span><br><span class="line">prices[<span class="number">3</span>] = <span class="number">4</span>;</span><br><span class="line">prices[<span class="number">4</span>] = <span class="number">5</span>;</span><br></pre></td></tr></tbody></table></figure><p>或者使用循环：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> prices[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) {</span><br><span class="line">  prices[i] = i + <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">prices[<span class="number">0</span>]; <span class="comment">/* 第一个数组项的值 */</span></span><br><span class="line">prices[<span class="number">1</span>]; <span class="comment">/* 第二个数组项的值 */</span></span><br></pre></td></tr></tbody></table></figure><p>数组的索引从 0 开始，所以一个有五个元素的数组，比如上面的 <code>prices</code> 数组，将会包含的数组项的范围为 <code>prices[0]</code> 到 <code>prices[4]</code>。</p><h1 id="二维数组">二维数组<a class="" href="#二维数组"></a></h1><p>怎样定义二维数组呢？其基本概念与方法和一维数组相似。如：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">float</span> pay[<span class="number">3</span>][<span class="number">6</span>]</span><br></pre></td></tr></tbody></table></figure><p>以上定义了一个<code>float</code>型的二维数组，第1维有3个元素，第2维有6个元素。每一维的长度分别用一对方括号括起来。二维数组定义的一般形式为<code>类型说明符数组名[常量表达式常][量表达式]</code></p><p>例如：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>][<span class="number">4</span>];</span><br></pre></td></tr></tbody></table></figure><p>可以直接用初始化列表对数组进行初始化</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>][<span class="number">4</span>] = {{<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>},{<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>},{<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>}};</span><br></pre></td></tr></tbody></table></figure><p>也可以直接在一个花括号内初始化：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>][<span class="number">4</span>] = {<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>};</span><br></pre></td></tr></tbody></table></figure><p>效果与上一个相同，不过这种写法不如一个明确而且容易出错。</p><p>也可以部分赋值</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>][<span class="number">4</span>] = {{<span class="number">1</span>},{<span class="number">5</span>,<span class="number">6</span>},{<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>}};</span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> C语言入门手册 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>五、循环</title>
      <link href="/post/164885486/"/>
      <url>/post/164885486/</url>
      
        <content type="html"><![CDATA[<p>C 给我们提供了三种循环：<strong>For 循环</strong>、<strong>while 循环</strong> 和 <strong>do while 循环</strong>。它们都允许在数组上进行迭代，但又各有不同。</p><h1 id="for-循环">for 循环<a class="" href="#for-循环"></a></h1><p>第一种执行循环是 <strong>for 循环</strong>，它可能也是最常见的循环。</p><p>使用 <code>for</code> 关键字时，我们可以先定义循环的 <em>规则</em>，然后提供反复执行的那个代码块。</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">10</span>; i++) {</span><br><span class="line">  <span class="comment">/* 反复执行的指令 */</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>(int i = 0; i &lt;= 10; i++)</code> 代码块包含与循环细节有关的三个部分：</p><ul><li>初始条件（<code>int i = 0</code>）</li><li>测试（<code>i &lt;= 10</code>）</li><li>增长（<code>i++</code>）</li></ul><p>我们首先定义循环变量，本示例中为 <code>i</code>。<code>i</code> 是循环中的一个常用变量名，<code>j</code> 是嵌套循环（循环内的循环）内使用的变量名。这只是一个惯例。</p><p>变量 <code>i</code> 的值被初始化为 0，并且第一次迭代执行完毕。然后 <code>i</code> 像增长部分（这个示例中是 <code>i++</code>，递增 1）所说的那样增长，并且所有的循环会一直重复，直到 <code>i</code> 的值达到数字 10。</p><p>在循环的主代码块内，我们可以访问变量 <code>i</code>，从而获知我们当前所处的是哪个迭代。这个程序应该打印 <code>0 1 2 3 4 5 5 6 7 8 9 10</code>：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">10</span>; i++) {</span><br><span class="line">  <span class="comment">/* 反复执行的指令 */</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%u "</span>, i);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>循环可以从较高的数字开始，往较低的数字逼近，就像这样：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">10</span>; i &gt; <span class="number">0</span>; i--) {</span><br><span class="line">  <span class="comment">/* 反复执行的指令 */</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>可以让循环变量的增量为 2 或者其它值：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i = i + <span class="number">30</span>) {</span><br><span class="line">  <span class="comment">/* 反复执行的指令 */</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="while-循环">while 循环<a class="" href="#while-循环"></a></h1><p><strong>while 循环</strong> 写起来比 <code>for</code> 循环要简单，因为它需要我们在自己的部分做更多的事情。</p><p>使用 <code>while</code> 时，我们只需要检查条件，而不用在循环开始时预先定义所有的循环数据（就像你在 <code>for</code> 循环中做的那样）：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (i &lt; <span class="number">10</span>) {</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这段代码假定 <code>i</code> 已经定义并且用某个值进行了初始化。</p><p>除非我们在循环内的某些地方增加变量 <code>i</code> 的值，否则这个循环会变成一个 <strong>无限循环</strong>。无限循环非常糟糕，因为它会阻塞程序，从而使其它任何事情都不会发生。</p><p>对于一个“正确的” while 循环，我们需控制变量 i 的值：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (i &lt; <span class="number">10</span>) {</span><br><span class="line">  <span class="comment">/* 做点事情 */</span></span><br><span class="line"></span><br><span class="line">  i++;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="do-while-循环">do while 循环<a class="" href="#do-while-循环"></a></h1><p>与 while循环相比，有些时候我们可能需要做某件特定的事情：我们总是想执行某个代码块，然后 <em>可能</em> 一直重复它。</p><p>这可以通过 <code>do while</code> 关键字来完成。它在某种程度上和 <code>while</code> 循环非常类似，但是会有些许不同：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> {</span><br><span class="line">  <span class="comment">/* 做点事情 */</span></span><br><span class="line"></span><br><span class="line">  i++;</span><br><span class="line">} <span class="keyword">while</span> (i &lt; <span class="number">10</span>);</span><br></pre></td></tr></tbody></table></figure><p>尽管条件检查在底部，但是包含注释 <code>/* 做点事情 */</code> 的代码块总是会至少执行一次。</p><p>然后，只要 <code>i</code> 小于 10，我们都将会重复这个代码块。</p><h1 id="使用-break-跳出循环">使用 break 跳出循环<a class="" href="#使用-break-跳出循环"></a></h1><p>这在很多情况下非常有用，我们可能想检查某个变量的值，例如：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">10</span>; i++) {</span><br><span class="line">  <span class="keyword">if</span> (i == <span class="number">4</span> &amp;&amp; someVariable == <span class="number">10</span>) {</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>对 <code>while</code> 循环（也适用于 <code>do while</code> 循环）来说，使用这种方式跳出循环非常实用，因为我们可以创建一个看似无限的循环，不过我们可以在某个条件发生时结束这个循环。可以在循环代码块里面定义它：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) {</span><br><span class="line">  <span class="comment">/* 做点事情 */</span></span><br><span class="line"></span><br><span class="line">  i++;</span><br><span class="line">  <span class="keyword">if</span> (i == <span class="number">10</span>) <span class="keyword">break</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这种循环在 C 中非常普遍。</p><h1 id="使用-continue-提前结束本次循环">使用 continue 提前结束本次循环<a class="" href="#使用-continue-提前结束本次循环"></a></h1><p>有时并不希望终止整个循环的操作，而只希望提前结束本次循环，而接着执行下次循环。这时可以用continue语句。</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> someVariable = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">10</span>; i++) {</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">4</span> &amp;&amp; someVariable == <span class="number">10</span>) {</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>, i);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> C语言入门手册 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>四、条件语句</title>
      <link href="/post/164885503/"/>
      <url>/post/164885503/</url>
      
        <content type="html"><![CDATA[<p>任何编程语言都给程序员提供了进行选择的能力。我们想要在一些情况下进行 X，而在其它情况下进行 Y。我们想检查数据，根据数据的状态做选择。</p><p>C 给我们提供了两种方式。</p><p>第一种方式是带 <code>else</code> 的 <code>if</code> 语句，第二种是 <code>switch</code> 语句。</p><h1 id="if">if<a class="" href="#if"></a></h1><p>在 <code>if</code> 语句中，可以在检查到条件为 true 的时候，执行花括号内的代码块：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (a == <span class="number">1</span>) {</span><br><span class="line">  <span class="comment">/* 进行一些操作 */</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>如果原始条件的结果是 false，可以追加一个 <code>else</code> 块以不同的代码块：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (a == <span class="number">2</span>) {</span><br><span class="line">  <span class="comment">/* 进行一些操作 */</span></span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">  <span class="comment">/* 进行另一些操作 */</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>谨防一种常见的问题：在比较中要使用比较运算符 <code>==</code>，而不是赋值运算符 <code>=</code>   。如果使用了<code>=</code>除非参数为 0，否则 <code>if</code> 条件检查的结果将一直都是 true。</p><p>例如：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (a = <span class="number">0</span>) {</span><br><span class="line">  <span class="comment">/* 永远都不会被调用 */</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>为什么会这样呢？因为条件检查会寻找一个布尔类型的结果（比较的结果），数字 <code>0</code> 总是等于 false。其它的任何东西都是 true，包括负数。</p><p>通过将多个 <code>if</code> 语句堆叠在一起，可以有多个 <code>else</code> 块：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (a == <span class="number">2</span>) {</span><br><span class="line">  <span class="comment">/* do something */</span></span><br><span class="line">} <span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">1</span>) {</span><br><span class="line">  <span class="comment">/* 进行一些操作 */</span></span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">  <span class="comment">/* 进行另一些操作 */</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="switch">switch<a class="" href="#switch"></a></h1><p>如果需要检查变量的具体值，这时就可以选择<code>switch</code> 语句。</p><p>可以提供一个变量作为条件，然后为期望的每个值使用一个 <code>case</code> 入口点：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (a) {</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">    <span class="comment">/* 进行一些操作 */</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    <span class="comment">/* 进行另一些操作 */</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    <span class="comment">/* 进行另一些操作 */</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></tbody></table></figure><p>当前一个 case 执行完后，为了避免下一个 case 被执行，我们需要在每个 case 的末尾使用 <code>break</code> 关键字。这种“级联”效果在某些创造性方法中非常有用的。</p><p>另外需要在末尾添加一个“捕获所有的” case，名为 <code>default</code>：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (a) {</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">    <span class="comment">/* 进行一些操作 */</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    <span class="comment">/* 进行另一些操作 */</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    <span class="comment">/* 进行另一些操作 */</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="comment">/* 处理所有其它的情况 */</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> C语言入门手册 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三、运算符</title>
      <link href="/post/164885482/"/>
      <url>/post/164885482/</url>
      
        <content type="html"><![CDATA[<p>C 给我们提供了各种各样的运算符，我们可以用来操作数据。</p><p>特别地，我们可以识别不同分组的运算符：</p><ul><li>算术运算符</li><li>比较运算符</li><li>逻辑运算符</li><li>复合赋值运算符</li><li>位运算符</li><li>指针运算符</li><li>结构运算符</li><li>混合运算符</li></ul><p>在这一节中，我们将用两个假想的变量 <code>a</code> 和 <code>b</code> 举例，详细介绍所有这些运算符。</p><p>为了简单起见，本篇不会介绍位运算符、结构运算符和指针运算符。</p><h1 id="算术运算符">算术运算符<a class="" href="#算术运算符"></a></h1><p>算术运算符可以分为二元运算符和一元运算符。</p><p>二元操作符需要两个操作数：</p><table><thead><tr><th style="text-align:left">操作符</th><th style="text-align:left">名字</th><th style="text-align:left">示例</th></tr></thead><tbody><tr><td style="text-align:left"><code>=</code></td><td style="text-align:left">赋值</td><td style="text-align:left"><code>a = b</code></td></tr><tr><td style="text-align:left"><code>+</code></td><td style="text-align:left">加</td><td style="text-align:left"><code>a + b</code></td></tr><tr><td style="text-align:left"><code>-</code></td><td style="text-align:left">减</td><td style="text-align:left"><code>a - b</code></td></tr><tr><td style="text-align:left"><code>*</code></td><td style="text-align:left">乘</td><td style="text-align:left"><code>a * b</code></td></tr><tr><td style="text-align:left"><code>/</code></td><td style="text-align:left">除</td><td style="text-align:left"><code>a / b</code></td></tr><tr><td style="text-align:left"><code>%</code></td><td style="text-align:left">取模</td><td style="text-align:left"><code>a % b</code></td></tr></tbody></table><p>一元运算符只需要一个操作数：</p><table><thead><tr><th style="text-align:left">运算符</th><th style="text-align:left">名字</th><th style="text-align:left">示例</th></tr></thead><tbody><tr><td style="text-align:left"><code>+</code></td><td style="text-align:left">一元加（正值）</td><td style="text-align:left"><code>+a</code></td></tr><tr><td style="text-align:left"><code>-</code></td><td style="text-align:left">一元减（负值）</td><td style="text-align:left"><code>-a</code></td></tr><tr><td style="text-align:left"><code>++</code></td><td style="text-align:left">自增</td><td style="text-align:left"><code>a++</code> or <code>++a</code></td></tr><tr><td style="text-align:left"><code>--</code></td><td style="text-align:left">自减</td><td style="text-align:left"><code>a--</code> or <code>--a</code></td></tr></tbody></table><p><code>a++</code> 与 <code>++a</code> 的区别在于：<code>a++</code> 在使用 <code>a</code> 之后才自增它的值，而 <code>++a</code> 会在使用 <code>a</code> 之前自增它的值。</p><p>例如：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> b;</span><br><span class="line">b = a++ <span class="comment">/* b 为 2，a 为 3 */</span></span><br><span class="line">b = ++a <span class="comment">/* b 为 4，a 为 4 */</span></span><br></pre></td></tr></tbody></table></figure><p>这也适用于递减运算符。</p><h1 id="比较运算符">比较运算符<a class="" href="#比较运算符"></a></h1><table><thead><tr><th style="text-align:left">运算符</th><th style="text-align:left">名字</th><th style="text-align:left">示例</th></tr></thead><tbody><tr><td style="text-align:left"><code>==</code></td><td style="text-align:left">相等</td><td style="text-align:left"><code>a == b</code></td></tr><tr><td style="text-align:left"><code>!=</code></td><td style="text-align:left">不相等</td><td style="text-align:left"><code>a != b</code></td></tr><tr><td style="text-align:left"><code>&gt;</code></td><td style="text-align:left">大于</td><td style="text-align:left"><code>a &gt; b</code></td></tr><tr><td style="text-align:left"><code>&lt;</code></td><td style="text-align:left">小于</td><td style="text-align:left"><code>a &lt; b</code></td></tr><tr><td style="text-align:left"><code>&gt;=</code></td><td style="text-align:left">大于等于</td><td style="text-align:left"><code>a &gt;= b</code></td></tr><tr><td style="text-align:left"><code>&lt;=</code></td><td style="text-align:left">小于等于</td><td style="text-align:left"><code>a &lt;= b</code></td></tr></tbody></table><h1 id="逻辑运算符">逻辑运算符<a class="" href="#逻辑运算符"></a></h1><ul><li><code>!</code> 非（例如：<code>!a</code>）</li><li><code>&amp;&amp;</code> 与（例如：<code>a &amp;&amp; b</code>）</li><li><code>||</code> 或（例如：<code>a || b</code>）</li></ul><p>这些运算符在使用布尔值时非常有用。</p><h1 id="复合赋值运算符">复合赋值运算符<a class="" href="#复合赋值运算符"></a></h1><p>当赋值与算术运算同时进行时，这些运算符非常有用。</p><table><thead><tr><th style="text-align:left">运算符</th><th style="text-align:left">名字</th><th style="text-align:left">示例</th></tr></thead><tbody><tr><td style="text-align:left"><code>+=</code></td><td style="text-align:left">加且赋值</td><td style="text-align:left"><code>a += b</code></td></tr><tr><td style="text-align:left"><code>-=</code></td><td style="text-align:left">减且赋值</td><td style="text-align:left"><code>a -= b</code></td></tr><tr><td style="text-align:left"><code>*=</code></td><td style="text-align:left">乘且赋值</td><td style="text-align:left"><code>a *= b</code></td></tr><tr><td style="text-align:left"><code>/=</code></td><td style="text-align:left">除且赋值</td><td style="text-align:left"><code>a /= b</code></td></tr><tr><td style="text-align:left"><code>%=</code></td><td style="text-align:left">求模且赋值</td><td style="text-align:left"><code>a %= b</code></td></tr></tbody></table><h1 id="三目运算符">三目运算符<a class="" href="#三目运算符"></a></h1><p>三目运算符是 C 中唯一一个使用三个操作数的运算符，并且它是表达条件的简便方法。</p><p><code>&lt;条件&gt; ? &lt;表达式&gt; : &lt;表达式&gt;</code></p><p>示例：</p><p>若 <code>a</code> 的值为 <code>true</code>，就执行语句 <code>b</code>，否则执行语句 <code>c</code>。</p><p>三目运算符的功能与 if/else 条件语句相同，但是它更短，还可以被内联进表达式。</p><h1 id="sizeof">sizeof<a class="" href="#sizeof"></a></h1><p><code>sizeof</code> 运算符返回传入的操作数的大小。可以传入变量，或者甚至是类型也可以。</p><p>使用示例：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line">  <span class="keyword">int</span> age = <span class="number">37</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%ld\n"</span>, <span class="keyword">sizeof</span>(age));</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%ld"</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="运算符优先级">运算符优先级<a class="" href="#运算符优先级"></a></h1><p>对于所有的这些运算符（以及我们还没有在本文中介绍的其它运算符，包括位运算符、结构运算符和指针运算符），我们在单个表达式中一起使用它们时必须要留意。</p><p>假如我们有这个运算：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">int</span> c = b + a * a / b - a;</span><br></pre></td></tr></tbody></table></figure><p><code>c</code> 的值是多少？我们在执行乘和除之前有进行加法操作吗？</p><p>按照顺序，优先级从低到高：</p><ul><li>赋值运算符 <code>=</code></li><li>二元运算符 <code>+</code> 和 <code>-</code></li><li>运算符 <code>*</code> 和 <code>/</code></li><li>一元运算符 <code>+</code> 和 <code>-</code></li></ul><p>运算符还具有关联规则，除了一元运算符和赋值运算符之外，该规则总是从左到右的。</p><p>在：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> c = b + a * a / b - a;</span><br></pre></td></tr></tbody></table></figure><p>中，我们首先执行 <code>a * a / b</code>，由于是从左到右的，我们可以拆分为 <code>a * a</code> 与其结果 <code>/b</code>：<code>2 * 2 = 4</code>，<code>4 / 4 = 1</code>。</p><p>然后我们可以进行加法操作和减法操作：4 + 1 - 2。<code>c</code> 的值是 <code>3</code>。</p><p>括号的优先级比其它任何运算符都要高。</p><p>上述示例表达式可以被重写为：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> c = b + ((a * a) / b) - a;</span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> C语言入门手册 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二、变量与类型</title>
      <link href="/post/164885485/"/>
      <url>/post/164885485/</url>
      
        <content type="html"><![CDATA[<p>C 是一门静态类型语言。</p><p>这意味着任何变量都有一个相关联的类型，并且该类型在编译时是可知的。这与Python、JavaScript、PHP 和其它解释型语言中使用变量的方式大有不同。</p><p>在 C 中创建变量时，必须在声明中给出该变量的类型。</p><p>在这个示例中，我们初始化一个 <code>int</code> 类型的变量 <code>age</code>：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> age;</span><br></pre></td></tr></tbody></table></figure><p>变量名可以包含任意大写或小写字母，也可以包含数字和下划线，但是不能以数字开头。<code>AGE</code> 和 <code>Age10</code> 都是有效的变量名，但 <code>1age</code> 就不是了。</p><p>还可以在声明中初始化变量，给出初始值即可：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> age = <span class="number">35</span>;</span><br></pre></td></tr></tbody></table></figure><p>变量一旦声明，就可以在程序代码中使用它了。你在任何时候都可以使用 <code>=</code> 改变它的值，例如 <code>age = 100;</code>（提供的新值的类型与原值相同）。</p><p>但是下面这种情况下：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> age = <span class="number">0</span>;</span><br><span class="line">    age = <span class="number">37.2</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%u"</span>, age);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>编译器会在编译时发出警告，然后将小数转为整数。</p><p>C的内置数据类型有 <code>int</code>、<code>char</code>、<code>short</code>、<code>long</code>、<code>float</code>、<code>double</code>、<code>long double</code>。</p><h1 id="整数">整数<a class="" href="#整数"></a></h1><p>C 给我们提供了下列定义整数的类型：</p><ul><li><code>char</code></li><li><code>int</code></li><li><code>short</code></li><li><code>long</code></li></ul><p><code>char</code> 类型通常被用来保存 ASCII 表中的字母，但是它也可以用来保存 <code>-128</code> 到 <code>127</code> 之间的小整数。它占据至少一个字节。</p><p><code>int</code> 占据至少两个字节。<code>short</code> 占据至少两个字节。<code>long</code> 占据至少四个字节。</p><p>在不同环境下，每种数据类型所储存的值是可能不同的，至于每种数据类型所储存的具体值由不同系统的实现和架构决定的。</p><p>但一定会遵循一下准则：</p><ul><li><code>short</code> 不会比 <code>int</code> 长</li><li><code>long</code> 不会比 <code>int</code> 短</li></ul><h1 id="无符号整数">无符号整数<a class="" href="#无符号整数"></a></h1><p>对于以上所有的数据类型，我们都可以在其前面追加一个 <code>unsigned</code>。这样一来，值的范围就不再从负数开始，而是从 0 开始。这在很多情况下是很有用的。</p><ul><li><code>unsigned char</code> 的范围从 <code>0</code> 开始，至少到 <code>255</code></li><li><code>unsigned int</code> 的范围从 <code>0</code> 开始，至少到 <code>65,535</code></li><li><code>unsigned short</code> 的范围从 <code>0</code> 开始，至少到 <code>65,535</code></li><li><code>unsigned long</code> 的范围从 <code>0</code> 开始，至少到 <code>4,294,967,295</code></li></ul><h1 id="溢出问题">溢出问题<a class="" href="#溢出问题"></a></h1><p>鉴于所有这些限制，可能会出现一个问题：我们如何确保数字不超过限制？如果超过了限制会怎样？</p><p>如果有一个值为 255 的 <code>unsigned int</code>，自增返回的值为 256，这在意料之中。如果有一个值为 255 的 <code>unsigned char</code>，自增得到的结果就是 0。它重置为了初始值。</p><p>如果你有一个值为 255 的 <code>unsigned char</code>，给它加上 10 会得到数字 <code>9</code>：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> a = <span class="number">255</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%u\n"</span>, a); <span class="comment">// 255</span></span><br><span class="line">    a = a + <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%u\n"</span>, a); <span class="comment">// 9</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>如果变量是有符号的，则程序的行为则是未知的。程序基本上会给一个很大的值，这个值可能变化，就像这样：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line">    <span class="keyword">char</span> j = <span class="number">127</span>;</span><br><span class="line">    j = j + <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%u"</span>, j); <span class="comment">/* 4294967177 */</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="声明错误类型时的警告">声明错误类型时的警告<a class="" href="#声明错误类型时的警告"></a></h1><p>如果声明变量并用错误的值进行初始化，<code>gcc</code> 编译器应该会发出警告：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line">    <span class="keyword">char</span> a = <span class="number">1000</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">gcc hello.c -o hello</span><br><span class="line">hello.c:8:14: warning: implicit conversion from <span class="string">'int'</span> to <span class="string">'char'</span> changes value from 1000 to -24 [-Wconstant-conversion]</span><br><span class="line">    char a = 1000;</span><br><span class="line">         ~   ^~~~</span><br><span class="line">1 warning generated.</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>如果直接赋值，也会有警告：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line">  <span class="keyword">char</span> j;</span><br><span class="line">  j = <span class="number">1000</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">gcc hello.c -o hello</span><br><span class="line">hello.c:9:9: warning: implicit conversion from <span class="string">'int'</span> to <span class="string">'char'</span> changes value from 1000 to -24 [-Wconstant-conversion]</span><br><span class="line">    j = 1000;</span><br><span class="line">      ~ ^~~~</span><br><span class="line">1 warning generated.</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>但是对值进行增加操作（例如，使用 <code>+=</code>）就不会有警告：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line">  <span class="keyword">char</span> j = <span class="number">0</span>;</span><br><span class="line">  j += <span class="number">1000</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="浮点数">浮点数<a class="" href="#浮点数"></a></h1><p>浮点类型可以表示的数值范围比整数大得多，还可以表示整数无法表示的分数。</p><p>浮点数有下面几种类型</p><ul><li><code>float</code></li><li><code>double</code></li><li><code>long double</code></li></ul><p>这几种类型都可以表示正数和负数。</p><p>任何 C 的实现都必须满足的最小要求是 <code>float</code> 可以表示范围在 10^-37 到 10^+37 之间的数，这通常用 32 位比特实现。 <code>double</code> 可以表示一组更大范围的数，<code>long double</code> 可以保存的数还要更多。</p><p>与整数一样，浮点数的确切值取决于具体实现。</p><p>在现代的 Mac 上，<code>float</code> 用 32 位表示，精度为 24 个有效位，剩余 8 位被用来编码指数部分。</p><p><code>double</code> 用 64 位表示，精度为 53 个有效位，剩余 11 为用于编码指数部分。</p><p><code>long double</code> 类型用 80 位表示，精度为 64 位有效位，剩余 15 位被用来编码指数部分。</p><p>怎么样能在自己的计算机上确定这些类型的大小呢？我们可以写一个程序来干这事儿：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"char size: %lu bytes\n"</span>, <span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"int size: %lu bytes\n"</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"short size: %lu bytes\n"</span>, <span class="keyword">sizeof</span>(<span class="keyword">short</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"long size: %lu bytes\n"</span>, <span class="keyword">sizeof</span>(<span class="keyword">long</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"float size: %lu bytes\n"</span>, <span class="keyword">sizeof</span>(<span class="keyword">float</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"double size: %lu bytes\n"</span>, <span class="keyword">sizeof</span>(<span class="keyword">double</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"long double size: %lu bytes\n"</span>, <span class="keyword">sizeof</span>(<span class="keyword">long</span> <span class="keyword">double</span>));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">char size: 1 bytes</span><br><span class="line">int size: 4 bytes</span><br><span class="line">short size: 2 bytes</span><br><span class="line">long size: 8 bytes</span><br><span class="line">float size: 4 bytes</span><br><span class="line">double size: 8 bytes</span><br><span class="line">long double size: 16 bytes</span><br></pre></td></tr></tbody></table></figure><h1 id="常量">常量<a class="" href="#常量"></a></h1><p>常量的声明与变量类似，不同之处在于常量声明的前面带有 <code>const</code> 关键字，并且需要给常量指定一个值。</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> age = <span class="number">37</span>;</span><br></pre></td></tr></tbody></table></figure><p>通常情况下将常量声明为大写</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> AGE = <span class="number">37</span>;</span><br></pre></td></tr></tbody></table></figure><p>另一种定义常量的方式是使用这种语法：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AGE 37</span></span><br></pre></td></tr></tbody></table></figure><p>在这种情况下，不需要添加类型，也不需要使用等于符号 <code>=</code>，并且可以省略末尾的分号。C 编译器将会在编译时从声明的值推断出相应的类型。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> C语言入门手册 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一、C语言简介</title>
      <link href="/post/164885416/"/>
      <url>/post/164885416/</url>
      
        <content type="html"><![CDATA[<p>C 可能是最广为人知的编程语言。它被全世界的计算机科学课程中用作参考语言，除了 Python 与 Java，它可能是人们在学校学得最多得编程语言。</p><p>今天，C 在嵌入式设备中广泛使用，它驱动着绝大多数用 Linux 搭建的因特网服务器。Linux 内核是用 C 写的，这也意味着 C 驱动着所有安卓设备的内核。可以这么说，此时此刻，整个世界的一大部分就是由 C 代码运行的，令人惊叹。</p><p>在诞生之初，C 被认为是一门高级语言，因为它可以在不同机器之间移植。如今，我们或多或少都认为在 Mac 或 Windows 或 Linux 运行一个程序（可能使用 Node.js 或 Python）是理所当然的。</p><p>C 是一门编译型语言，就像 Go、Java、Swift 或 Rust 一样。其它流行的语言，比如 Python、Ruby 或 JavaScript 都是解释型语言。编译型语言与解释型语言的差别是不变的：编译型语言生成的是可直接执行和分发的二进制文件。</p><p>C 不支持垃圾收集（garbage collection），这意味着我们必须自己管理内存。管理内存是一项复杂的任务，需要十分小心才能预防缺陷，但 C 也因此成为了嵌入式设备（例如 Arduino）编程的理想语言。</p><p>C 并不会隐藏下层机器的复杂性和能力。一旦知道你能做什么，你就能拥有巨大的能力。</p><p>现在，编写我们第一个 C程序 <code>Hello,World</code>。</p><p><code>hello.c</code></p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>{</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Hello,World!"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>C 是一门编译型语言。要运行程序，我们必须先编译它。任何 Linux 或 macOS 计算机都自带了 C 编译器。至于 Windows，你可以使用适用于 Linux 的 Windows 子系统（WSL）。</p><p>打开 Mac 终端输入 <code>gcc</code> 如果这个命名返回一个错误，提示没有声明任何文件：</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/2021/12/image-20211223184031416.png" alt="gcc"></p><p>编译<code>hello.c</code></p><p>终端输入</p><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">gcc hello.c -o hello</span><br></pre></td></tr></tbody></table></figure><p>此时会生成一个可执行的 <code>hello</code> 文件</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/2021/12/image-20211223184528050.png" alt="编译 hello.c"></p><p>执行 <code>hello</code> 文件</p><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">./hello</span><br></pre></td></tr></tbody></table></figure><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/2021/12/image-20211223184651155.png" alt="hello world"></p><p>第一个 C 语言程序就完成了。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> C语言入门手册 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对象的创建与死亡以及内存分配、回收机制</title>
      <link href="/post/164885507/"/>
      <url>/post/164885507/</url>
      
        <content type="html"><![CDATA[<h2 id="对象的创建">对象的创建<a class="" href="#对象的创建"></a></h2><h3 id="对象创建的主要流程">对象创建的主要流程<a class="" href="#对象创建的主要流程"></a></h3><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/images/2020/09/07/image-20200907160940185.png" alt="对象创建的流程"></p><h3 id="类加载检查">类加载检查<a class="" href="#类加载检查"></a></h3><p>当虚拟机遇到<code>new</code>指令时，首先要检查这个指令的参数是否能在常量池中找到类的符号引用，并检查这个符号引用的类是否已经被加载，验证、解析、初始化过，如果没有那必须先执行相应的类加载过程。</p><h3 id="分配内存">分配内存<a class="" href="#分配内存"></a></h3><p>类加载检查通过后，接下来虚拟机要为新生对象分配内存。对象所需要的内存大小在类加载后便可确定。为对象分配空间的任务等同于把一块大小的确定的内存从堆内存中划分出来。</p><p>对象内存分配中有两个问题：</p><ol><li>如何进行内存划分</li><li>并发情况下如何保证多个对象同时内存分配成功。</li></ol><h4 id="内存分配方式">内存分配方式<a class="" href="#内存分配方式"></a></h4><h5 id="指针碰撞（bump-the-Pointer）">指针碰撞（bump the Pointer）<a class="" href="#指针碰撞（bump-the-Pointer）"></a></h5><p>假设 Java 堆内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放一个指针作为分界点的指示器，那么分配内存就仅仅是把指针向空闲那部分移动对象大小相等的距离。</p><h5 id="空闲列表（Free-List）">空闲列表（Free List）<a class="" href="#空闲列表（Free-List）"></a></h5><p>如果 Java 堆内存不是规整的，已使用的内存和未使用的内存空间交错，此时无法使用指针碰撞分配方式，则需要由虚拟机维护一个内存列表，记录哪些内存时可用的，在分配的时候找到一块足够大的空间分配给对象，并更新列表。</p><h4 id="并发分配">并发分配<a class="" href="#并发分配"></a></h4><h5 id="线程同步处理">线程同步处理<a class="" href="#线程同步处理"></a></h5><p>虚拟机通过 CAS + 失败重试机制将内存分配空间的动作进行同步处理。</p><h5 id="本地线程分配缓冲">本地线程分配缓冲<a class="" href="#本地线程分配缓冲"></a></h5><p>本地线程分配缓冲（Thread Local Allocation buffe，TLAB）是把内存空间分配动作按照线程分配到不同的空间进行，即每个线程在 Java 堆中预先分配一小块内存。哪个线程需要分配内存，就在哪个线程的 TLAB 上进行，只有在 TLAB 用完并分配新的 TLAB 时才需要进行同步锁定，虚拟机默认开启 TLAB。虚拟机是否启用 TLAB 可以通过 <code>+XX:+/-UseTLAB</code>  参数来设定。</p><h3 id="对象初始化">对象初始化<a class="" href="#对象初始化"></a></h3><p>内存分配完之后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头）。如果使用 TLAB，这一过程也可以提前至 TLAB 时进行。对象实例属性初始化零值保证了对象实例字段在 Java 代码中不用赋值也能使用，程序能访问到这些对象字段数据类型对应的零值。</p><p>基本数据类型的零值：</p><table><thead><tr><th>数据类型</th><th>零值</th></tr></thead><tbody><tr><td><code>byte</code></td><td><code>(byte)0</code></td></tr><tr><td><code>char</code></td><td><code>'\u0000'</code></td></tr><tr><td><code>short</code></td><td><code>(short)0</code></td></tr><tr><td><code>boolean</code></td><td><code>false</code></td></tr><tr><td><code>int</code></td><td><code>0</code></td></tr><tr><td><code>long</code></td><td><code>0l</code></td></tr><tr><td><code>float</code></td><td><code>0.0f</code></td></tr><tr><td><code>double</code></td><td><code>0.0</code></td></tr><tr><td><code>reference</code></td><td><code>null</code></td></tr></tbody></table><h3 id="设置对象头">设置对象头<a class="" href="#设置对象头"></a></h3><p>在对象初始化之后，虚拟机还需要对对象进行必要的设置，例如这个对象是哪个类的实例，如何才能找到类的元数据信息，对象的哈希码、对象的分代年龄等。这些信息存放在对象的对象头（Object Header）中。</p><h3 id="执行-init-方法">执行<init>方法<a class="" href="#执行-init-方法"></a></init></h3><p>从虚拟机角度来讲，上面的步骤执行完之后，一个新的对象就已经产生。但是从程序员角度来说还需要执行<code>&lt;init&gt;</code>方法和构造方法为对象的属性赋值。至此一个完整的对象才算生产出来。</p><h2 id="对象的内存布局">对象的内存布局<a class="" href="#对象的内存布局"></a></h2><h3 id="OOP-Klass-Model">OOP-Klass Model<a class="" href="#OOP-Klass-Model"></a></h3><p>在理解对象的内存布局之前，可以总体了解一下在 Hotspot 虚拟机中对象的 OOP-Klass 模型，这里的 OOP 指的是Oridinary Object Pointer(普通对象指针)，他用来表示对象的实例信息，实际上是隐藏在在指针里面的对象。而 Klass 则包含元数据和方法信息，用来描述 Java 类。</p><p>JVM 使用 Oop 来表示一个对象，在 Java 程序运行过程中，每创建一个新的对象，在 JVM 内部都会在 JVM 内部创建一个对象类型的 oop 对象。各种 oop 类的共同基类为 oopDesc 类。oop 的继承体系如下：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// hotspot/src/share/vm/oops/oopsHierarchy.hpp</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">// Oop的继承体系</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">class</span> <span class="title">oopDesc</span>*                            <span class="title">oop</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">class</span>   <span class="title">instanceOopDesc</span>*            <span class="title">instanceOop</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">class</span>   <span class="title">arrayOopDesc</span>*                    <span class="title">arrayOop</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">class</span>     <span class="title">objArrayOopDesc</span>*            <span class="title">objArrayOop</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">class</span>     <span class="title">typeArrayOopDesc</span>*            <span class="title">typeArrayOop</span>;</span></span><br><span class="line">...</span><br></pre></td></tr></tbody></table></figure><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/images/2020/09/08/image-20200908145725254.png" alt="oop 继承体系"></p><p>oop 的子类有两个，分别是 instanceOop 和 arrayOop。前者表示 Java 中普通的对象，后者表示数组对象。oop 的储存结构主要由对象头和对象体组成。</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/images/2020/09/08/image-20200908155943599.png" alt="oop 内存结构"></p><p>Oop 的主要的两个成员属性：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// hotspot/src/share/vm/oops/oop.hpp</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">oopDesc</span> {</span></span><br><span class="line"> ...</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// 用于存储对象的运行时记录信息，如哈希值、GC分代年龄、锁状态等</span></span><br><span class="line">  <span class="keyword">volatile</span> markOop  _mark;</span><br><span class="line">  <span class="comment">// Klass指针的联合体，指向当前对象所属的Klass对象</span></span><br><span class="line">  <span class="class"><span class="keyword">union</span> _<span class="title">metadata</span> {</span></span><br><span class="line">    <span class="comment">// 未采用指针压缩技术时使用</span></span><br><span class="line">    Klass*      _klass;</span><br><span class="line">    <span class="comment">// 采用指针压缩技术时使用</span></span><br><span class="line">    narrowKlass _compressed_klass;</span><br><span class="line">  } _metadata;</span><br><span class="line"> ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>_mark</code>和<code>_metadata</code>被称为<strong>对象头</strong>，其中前者存储对象的运行时记录信息；后者是一个指针，指向当前对象所属的<code>Klass</code>对象。</p><p>和 oop 一样 Klass 也有一个继承体系：</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/images/2020/09/08/image-20200908160820508.png" alt="Klass 继承体系"></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// hotspot/src/share/vm/oops/oopsHierarchy.hpp</span></span><br><span class="line">...</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Klass</span>;</span>  <span class="comment">// Klass继承体系的最高父类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span>   <span class="title">InstanceKlass</span>;</span>  <span class="comment">// 表示一个Java普通类，包含了一个类运行时的所有信息</span></span><br><span class="line"><span class="class"><span class="keyword">class</span>     <span class="title">InstanceMirrorKlass</span>;</span>  <span class="comment">// 表示java.lang.Class</span></span><br><span class="line"><span class="class"><span class="keyword">class</span>     <span class="title">InstanceClassLoaderKlass</span>;</span> <span class="comment">// 主要用于遍历ClassLoader继承体系</span></span><br><span class="line"><span class="class"><span class="keyword">class</span>     <span class="title">InstanceRefKlass</span>;</span>  <span class="comment">// 表示java.lang.ref.Reference及其子类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span>   <span class="title">ArrayKlass</span>;</span>  <span class="comment">// 表示一个Java数组类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span>     <span class="title">ObjArrayKlass</span>;</span>  <span class="comment">// 普通对象的数组类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span>     <span class="title">TypeArrayKlass</span>;</span>  <span class="comment">// 基础类型的数组类</span></span><br><span class="line">...</span><br></pre></td></tr></tbody></table></figure><p>不同于Oop，Klass在<code>InstanceKlass</code>下又设计了3个子类，其中<code>InstanceMirrorKlass</code>用于表示java.lang.Class类型，该类型对应的oop特别之处在于其包含了<code>static field</code>，因此计算<code>oop</code>大小时需要把<code>static field</code>也考虑进来；<code>InstanceClassLoaderKlass</code>主要提供了遍历当前<code>ClassLoader</code>的继承体系；<code>InstanceRefKlass</code>用于表示<code>java.lang.ref.Reference</code>及其子类。</p><p>总体来说在 Hotspot 虚拟机中存在对象、类的元数据（InstanceKlass）、类的 Java 镜像是那种对象。三者之间的关系是这样的：</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/images/post/2020/09/image-20200909004159729.png" alt="Hotspot Klass"></p><p>每个Java对象的对象头里，_klass字段会指向一个VM内部用来记录类的元数据用的InstanceKlass对象；InsanceKlass里有个_java_mirror字段，指向该类所对应的Java镜像——java.lang.Class实例。HotSpot VM会给Class对象注入一个隐藏字段“klass”，用于指回到其对应的InstanceKlass对象。这样，klass与mirror之间就有双向引用，可以来回导航。这个模型里，java.lang.Class实例并不负责记录真正的类元数据，而只是对VM内部的InstanceKlass对象的一个包装供Java的反射访问用。</p><p>在JDK 7或之前的HotSpot VM里，InstanceKlass是被包装在由GC管理的klassOopDesc对象中，存放在GC堆中的所谓Permanent Generation（简称PermGen）中。从JDK 8开始的HotSpot VM则完全移除了PermGen，改为在native memory里存放这些元数据。新的用于存放元数据的内存空间叫做Metaspace，InstanceKlass对象就存在这里。至于java.lang.Class对象，它们从来都是“普通”Java对象，跟其它Java对象一样存在普通的Java堆（GC堆的一部分）里。</p><h3 id="对象头">对象头<a class="" href="#对象头"></a></h3><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/images/post/2020/09/image-20200908210059547.png" alt="对象头"></p><p>Hotspot 虚拟机对象头分为两部分，一部分是用来储存对象自身运行时数据，如 hash 码、GC 分代年龄、锁状态标志、偏向线程 ID、线程持有的锁等，称为<code>Mark Word</code> 即 JVM 中的 markOop。</p><p>另一部分为对象指向它自身类元数据的类型指针。虚拟机通过这个指针来确定对象是哪个类的实例及 _metadata。</p><p>对于数组对象，在对象头中还必须有一块用于记录数组长度的数据。因为虚拟机可以通过普通Java对象的元数据信息确定Java对象的大小，但是从数组的元数据中却无法确定数组的大小。</p><h4 id="Mark-Word">Mark Word<a class="" href="#Mark-Word"></a></h4><p>Mark Word 用来储存对象自身运行时数据，如hash码，GC 分代年龄、锁状态、偏向线程 ID、线程持有的锁、偏向时间戳等，这部分数据在 32 位虚拟机和 64 位虚拟机（未开启指针压缩）分别为32bit 和 64 bit。Mark Word 在 32 位虚拟机中存储内容如下：</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/images/2020/09/08/%E5%AF%B9%E8%B1%A1%E5%A4%B4%20Mark%20Word.png" alt="对象头 Mark Word"></p><h3 id="实例数据">实例数据<a class="" href="#实例数据"></a></h3><p>实例数据部分是对象真正存储的有效信息，也是在程序代码中所定义的各种类型的字段内容。无论是从父类继承下来的，还是在子类中定义的，都需要记录起来。这部分的存储顺序会受到虚拟机分配策略参数和字段在源码中定义顺序的影响。HotSpot 虚拟机默认的分配策略为 longs/doubules、ints、shorts/chars、bytes/booleans、oops。从分配策略中可以看出，相同宽度的字段总是被分配在一起。在满足这个前提条件的情况下，在父类中定义的变量会出现在子类之前。如果 CompactFields 参数值为 true（默认为 true），那么子类中较窄的变量也可能会插入到父类变量的空隙中。</p><h3 id="对齐填充">对齐填充<a class="" href="#对齐填充"></a></h3><p>第三部分对齐填充并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用。由于HotSpot VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说，就是对象的大小必须是8字节的整数倍。而对象头部分正好是8字节的倍数（1倍或者2倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。这种排布方式可以让原始类型字段最大限度地紧凑排布在一起，减少字段间因为对齐而带来的空隙；同时又让引用类型字段尽可能排布在一起，减少OopMap的开销。</p><p>举例来说，对于下面的类 C</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>{</span><br><span class="line">  <span class="keyword">boolean</span> b;</span><br><span class="line">  Object o1;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>{</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">long</span> l;</span><br><span class="line">  Object o2;</span><br><span class="line">  <span class="keyword">float</span> f;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">B</span> </span>{</span><br><span class="line">  <span class="keyword">boolean</span> b;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>它的实例对象布局就是：（假定是64位HotSpot VM，开启了压缩指针的话）</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">--&gt;  +<span class="number">0</span> [ _mark     ] (<span class="number">64</span>-bit header word)</span><br><span class="line">     +<span class="number">8</span> [ _klass    ] (<span class="number">32</span>-bit header word, compressed klass pointer)</span><br><span class="line">    +<span class="number">12</span> [ A.b       ] (<span class="keyword">boolean</span>, <span class="number">1</span> <span class="keyword">byte</span>)</span><br><span class="line">    +<span class="number">13</span> [ (padding) ] (padding <span class="keyword">for</span> alignment, <span class="number">3</span> bytes)</span><br><span class="line">    +<span class="number">16</span> [ A.o1      ] (reference, compressed pointer, <span class="number">4</span> bytes)</span><br><span class="line">    +<span class="number">20</span> [ B.i       ] (<span class="keyword">int</span>, <span class="number">4</span> bytes)</span><br><span class="line">    +<span class="number">24</span> [ B.l       ] (<span class="keyword">long</span>, <span class="number">8</span> bytes)</span><br><span class="line">    +<span class="number">32</span> [ B.f       ] (<span class="keyword">float</span>, <span class="number">4</span> bytes)</span><br><span class="line">    +<span class="number">36</span> [ B.o2      ] (reference, compressed pointer, <span class="number">4</span> bytes)</span><br><span class="line">    +<span class="number">40</span> [ C.b       ] (<span class="keyword">boolean</span>, <span class="number">1</span> <span class="keyword">byte</span>)</span><br><span class="line">    +<span class="number">41</span> [ (padding) ] (padding <span class="keyword">for</span> object alignment, <span class="number">7</span> bytes)</span><br></pre></td></tr></tbody></table></figure><p>所以C类的对象实例大小，在这个设定下是48字节，其中有10字节是为对齐而浪费掉的padding，12字节是对象头，剩下的26字节是用户自己代码声明的实例字段。</p><p>留意到C类里字段的排布是按照这个顺序的：对象头 - Object声明的字段（无） - A声明的字段 - B声明的字段 - C声明的字段——按继承深度从浅到深排布。而每个类里面的字段排布顺序则按前面说的规则，按宽度来重排序。同时，如果类继承边界上有空隙（例如这里A和B之间其实本来会有一个4字节的空隙，但B里正好声明了一些不宽于4字节的字段，就可以把第一个不宽于4字节的字段拉到该空隙里，也就是 B.i 的位置）。</p><p>同时也请留意到A类和C类都声明了名字为b的字段。它们之间有什么关系？——没关系。Java里，字段是不参与多态的。派生类如果声明了跟基类同名的字段，则两个字段在最终的实例中都会存在；派生类的版本只会在名字上遮盖（shadow / hide）掉基类字段的名字，而不会与基类字段合并或令其消失。上面例子特意演示了一下A.b 与 C.b 同时存在的这个情况。</p><p>使用 JOL工具查看对象的信息：</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"># WARNING: Unable to attach Serviceability Agent. You can try again with escalated privileges. Two options: a) use -Djol.tryWithSudo=true to try with sudo; b) echo 0 | sudo tee /proc/sys/kernel/yama/ptrace_scope</span><br><span class="line">tech.stack.C object internals:</span><br><span class="line"> OFFSET  SIZE               TYPE DESCRIPTION                               VALUE</span><br><span class="line">      <span class="number">0</span>     <span class="number">4</span>                    (object header)                           <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000001</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">1</span>)</span><br><span class="line">      <span class="number">4</span>     <span class="number">4</span>                    (object header)                           <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">0</span>)</span><br><span class="line">      <span class="number">8</span>     <span class="number">4</span>                    (object header)                           <span class="number">05</span> c2 <span class="number">00</span> f8 (<span class="number">00000101</span> <span class="number">11000010</span> <span class="number">00000000</span> <span class="number">11111000</span>) (-<span class="number">134168059</span>)</span><br><span class="line">     <span class="number">12</span>     <span class="number">1</span>            <span class="keyword">boolean</span> A.b                                       <span class="keyword">false</span></span><br><span class="line">     <span class="number">13</span>     <span class="number">3</span>                    (alignment/padding gap)                  </span><br><span class="line">     <span class="number">16</span>     <span class="number">4</span>   java.lang.Object A.o1                                      <span class="keyword">null</span></span><br><span class="line">     <span class="number">20</span>     <span class="number">4</span>                <span class="keyword">int</span> B.i                                       <span class="number">0</span></span><br><span class="line">     <span class="number">24</span>     <span class="number">8</span>               <span class="keyword">long</span> B.l                                       <span class="number">0</span></span><br><span class="line">     <span class="number">32</span>     <span class="number">4</span>              <span class="keyword">float</span> B.f                                       <span class="number">0.0</span></span><br><span class="line">     <span class="number">36</span>     <span class="number">4</span>   java.lang.Object B.o2                                      <span class="keyword">null</span></span><br><span class="line">     <span class="number">40</span>     <span class="number">1</span>            <span class="keyword">boolean</span> C.b                                       <span class="keyword">false</span></span><br><span class="line">     <span class="number">41</span>     <span class="number">7</span>                    (loss due to the next object alignment)</span><br><span class="line">Instance size: <span class="number">48</span> bytes</span><br><span class="line">Space losses: <span class="number">3</span> bytes internal + <span class="number">7</span> bytes external = <span class="number">10</span> bytes total</span><br></pre></td></tr></tbody></table></figure><h3 id="指针压缩">指针压缩<a class="" href="#指针压缩"></a></h3><h4 id="什么是对象的指针压缩">什么是对象的指针压缩<a class="" href="#什么是对象的指针压缩"></a></h4><ul><li><p>jdk1.6 update14开始，在64bit操作系统中，JVM支持指针压缩</p></li><li><p>jvm配置参数:UseCompressedOops，compressed­­压缩、oop(ordinary object pointer)­­对象指针</p></li><li><p>启用指针压缩:-­XX:+UseCompressedOops(<strong>默认开启</strong>)，禁止指针压缩:-­XX:-­UseCompressedOops</p></li></ul><h4 id="为什么要进行指针压缩">为什么要进行指针压缩<a class="" href="#为什么要进行指针压缩"></a></h4><ul><li><p>在64位平台的HotSpot中使用32位指针，内存使用会多出1.5倍左右，使用较大指针在主内存和缓存之间移动数据， <strong>占用较大IO，同时GC也会承受较大压力</strong></p></li><li><p>为了减少64位平台下内存的消耗，启用指针压缩功能</p></li><li><p>在jvm中，32位地址最大支持4G内存(2的32次方)，可以通过对对象指针的压缩编码、解码方式进行优化，使得 jvm 只用32位地址就可以支持更大的内存配置(小于等于32G)</p></li><li><p>堆内存小于4G时，不需要启用指针压缩，jvm会直接去除高32位地址，即使用低虚拟地址空间</p></li><li><p>堆内存大于32G时，压缩指针会失效，会强制使用64位(即8字节)来对java对象寻址，这就会出现1的问题，所以堆内存不要大于32G为好</p></li></ul><h4 id="CompressedOops的原理">CompressedOops的原理<a class="" href="#CompressedOops的原理"></a></h4><p>32位内最多可以表示4GB，64位地址分为堆的基地址+偏移量，当堆内存&lt;32GB时候，在压缩过程中，把偏移量/8后保存到32位地址。在解压再把32位地址放大8倍，所以启用CompressedOops的条件是堆内存要在<code>4GB*8=32GB</code>以内。</p><p>所以压缩指针之所以能改善性能，是因为它通过对齐（Alignment），还有偏移量（Offset）将64位指针压缩成32位。换言之，性能提高是因为使用了更小更节省空间的压缩指针而不是完整长度的64位指针，CPU缓存使用率得到改善，应用程序也能执行得更快。</p><ul><li><p><strong>零基压缩优化(Zero Based Compressd Oops)：</strong></p><p>零基压缩是针对压解压动作的进一步优化。 它通过改变正常指针的随机地址分配特性，强制堆地址从零开始分配（需要OS支持），进一步提高了压解压效率。要启用零基压缩，你分配给JVM的内存大小必须控制在4G以上，32G以下。如果GC堆大小在4G以下，直接砍掉高32位，避免了编码解码过程 如果GC堆大小在4G以上32G以下，则启用UseCompressedOop 如果GC堆大小大于32G，压指失效，使用原来的64位（所以说服务器内存太大不好…）。</p></li></ul><h4 id="案例">案例<a class="" href="#案例"></a></h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// -XX:-UserCompressedOops</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        ClassLayout classLayout = ClassLayout.parseInstance(<span class="keyword">new</span> C());</span><br><span class="line">        System.out.println(classLayout.toPrintable());</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">// ---------------</span></span><br><span class="line"># WARNING: Unable to attach Serviceability Agent. You can try again with escalated privileges. Two options: a) use -Djol.tryWithSudo=true to try with sudo; b) echo 0 | sudo tee /proc/sys/kernel/yama/ptrace_scope</span><br><span class="line">tech.stack.C object internals:</span><br><span class="line"> OFFSET  SIZE               TYPE DESCRIPTION                               VALUE</span><br><span class="line">      <span class="number">0</span>     <span class="number">4</span>                    (object header)                           <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000001</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">1</span>)</span><br><span class="line">      <span class="number">4</span>     <span class="number">4</span>                    (object header)                           <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">0</span>)</span><br><span class="line">      <span class="number">8</span>     <span class="number">4</span>                    (object header)                           <span class="number">30</span> fd ca <span class="number">9d</span> (<span class="number">00110000</span> <span class="number">11111101</span> <span class="number">11001010</span> <span class="number">10011101</span>) (-<span class="number">1647641296</span>)</span><br><span class="line">     <span class="number">12</span>     <span class="number">4</span>                    (object header)                           <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> (<span class="number">00000001</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span>) (<span class="number">1</span>)</span><br><span class="line">     <span class="number">16</span>     <span class="number">1</span>            <span class="keyword">boolean</span> A.b                                       <span class="keyword">false</span></span><br><span class="line">     <span class="number">17</span>     <span class="number">7</span>                    (alignment/padding gap)                  </span><br><span class="line">     <span class="number">24</span>     <span class="number">8</span>   java.lang.Object A.o1                                      <span class="keyword">null</span></span><br><span class="line">     <span class="number">32</span>     <span class="number">8</span>               <span class="keyword">long</span> B.l                                       <span class="number">0</span></span><br><span class="line">     <span class="number">40</span>     <span class="number">4</span>                <span class="keyword">int</span> B.i                                       <span class="number">0</span></span><br><span class="line">     <span class="number">44</span>     <span class="number">4</span>              <span class="keyword">float</span> B.f                                       <span class="number">0.0</span></span><br><span class="line">     <span class="number">48</span>     <span class="number">8</span>   java.lang.Object B.o2                                      <span class="keyword">null</span></span><br><span class="line">     <span class="number">56</span>     <span class="number">1</span>            <span class="keyword">boolean</span> C.b                                       <span class="keyword">false</span></span><br><span class="line">     <span class="number">57</span>     <span class="number">7</span>                    (loss due to the next object alignment)</span><br><span class="line">Instance size: <span class="number">64</span> bytes</span><br><span class="line">Space losses: <span class="number">7</span> bytes internal + <span class="number">7</span> bytes external = <span class="number">14</span> bytes total</span><br></pre></td></tr></tbody></table></figure><p>使用<code>-XX:-UseCompressedOops</code>关闭指针压缩，再次使用 JOL 工具查看对象 C 内存分配可以看出对象 C 占用了 64 字节，明显要比开启指针压缩时 48 字节大得多。</p><h2 id="对象的访问定位">对象的访问定位<a class="" href="#对象的访问定位"></a></h2><p>程序使用对象是通过栈上的 reference 数据来操作堆上的具体对象。由于 reference 类型在 Java 虚拟机规范中只规定了一个指向对象的引用，并没有定义这个引用应该通过何种方式去定位，访问堆中的对象的具体位置，所以对象访问方式也是取决于虚拟机实现而定的。目前主流的访问方式有使用句柄和直接指针两种中。</p><h3 id="直接指针">直接指针<a class="" href="#直接指针"></a></h3><p>如果使用直接指针访问，那么 Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而 reference 中存储的直接就是对象地址。</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/images/post/2020/09/image-20200908230842135.png" alt="直接引用"></p><p>直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销，由于对象的访问在 Java 中十分频繁，因此此类开销极少成多后也是一项十分可观的成本。HotSpot 虚拟机使用的就是直接指针访问方式。</p><h3 id="句柄访问">句柄访问<a class="" href="#句柄访问"></a></h3><p>如果使用句柄访问，那么 Java 堆中会划分出来一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址。</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/images/post/2020/09/image-20200908231416270.png" alt="句柄访问"></p><p>句柄访问最大的好处就是 reference 中存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。</p><h2 id="对象的内存分配">对象的内存分配<a class="" href="#对象的内存分配"></a></h2><p>对象的内存分配一般来说都是堆上分配，但是也可能经过 JIT 编译后被拆散为标量类型并间接地在栈上分配。下面将通过一些代码来理解对象内存分配的规则。</p><h3 id="对象栈上分配">对象栈上分配<a class="" href="#对象栈上分配"></a></h3><h4 id="逃逸分析">逃逸分析<a class="" href="#逃逸分析"></a></h4><p>逃逸分析（Escape Analysis）的基本行为是就分析对象动态作用域：当一个对象在方法中被定义后，它可以能被外部方法所引用，例如作为调用参数传递到其他方法中，称为方法逃逸。甚至还有可能被外部线程访问到，譬如赋值给类变量或可以在其他线程中访问的实例变量，称为线程逃逸。</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> A <span class="title">escape</span><span class="params">()</span> </span>{</span><br><span class="line">    A a = <span class="keyword">new</span> A();</span><br><span class="line">    a.b = <span class="keyword">false</span>;</span><br><span class="line">    a.o1 = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">noEscape</span><span class="params">()</span></span>{</span><br><span class="line">    A a = <span class="keyword">new</span> A();</span><br><span class="line">    a.b = <span class="keyword">false</span>;</span><br><span class="line">    a.o1 = <span class="keyword">new</span> Object();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>如上例代码 <code>escape</code> 方法中的 <code>a</code>对象返回了，这个对象的作用域范围就无法确定，因此<code>a</code>对象在方法<code>escape</code>中逃逸了。 <code>noEscape</code>方法中的 a 对象我们可以确定当方法结束，这个对象就可以认为是无效对象了，对象<code>a</code> 没有逃逸出 <code>noEscape</code> 方法。</p><p>JVM 对于这种情况可以通过参数<code>-XX:+DoEscapeAnalysis</code>来开启逃逸分析。开启后可以通过<code>-XX:PrintEscapeAnalysis</code>来查看分析结果。JDK7  之后默认开启逃逸分析，如果要关闭使用参数<code>-XX:-DoEscapeAnalysis</code>。</p><h4 id="标量替换">标量替换<a class="" href="#标量替换"></a></h4><p>如果把一个对象拆散，根据程序访问的情况，将其使用到的成员变量恢复原始类型来访问就叫做标量替换（Scalar Replacement）。标量（Scalar）是指一个数据已经无法再分解成更小的数据来表示了，Java 虚拟机中的原始数据类型（int、long 等数值类型以及 reference 类型等）都不能进一步分解，它们就可以成为标量。相对的，如果一个数据可以继续分解，那它就称作聚合量（Aggregate），Java 中的对象就是最典型的聚合量。</p><p>如果逃逸分析证明一个对象不会被外部访问，并且这个对象可以被拆散的话，那程序真正执行的时候将可能不会创建这个对象，而改为直接创建它的若干个被这个方法使用到的成员变量来代替。这些代替的成员变量在栈帧或寄存器上分配空间，这样就不会因为没有一大块连续空间导致对象内存不够分配。开启标量替换参数(-XX:+EliminateAllocations)，JDK7之后默认开启。</p><h4 id="栈上分配示例">栈上分配示例<a class="" href="#栈上分配示例"></a></h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 逃逸分析 标量替换 -&gt; 栈上分配</span></span><br><span class="line"><span class="comment"> * 调用一亿次 alloc() 如果分配到堆上 大约需要 48B x 1000000 ≈ 45m 的空间 如果堆空间小于该值, 必然会触发 GC</span></span><br><span class="line"><span class="comment"> * 使用如下参数不会发生 GC:</span></span><br><span class="line"><span class="comment"> * -Xmx15m -Xms15m -XX:+DoEscapeAnalysis -XX:+EliminateAllocations  -XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 使用如下参数都会发生大量 GC</span></span><br><span class="line"><span class="comment"> * 关闭逃逸分析 开启标量替换</span></span><br><span class="line"><span class="comment"> * -Xmx15m -Xms15m -XX:-DoEscapeAnalysis -XX:+EliminateAllocations  -XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 开启逃逸分析 关闭标量替换</span></span><br><span class="line"><span class="comment"> * -Xmx15m -Xms15m -XX:+DoEscapeAnalysis -XX:-EliminateAllocations  -XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AllocateOnStack</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">alloc</span><span class="params">()</span> </span>{</span><br><span class="line">        C c = <span class="keyword">new</span> C();</span><br><span class="line">        c.b = <span class="keyword">true</span>;</span><br><span class="line">        c.i = <span class="number">1</span>;</span><br><span class="line">        c.f = <span class="number">2.0F</span>;</span><br><span class="line">        c.l = <span class="number">1L</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) {</span><br><span class="line">            alloc();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"time used: "</span> + (end - start));</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">20</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//  -Xmx15m -Xms15m -XX:+DoEscapeAnalysis -XX:+EliminateAllocations  -XX:+PrintGCDetails</span></span><br><span class="line">time used: <span class="number">11</span></span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 4096K-&gt;480K(4608K)] 4096K-&gt;488K(15872K), <span class="number">0.0027909</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 4608K, used 1487K [<span class="number">0x00000007bfb00000</span>, <span class="number">0x00000007c0000000</span>, <span class="number">0x00000007c0000000</span>)</span><br><span class="line">  eden space 4096K, <span class="number">24</span>% used [<span class="number">0x00000007bfb00000</span>,<span class="number">0x00000007bfbfbcb0</span>,<span class="number">0x00000007bff00000</span>)</span><br><span class="line">  from space 512K, <span class="number">93</span>% used [<span class="number">0x00000007bff00000</span>,<span class="number">0x00000007bff78000</span>,<span class="number">0x00000007bff80000</span>)</span><br><span class="line">  to   space 512K, <span class="number">0</span>% used [<span class="number">0x00000007bff80000</span>,<span class="number">0x00000007bff80000</span>,<span class="number">0x00000007c0000000</span>)</span><br><span class="line"> ParOldGen       total 11264K, used 8K [<span class="number">0x00000007bf000000</span>, <span class="number">0x00000007bfb00000</span>, <span class="number">0x00000007bfb00000</span>)</span><br><span class="line">  object space 11264K, <span class="number">0</span>% used [<span class="number">0x00000007bf000000</span>,<span class="number">0x00000007bf002000</span>,<span class="number">0x00000007bfb00000</span>)</span><br><span class="line"> Metaspace       used 3641K, capacity 4606K, committed 4864K, reserved 1056768K</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">space</span>    <span class="title">used</span> 406<span class="title">K</span>, <span class="title">capacity</span> 430<span class="title">K</span>, <span class="title">committed</span> 512<span class="title">K</span>, <span class="title">reserved</span> 1048576<span class="title">K</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line">//  -Xmx15m -Xms15m -XX:-DoEscapeAnalysis -XX:+EliminateAllocations  -XX:+PrintGCDetails                                </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 4096K-&gt;464K(4608K)] 4096K-&gt;472K(15872K), <span class="number">0.0023558</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.01</span> secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 4560K-&gt;480K(4608K)] 4568K-&gt;488K(15872K), <span class="number">0.0016919</span> secs] [Times: user=<span class="number">0.01</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 4576K-&gt;464K(4608K)] 4584K-&gt;480K(15872K), <span class="number">0.0012115</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 4560K-&gt;416K(4608K)] 4576K-&gt;440K(15872K), <span class="number">0.0014123</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.01</span> secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 4512K-&gt;432K(4608K)] 4536K-&gt;456K(15872K), <span class="number">0.0007827</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 4528K-&gt;448K(4608K)] 4552K-&gt;472K(15872K), <span class="number">0.0014156</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 4544K-&gt;64K(4608K)] 4568K-&gt;469K(15872K), <span class="number">0.0011911</span> secs] [Times: user=<span class="number">0.01</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 4160K-&gt;0K(3584K)] 4565K-&gt;429K(14848K), <span class="number">0.0008173</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 3072K-&gt;64K(4096K)] 3501K-&gt;493K(15360K), <span class="number">0.0008980</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 3136K-&gt;0K(4096K)] 3565K-&gt;429K(15360K), <span class="number">0.0008181</span> secs] [Times: user=<span class="number">0.01</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 3072K-&gt;0K(4096K)] 3501K-&gt;429K(15360K), <span class="number">0.0009510</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.01</span> secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 3072K-&gt;96K(4096K)] 3501K-&gt;525K(15360K), <span class="number">0.0010059</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 3168K-&gt;96K(4096K)] 3597K-&gt;549K(15360K), <span class="number">0.0008356</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">time used: <span class="number">32</span></span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 4096K, used 1733K [<span class="number">0x00000007bfb00000</span>, <span class="number">0x00000007c0000000</span>, <span class="number">0x00000007c0000000</span>)</span><br><span class="line">  eden space 3072K, <span class="number">53</span>% used [<span class="number">0x00000007bfb00000</span>,<span class="number">0x00000007bfc996f8</span>,<span class="number">0x00000007bfe00000</span>)</span><br><span class="line">  from space 1024K, <span class="number">9</span>% used [<span class="number">0x00000007bfe00000</span>,<span class="number">0x00000007bfe18000</span>,<span class="number">0x00000007bff00000</span>)</span><br><span class="line">  to   space 1024K, <span class="number">0</span>% used [<span class="number">0x00000007bff00000</span>,<span class="number">0x00000007bff00000</span>,<span class="number">0x00000007c0000000</span>)</span><br><span class="line"> ParOldGen       total 11264K, used 453K [<span class="number">0x00000007bf000000</span>, <span class="number">0x00000007bfb00000</span>, <span class="number">0x00000007bfb00000</span>)</span><br><span class="line">  object space 11264K, <span class="number">4</span>% used [<span class="number">0x00000007bf000000</span>,<span class="number">0x00000007bf071498</span>,<span class="number">0x00000007bfb00000</span>)</span><br><span class="line"> Metaspace       used 3635K, capacity 4606K, committed 4864K, reserved 1056768K</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">space</span>    <span class="title">used</span> 406<span class="title">K</span>, <span class="title">capacity</span> 430<span class="title">K</span>, <span class="title">committed</span> 512<span class="title">K</span>, <span class="title">reserved</span> 1048576<span class="title">K</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line">// -Xmx15m -Xms15m -XX:+DoEscapeAnalysis -XX:-EliminateAllocations  -XX:+PrintGCDetails</span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 4096K-&gt;464K(4608K)] 4096K-&gt;472K(15872K), <span class="number">0.0012666</span> secs] [Times: user=<span class="number">0.01</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 4560K-&gt;496K(4608K)] 4568K-&gt;504K(15872K), <span class="number">0.0007431</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.01</span> secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 4592K-&gt;480K(4608K)] 4600K-&gt;496K(15872K), <span class="number">0.0005317</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 4576K-&gt;432K(4608K)] 4592K-&gt;448K(15872K), <span class="number">0.0005055</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 4528K-&gt;448K(4608K)] 4544K-&gt;464K(15872K), <span class="number">0.0004695</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 4544K-&gt;400K(3584K)] 4560K-&gt;416K(14848K), <span class="number">0.0005831</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 3472K-&gt;96K(4096K)] 3488K-&gt;497K(15360K), <span class="number">0.0005897</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 3168K-&gt;96K(4096K)] 3569K-&gt;513K(15360K), <span class="number">0.0006654</span> secs] [Times: user=<span class="number">0.01</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 3168K-&gt;96K(4096K)] 3585K-&gt;513K(15360K), <span class="number">0.0006979</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 3168K-&gt;0K(4096K)] 3585K-&gt;433K(15360K), <span class="number">0.0011842</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.01</span> secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 3072K-&gt;64K(4096K)] 3505K-&gt;497K(15360K), <span class="number">0.0004890</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 3136K-&gt;32K(4096K)] 3569K-&gt;465K(15360K), <span class="number">0.0010702</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 3104K-&gt;0K(4096K)] 3537K-&gt;449K(15360K), <span class="number">0.0010044</span> secs] [Times: user=<span class="number">0.01</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">time used: <span class="number">25</span></span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 4096K, used 2704K [<span class="number">0x00000007bfb00000</span>, <span class="number">0x00000007c0000000</span>, <span class="number">0x00000007c0000000</span>)</span><br><span class="line">  eden space 3072K, <span class="number">88</span>% used [<span class="number">0x00000007bfb00000</span>,<span class="number">0x00000007bfda4070</span>,<span class="number">0x00000007bfe00000</span>)</span><br><span class="line">  from space 1024K, <span class="number">0</span>% used [<span class="number">0x00000007bfe00000</span>,<span class="number">0x00000007bfe00000</span>,<span class="number">0x00000007bff00000</span>)</span><br><span class="line">  to   space 1024K, <span class="number">0</span>% used [<span class="number">0x00000007bff00000</span>,<span class="number">0x00000007bff00000</span>,<span class="number">0x00000007c0000000</span>)</span><br><span class="line"> ParOldGen       total 11264K, used 449K [<span class="number">0x00000007bf000000</span>, <span class="number">0x00000007bfb00000</span>, <span class="number">0x00000007bfb00000</span>)</span><br><span class="line">  object space 11264K, <span class="number">3</span>% used [<span class="number">0x00000007bf000000</span>,<span class="number">0x00000007bf0704a8</span>,<span class="number">0x00000007bfb00000</span>)</span><br><span class="line"> Metaspace       used 3086K, capacity 4502K, committed 4864K, reserved 1056768K</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">space</span>    <span class="title">used</span> 339<span class="title">K</span>, <span class="title">capacity</span> 390<span class="title">K</span>, <span class="title">committed</span> 512<span class="title">K</span>, <span class="title">reserved</span> 1048576<span class="title">K</span>                                </span></span><br></pre></td></tr></tbody></table></figure><p>由上运行结果可看出开启逃逸分析和标量替换后除了启动 jvm 时发生了一次 GC 其余时间都没有发生 GC，而关闭逃逸分析或者标量替换都会发生大量 GC，同时如果想完成程序栈上分配，则需要同时开始逃逸分析和标量替换。把运行内存参数调整放大<code>+Xms500m +Xmx500m</code> ，让程序睡眠 20s，此时都没有发生 GC,通过 jmap 查看程序的内存分布：</p><p>开启逃逸分析和标量替换：</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/images/post/2020/09/image-20200909014422260.png" alt="逃逸分析"></p><p>此时程序中只存在 68768 个 C 对象。关闭逃逸分析再次查看：</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/images/post/2020/09/image-20200909014627264.png" alt="逃逸分析"></p><p>此时 C 实例对象有 1000000 个。</p><h3 id="对象有现在-Eden-区分配">对象有现在 Eden 区分配<a class="" href="#对象有现在-Eden-区分配"></a></h3><p>大多数情况下，对象在新生代中 Eden 区分配。当 Eden 区没有足够空间进行分配时，虚拟机将发起一次Minor GC。</p><ul><li><p><strong>Minor GC/Young GC</strong>：指发生新生代的的垃圾收集动作，Minor GC非常频繁，回收速度一般也比较快。</p></li><li><p><strong>Major GC/Full GC</strong>：一般会回收老年代 ，年轻代，方法区的垃圾，Major GC的速度一般会比Minor GC的慢10倍以上。</p></li></ul><p>大量的对象被分配在 Eden 区，Eden 区满了之后会触发 MinorGC，可能会有 99% 以上的对象成为垃圾被回收掉，剩余存活的对象会被挪到 survivor1 区，下一次eden区满了后又会触发minor gc，把eden区和survivor1区垃圾对象回收，把剩余存活的对象一次性挪动到另外一块为空的survivor2区，因为新生代的对象都是朝生夕死的，存活时间很短，所以JVM默认的8:1:1的比例是很合适的，<strong>让eden区尽量的大，survivor区够用即可</strong>。</p><p>JVM默认有这个参数<code>-XX:+UseAdaptiveSizePolicy</code>(默认开启)，会导致这个8:1:1比例自动变化，如果不想这个比例有变化可以设置参数<code>-XX:-UseAdaptiveSizePolicy</code>。</p><p>示例如下：</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * -Xmx30m -Xms30m -XX:+PrintGCDetails </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GCTest</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="keyword">byte</span>[] allocation1 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">        <span class="keyword">byte</span>[] allocation2 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">        <span class="keyword">byte</span>[] allocation3 = <span class="keyword">new</span> <span class="keyword">byte</span>[_1MB];</span><br><span class="line">        <span class="keyword">byte</span>[] allocation4 = <span class="keyword">new</span> <span class="keyword">byte</span>[_1MB];</span><br><span class="line"><span class="comment">//        alloc();</span></span><br><span class="line"><span class="comment">//        byte[] allocation5 = new byte[_1MB];</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//    private static void alloc() {</span></span><br><span class="line"><span class="comment">//        byte[] allocation1 = new byte[2 * _1MB];</span></span><br><span class="line"><span class="comment">//        byte[] allocation2 = new byte[2 * _1MB];</span></span><br><span class="line"><span class="comment">//        byte[] allocation3 = new byte[_1MB];</span></span><br><span class="line"><span class="comment">//        byte[] allocation4 = new byte[_1MB];</span></span><br><span class="line"><span class="comment">//    }</span></span><br><span class="line">}</span><br><span class="line">--------------------------------------------------</span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 9216K, used 7816K [<span class="number">0x00000007bf600000</span>, <span class="number">0x00000007c0000000</span>, <span class="number">0x00000007c0000000</span>)</span><br><span class="line">  eden space 8192K, <span class="number">95</span>% used [<span class="number">0x00000007bf600000</span>,<span class="number">0x00000007bfda22d8</span>,<span class="number">0x00000007bfe00000</span>)</span><br><span class="line">  from space 1024K, <span class="number">0</span>% used [<span class="number">0x00000007bff00000</span>,<span class="number">0x00000007bff00000</span>,<span class="number">0x00000007c0000000</span>)</span><br><span class="line">  to   space 1024K, <span class="number">0</span>% used [<span class="number">0x00000007bfe00000</span>,<span class="number">0x00000007bfe00000</span>,<span class="number">0x00000007bff00000</span>)</span><br><span class="line"> ParOldGen       total 20480K, used 0K [<span class="number">0x00000007be200000</span>, <span class="number">0x00000007bf600000</span>, <span class="number">0x00000007bf600000</span>)</span><br><span class="line">  object space 20480K, <span class="number">0</span>% used [<span class="number">0x00000007be200000</span>,<span class="number">0x00000007be200000</span>,<span class="number">0x00000007bf600000</span>)</span><br><span class="line"> Metaspace       used 2973K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">space</span>    <span class="title">used</span> 328<span class="title">K</span>, <span class="title">capacity</span> 388<span class="title">K</span>, <span class="title">committed</span> 512<span class="title">K</span>, <span class="title">reserved</span> 10</span></span><br></pre></td></tr></tbody></table></figure><p>上述代码设置参数<code>-Xmx30m -Xms30m</code>根据虚拟机老年代和新生代默认比例为 2：1 可得知年轻代大小为 10MB，老年代为20MB。新生代中 Eden:s1:s1 = 8:1:1,其中 Eden 为 8MB，s1 为 1MB，另外s2 也为 1MB。在 allocation 1，2，3，4 申请内存时都在 eden 区进行分配。接下来再为 allocation5 申请内存，输出 GC 日志如下：</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">[GC (Allocation Failure) [PSYoungGen: 7652K-&gt;592K(9216K)] 7652K-&gt;6744K(29696K), <span class="number">0.0049781</span> secs] [Times: user=<span class="number">0.03</span> sys=<span class="number">0.01</span>, real=<span class="number">0.01</span> secs] </span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 9216K, used 1782K [<span class="number">0x00000007bf600000</span>, <span class="number">0x00000007c0000000</span>, <span class="number">0x00000007c0000000</span>)</span><br><span class="line">  eden space 8192K, <span class="number">14</span>% used [<span class="number">0x00000007bf600000</span>,<span class="number">0x00000007bf7297f0</span>,<span class="number">0x00000007bfe00000</span>)</span><br><span class="line">  from space 1024K, <span class="number">57</span>% used [<span class="number">0x00000007bfe00000</span>,<span class="number">0x00000007bfe94010</span>,<span class="number">0x00000007bff00000</span>)</span><br><span class="line">  to   space 1024K, <span class="number">0</span>% used [<span class="number">0x00000007bff00000</span>,<span class="number">0x00000007bff00000</span>,<span class="number">0x00000007c0000000</span>)</span><br><span class="line"> ParOldGen       total 20480K, used 6152K [<span class="number">0x00000007be200000</span>, <span class="number">0x00000007bf600000</span>, <span class="number">0x00000007bf600000</span>)</span><br><span class="line">  object space 20480K, <span class="number">30</span>% used [<span class="number">0x00000007be200000</span>,<span class="number">0x00000007be802040</span>,<span class="number">0x00000007bf600000</span>)</span><br><span class="line"> Metaspace       used 3024K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">space</span>    <span class="title">used</span> 329<span class="title">K</span>, <span class="title">capacity</span> 388<span class="title">K</span>, <span class="title">committed</span> 512<span class="title">K</span>, <span class="title">reserved</span> 1048576<span class="title">K</span></span></span><br></pre></td></tr></tbody></table></figure><p>此时 jvm 发生了一次 Minor GC，但是注意到老年代使用了 30% 的内存空间。因为给allocation5分配内存的时候eden区内存几乎已经被分配完了，当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC，GC期间虚拟机又发现allocation1，2，3，4无法存入Survior空间，所以只好把新生代的对象<strong>提前转移到老年代</strong>中去，老年代上的空间足够存放allocation1-4，所以不会出现Full GC。如果把 allocation1-4 的内存分配动作封装到 <code>alloc()</code> 方法中，再次运行程序：</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">[GC (Allocation Failure) [PSYoungGen: 7652K-&gt;592K(9216K)] 7652K-&gt;600K(29696K), <span class="number">0.0011807</span> secs] [Times: user=<span class="number">0.01</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 9216K, used 1782K [<span class="number">0x00000007bf600000</span>, <span class="number">0x00000007c0000000</span>, <span class="number">0x00000007c0000000</span>)</span><br><span class="line">  eden space 8192K, <span class="number">14</span>% used [<span class="number">0x00000007bf600000</span>,<span class="number">0x00000007bf729838</span>,<span class="number">0x00000007bfe00000</span>)</span><br><span class="line">  from space 1024K, <span class="number">57</span>% used [<span class="number">0x00000007bfe00000</span>,<span class="number">0x00000007bfe94010</span>,<span class="number">0x00000007bff00000</span>)</span><br><span class="line">  to   space 1024K, <span class="number">0</span>% used [<span class="number">0x00000007bff00000</span>,<span class="number">0x00000007bff00000</span>,<span class="number">0x00000007c0000000</span>)</span><br><span class="line"> ParOldGen       total 20480K, used 8K [<span class="number">0x00000007be200000</span>, <span class="number">0x00000007bf600000</span>, <span class="number">0x00000007bf600000</span>)</span><br><span class="line">  object space 20480K, <span class="number">0</span>% used [<span class="number">0x00000007be200000</span>,<span class="number">0x00000007be202000</span>,<span class="number">0x00000007bf600000</span>)</span><br><span class="line"> Metaspace       used 2973K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">space</span>    <span class="title">used</span> 328<span class="title">K</span>, <span class="title">capacity</span> 388<span class="title">K</span>, <span class="title">committed</span> 512<span class="title">K</span>, <span class="title">reserved</span> 1048576<span class="title">K</span></span></span><br></pre></td></tr></tbody></table></figure><p>可以发现之前的 allocation1-4 并没有进入老年代，已经被 GC 掉了。这也是为什么我们在写代码中尽量封装方法减少方法体大小的原因。</p><h3 id="大对象直接进入老年代">大对象直接进入老年代<a class="" href="#大对象直接进入老年代"></a></h3><p>大对象就是需要大量连续内存空间的对象（比如：字符串、数组）。JVM参数 <code>-XX:PretenureSizeThreshold</code> 可以设置大对象的大小，如果对象超过设置大小会直接进入老年代，不会进入年轻代，这个参数只在 <strong>Serial</strong> 和 <strong>ParNew</strong> 两个收集器下有效。</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * -Xmx30m -Xms30m -XX:+PrintGCDetails -XX:+UseConcMarkSweepGC -XX:PretenureSizeThreshold=3145728</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BigObj</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">3</span> * _1MB ];</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">---------------------------------------------------------</span><br><span class="line">Heap</span><br><span class="line"> par <span class="keyword">new</span> generation   total 9216K, used 1673K [<span class="number">0x00000007be200000</span>, <span class="number">0x00000007bec00000</span>, <span class="number">0x00000007bec00000</span>)</span><br><span class="line">  eden space 8192K,  <span class="number">20</span>% used [<span class="number">0x00000007be200000</span>, <span class="number">0x00000007be3a2458</span>, <span class="number">0x00000007bea00000</span>)</span><br><span class="line">  from space 1024K,   <span class="number">0</span>% used [<span class="number">0x00000007bea00000</span>, <span class="number">0x00000007bea00000</span>, <span class="number">0x00000007beb00000</span>)</span><br><span class="line">  to   space 1024K,   <span class="number">0</span>% used [<span class="number">0x00000007beb00000</span>, <span class="number">0x00000007beb00000</span>, <span class="number">0x00000007bec00000</span>)</span><br><span class="line"> concurrent mark-sweep generation total 20480K, used 3072K [<span class="number">0x00000007bec00000</span>, <span class="number">0x00000007c0000000</span>, <span class="number">0x00000007c0000000</span>)</span><br><span class="line"> Metaspace       used 2972K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">space</span>    <span class="title">used</span> 328<span class="title">K</span>, <span class="title">capacity</span> 388<span class="title">K</span>, <span class="title">committed</span> 512<span class="title">K</span>, <span class="title">reserved</span> 1048576<span class="title">K</span></span></span><br></pre></td></tr></tbody></table></figure><p><code>-XX:+UseConcMarkSweepGC</code>参数意味着在老年代使用 cms 垃圾收集器，此时 jvm 默认的年轻代垃圾收集器为<code>ParNew</code>收集器，可以省略<code>-XX:+UseParNewGC</code>参数。通过上述代码示例可以看出 byte[] b 直接进入了老年代，占用了 3072KB的空间，正好与我们 new 出来的 3M 大小相同。</p><p>大对象直接在老年代分配的目的是避免在 Eden区和两个 survivor 区进行大量的复制。</p><h3 id="长期存活的对象进入老年代">长期存活的对象进入老年代<a class="" href="#长期存活的对象进入老年代"></a></h3><p>虚拟机采用了分代收集的思想来管理内存，那么内存回收时就必须能识别哪些对象应该放在新生代，哪些对象应该放在老年代中。为了做到这一点，虚拟机给每个对象一个对象年龄（Age）计数器。如果在 Eden 出生并经过第一次 Minor GC 后仍然能够存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间中，并将对象年龄设为 1。对象在 Survivor 中没熬过一次 Minor GC, 年龄就增加一岁，当它的年龄增加到一定程度（默认 15 岁，CMS 收集器默认为 6 岁，不同的垃圾收集器会稍微有些不同），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过<code>-XX:MaxTenuringThreshold</code>来设置。</p><h3 id="动态对象年龄判断">动态对象年龄判断<a class="" href="#动态对象年龄判断"></a></h3><p>当前放对象的Survivor区域里(其中一块区域，放对象的那块s区)，一批对象的总大小大于这块Survivor区域内存大小的50%(-XX:TargetSurvivorRatio可以指定)，那么此时<strong>大于等于</strong>这批对象年龄最大值的对象，就可以直接进入老年代了，例如Survivor区域里现在有一批对象，年龄1+年龄2+年龄n的多个年龄对象总和超过了Survivor区域的50%，此时就会把年龄n(含)以上的对象都放入老年代。这个规则其实是希望那些可能是长期存活的对象，尽早进入老年代。<strong>对象动态年龄判断机制一般是在minor gc之后触发的</strong>。</p><h3 id="老年代空间分配担保机制">老年代空间分配担保机制<a class="" href="#老年代空间分配担保机制"></a></h3><p>在每次 Minor GC 之前，虚拟机会检查老年代最大连续可用空间是否大于新生代所有对象（包括垃圾对象）总空间，如果大于则说明此次 Minor GC 是安全的。如果不大于，虚拟机会检查 HandlePromotionFailure 设置的值是否允许担保失败，如果不允许，则进行一次 Full GC，如果允许，则检查老年代最大可用连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，尝试进行一次 Minor GC，如果小于改为进行一次 Full GC。</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/images/2020/09/09/image-20200909170646617.png" alt="空间分配担保机制"></p><h3 id="内存分配流程">内存分配流程<a class="" href="#内存分配流程"></a></h3><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/images/2020/09/09/image-20200909180425796.png" alt="内存分配流程"></p><h2 id="对象的内存回收">对象的内存回收<a class="" href="#对象的内存回收"></a></h2><p>对象创建使用完成之后，需要被垃圾收集进行回收以释放内存空间。在回收之前，第一件事就是要确定这些对象中哪些还“存活着”，哪些已经“死去”。</p><h3 id="引用计数算法">引用计数算法<a class="" href="#引用计数算法"></a></h3><p>给对象添加一个引用计数器，每当一个地方引用它时，计数器的值就加 1；当引用失效时，计数器的值就减1；任何时刻计数器为 0 的对象就是不可能在被使用的。</p><p>**引用计数算法（Reference Counting）的实现简单，判定效率也很高，但是目前主流虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之前相互循环引用的问题。**所谓对象之间的相互引用问题，如下面代码所示：除了对象a 和 b 相互引用着对方之外，这两个对象之间再无任何引用。但是他们因为互相引用对方，导致它们的引用计数器都不为0，于是引用计数算法无法通知 GC 回收器回收他们。</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceCounting</span> </span>{</span><br><span class="line">    Object instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        ReferenceCounting a = <span class="keyword">new</span> ReferenceCounting();</span><br><span class="line">        ReferenceCounting b = <span class="keyword">new</span> ReferenceCounting();</span><br><span class="line">        a.instance = b;</span><br><span class="line">        b.instance = a;</span><br><span class="line">        a = <span class="keyword">null</span>;</span><br><span class="line">        b = <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="可达性分析算法">可达性分析算法<a class="" href="#可达性分析算法"></a></h3><p>可达性分析(Reachability Analysis)的基本思路就是通过一系列的成为<code>GC Roots</code>的对象为起点，从这些节点开始向下搜索，搜索所走过的路径称为<code>引用链</code>(Refernce Chain)，当一个独享到 GC Roots 没有任何引用链相连（用图论的话来说，就是从 GC Roots到这个对象不可达）时，则证明此对象是不可用的。</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/images/post/2020/09/image-20200909202306970.png" alt="可达性分析"></p><p>在 Java 中，可作为 GC Roots的对象包括下面几种：</p><ul><li>虚拟机栈（栈中变量表）中的引用对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中 JNI(Native)方法引用的对象。</li></ul><h3 id="对象引用类型">对象引用类型<a class="" href="#对象引用类型"></a></h3><p>java的引用类型一般分为四种：<strong>强引用</strong>、<strong>软引用</strong>、弱引用、虚引用</p><h4 id="强引用">强引用<a class="" href="#强引用"></a></h4><p>普通的变量引用，类似<code>Object obj = new Object()</code>这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。</p><h4 id="软引用">软引用<a class="" href="#软引用"></a></h4><p>用来描述一些还有用但并非必需的对象。该类对象正确情况下不会被回收，但是 GC 做完后发现释放不出空间存放新的对象，则会把这些对象回收掉。<strong>软引用可用来实现内存敏感的高速缓存</strong>。在JDK 1.2之后，提供了<code>SoftReference</code>类来实现弱引用。</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> SoftReference&lt;User&gt; user = <span class="keyword">new</span> SoftReference&lt;User&gt;(<span class="keyword">new</span> User());</span><br></pre></td></tr></tbody></table></figure><h4 id="弱引用">弱引用<a class="" href="#弱引用"></a></h4><p>弱引用也是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在JDK 1.2之后，提供了<code>WeakReference</code>类来实现弱引用。</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> WeakReference&lt;User&gt; user = <span class="keyword">new</span> WeakReference&lt;User&gt;(<span class="keyword">new</span> User());</span><br></pre></td></tr></tbody></table></figure><h4 id="虚引用">虚引用<a class="" href="#虚引用"></a></h4><p>虚引用也称为幽灵引用或者幻影引用，它是最弱的一种引用关系，几乎不用</p><h3 id="finalize-方法">finalize 方法<a class="" href="#finalize-方法"></a></h3><p>即使在可达性分析算法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经历再次标记过程。</p><p><strong>标记的前提是对象在进行可达性分析后发现没有与GC Roots相连接的引用链。</strong></p><ol><li><p><strong>第一次标记并进行一次筛选。</strong></p><p>筛选的条件是此对象是否有必要执行finalize()方法。 当对象没有覆盖finalize方法，对象将直接被回收。</p></li><li><p><strong>第二次标记</strong></p><p>如果这个对象覆盖了finalize方法，finalize方法是对象脱逃死亡命运的最后一次机会，如果对象要在finalize()中成功拯救自己，只要重新与引用链上的任何的一个对象建立关联即可，譬如把自己赋值给某个类变量或对象的成员变量，那在第二次标记时它将移除出“即将回收”的集合。如果对象这时候还没逃脱，那基本上它就真的被回收了。</p></li></ol><blockquote><p>注意：一个对象的finalize()方法只会被执行一次，也就是说通过调用finalize方法自我救命的机会就一次。</p><p><strong>如何判断一个类是无用的类</strong></p><p>方法区主要回收的是无用的类，那么如何判断一个类是无用的类的呢？</p><p>类需要同时满足下面3个条件才能算是 <strong>“无用的类”</strong> ：</p><ul><li><p>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。</p></li><li><p>加载该类的 ClassLoader 已经被回收。</p></li><li><p>该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</p></li></ul></blockquote><h2 id="参考文章：">参考文章：<a class="" href="#参考文章："></a></h2><p><a href="https://juejin.im/post/6844904054561193992">Java的对象模型——Oop-Klass模型（一）</a></p><p><a href="https://juejin.im/post/6844904055421009928">Java的对象模型——Oop-Klass模型（二）</a></p><p><a href="https://www.zhihu.com/question/50258991/answer/120450561">JVM符号引用转换直接引用的过程?</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从源码角度理解类加载器</title>
      <link href="/post/164885504/"/>
      <url>/post/164885504/</url>
      
        <content type="html"><![CDATA[<p>虚拟机类加载机制就是把 Class 文件加载到内存，并对数据进行校验、解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型。一个类有虚拟机加载到内存中的流程包含了多个阶段，其中实现加载阶段中的通过一个类的全限定名来获取描述此类的二进制字节流的动作便是有类加载器来完成的。</p><p>一般来说、类的加载流程都有虚拟自主完成，开发人员不必关系其实现细节。但是如过如果遇到了需要与类加载器进行交互的情况，而对类加载器的机制又不是很了解的话，就很容易花大量的时间去调试 <code>ClassNotFoundException</code> 和 <code>NoClassDefFoundError</code> 等异常。同时随着类加载器在类层次划分、OSGi、热部署、代码加密等领域大放异彩，对于开发人员还是很有必要去掌握其中的原理的。</p><h2 id="类加载运行的基本流程">类加载运行的基本流程<a class="" href="#类加载运行的基本流程"></a></h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> jianyuan.chen</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/8/20 15:51</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        System.out.println(<span class="string">"Hello world"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>对于一个 Java 程序的运行过程从整体上说可以分为两个步骤：</p><ol><li>使用javac 命令将<code>HelloWorld.java</code>源文件编译成<code>HelloWorld.class</code>文件。</li><li>java 命令运行<code>HelloWorld.class</code>文件。</li></ol><p>在运行 <code>java</code> 命令时，具体发生了什么，可以通过下图总结一下：</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/images/2020/08/20/image-20200820173314832.png" alt="类加载流程"></p><h2 id="类加载器分类与结构">类加载器分类与结构<a class="" href="#类加载器分类与结构"></a></h2><p>从上图能看出 Java 程序的入口为<code>sun.misc.Launcher</code>类，查看一下<code>Launcher</code>类的方法</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Launcher</span> </span>{</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Launcher launcher = <span class="keyword">new</span> Launcher();</span><br><span class="line"><span class="keyword">private</span> ClassLoader loader;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Launcher <span class="title">getLauncher</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> launcher;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Launcher</span><span class="params">()</span> </span>{</span><br><span class="line">        Launcher.ExtClassLoader var1;</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            var1 = Launcher.ExtClassLoader.getExtClassLoader();</span><br><span class="line">        } <span class="keyword">catch</span> (IOException var10) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(<span class="string">"Could not create extension class loader"</span>, var10);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">this</span>.loader = Launcher.AppClassLoader.getAppClassLoader(var1);</span><br><span class="line">        } <span class="keyword">catch</span> (IOException var9) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(<span class="string">"Could not create application class loader"</span>, var9);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        Thread.currentThread().setContextClassLoader(<span class="keyword">this</span>.loader);</span><br><span class="line">        ....</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ClassLoader <span class="title">getClassLoader</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.loader;</span><br><span class="line">    }</span><br><span class="line">  ...</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtClassLoader</span> <span class="keyword">extends</span> <span class="title">URLClassLoader</span> </span>{</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Launcher.ExtClassLoader instance;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> Launcher.<span class="function">ExtClassLoader <span class="title">getExtClassLoader</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>{</span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="keyword">null</span>) {</span><br><span class="line">                Class var0 = Launcher.ExtClassLoader.class;</span><br><span class="line">                <span class="keyword">synchronized</span>(Launcher.ExtClassLoader.class) {</span><br><span class="line">                    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) {</span><br><span class="line">                        instance = createExtClassLoader();</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        }</span><br><span class="line">      ...</span><br><span class="line">}        </span><br><span class="line">...</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AppClassLoader</span> <span class="keyword">extends</span> <span class="title">URLClassLoader</span> </span>{</span><br><span class="line">        <span class="keyword">final</span> URLClassPath ucp = SharedSecrets.getJavaNetAccess().getURLClassPath(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ClassLoader <span class="title">getAppClassLoader</span><span class="params">(<span class="keyword">final</span> ClassLoader var0)</span> <span class="keyword">throws</span> IOException </span>{</span><br><span class="line">            <span class="keyword">final</span> String var1 = System.getProperty(<span class="string">"java.class.path"</span>);</span><br><span class="line">            <span class="keyword">final</span> File[] var2 = var1 == <span class="keyword">null</span> ? <span class="keyword">new</span> File[<span class="number">0</span>] : Launcher.getClassPath(var1);</span><br><span class="line">            <span class="keyword">return</span> (ClassLoader)AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Launcher.AppClassLoader&gt;() {</span><br><span class="line">                <span class="keyword">public</span> Launcher.<span class="function">AppClassLoader <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">                    URL[] var1x = var1 == <span class="keyword">null</span> ? <span class="keyword">new</span> URL[<span class="number">0</span>] : Launcher.pathToURLs(var2);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> Launcher.AppClassLoader(var1x, var0);</span><br><span class="line">                }</span><br><span class="line">            });</span><br><span class="line">        }</span><br><span class="line">      ...</span><br><span class="line">} </span><br><span class="line">  ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>从 Launcher 入口可以看出在类加载过程中使用到<code>ExtClassLoader</code> 和 <code>AppClassLoader</code>两个系统类加载器，加上启动 Launcher 类使用的<code>BootStrapClassLoader</code>一共有三个系统类加载器。</p><blockquote><p>思维扩展：</p><p>Launcher.getLauncher()使用了饿汉单例模式创建。</p><p>ExtClassLoader.getExtClassLoader() 使用了懒汉双重校验单例模式。</p></blockquote><h3 id="BootStrapClassLoader">BootStrapClassLoader<a class="" href="#BootStrapClassLoader"></a></h3><p>引导类加载器，通过 C++ 代码实现，不属于 Java 程序，负责加载支撑 JVM 运行的位于 <code>JAVA_HOME/lib</code>目录中或者被<code>-Xbootclasspath</code>参数所指定的路径中的类库，比如：rt.jar、charset.jar 等。引导类加载器的加载路径可以通过<code>System.getProperty("sun.boot.class.path");</code>。</p><h3 id="ExtClassLoader">ExtClassLoader<a class="" href="#ExtClassLoader"></a></h3><p>扩展类加载器负责加载 <code>JAVA_HOME/ext</code>目录中或者被<code>java.ext.dir</code>系统变脸所指定的路径中的所有类库，扩展类加载器可以被直接使用。扩展类加载器的加载路径可以通过<code>System.getProperty("java.ext.dirs");</code>获取。</p><h3 id="AppClassLoader">AppClassLoader<a class="" href="#AppClassLoader"></a></h3><p>应用程序类加载器，由于这个类加载器是 ClassLoader 中的 getSystemClassLoader() 方法的返回值。所以一般也称它为系统类加载器。它负责加载用户类路径(ClassPath)上指定的类库，这个类加载器也是可以被开发者直接使用的，如果应用程序中没有定义过自己的类加载器一般情况下这个就是程序中的默认类加载器。应用程序类加载器的加载路径可以通过<code>System.getProperty("java.class.path")</code>获取。</p><p>ExtClassLoad 和 AppClassLoader 都属于 Launcher 的静态内部类，同时也都是 ClassLoader 的子类。Launcher 在实例化的过程中，创建了 ExtClassLoader 和 AppClassLoader。<code>getClassLoader()</code>返回的是一个 AppClassLoader 的实例。通过Idea查看整个 ClassLoader 的体系结构如下，虚拟机启动只使用了 ExtClassLoader 和 AppClassLoader。</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/images/2020/08/20/AppClassLoader.png" alt="AppClassLoader"></p><p>通过上文所述，运行一下代码：</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderPathTest</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        Arrays.stream(System.getProperty(<span class="string">"sun.boot.class.path"</span>).split(<span class="string">":"</span>)).forEach(System.out::println);</span><br><span class="line">        System.out.println(<span class="string">"------------------"</span>);</span><br><span class="line">        Arrays.stream(System.getProperty(<span class="string">"java.ext.dirs"</span>).split(<span class="string">":"</span>)).forEach(System.out::println);</span><br><span class="line">        System.out.println(<span class="string">"------------------"</span>);</span><br><span class="line">        Arrays.stream(System.getProperty(<span class="string">"java.class.path"</span>).split(<span class="string">":"</span>)).forEach(System.out::println);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_231</span>.jdk/Contents/Home/jre/lib/resources.jar</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_231</span>.jdk/Contents/Home/jre/lib/rt.jar</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_231</span>.jdk/Contents/Home/jre/lib/sunrsasign.jar</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_231</span>.jdk/Contents/Home/jre/lib/jsse.jar</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_231</span>.jdk/Contents/Home/jre/lib/jce.jar</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_231</span>.jdk/Contents/Home/jre/lib/charsets.jar</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_231</span>.jdk/Contents/Home/jre/lib/jfr.jar</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_231</span>.jdk/Contents/Home/jre/classes</span><br><span class="line">------------------</span><br><span class="line">/Users/chenjianyuan/Library/Java/Extensions</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_231</span>.jdk/Contents/Home/jre/lib/ext</span><br><span class="line">/Library/Java/Extensions</span><br><span class="line">/Network/Library/Java/Extensions</span><br><span class="line">/System/Library/Java/Extensions</span><br><span class="line">/usr/lib/java</span><br><span class="line">------------------</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_231</span>.jdk/Contents/Home/jre/lib/charsets.jar</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_231</span>.jdk/Contents/Home/jre/lib/deploy.jar</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_231</span>.jdk/Contents/Home/jre/lib/ext/cldrdata.jar</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_231</span>.jdk/Contents/Home/jre/lib/ext/dnsns.jar</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_231</span>.jdk/Contents/Home/jre/lib/ext/jaccess.jar</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_231</span>.jdk/Contents/Home/jre/lib/ext/jfxrt.jar</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_231</span>.jdk/Contents/Home/jre/lib/ext/localedata.jar</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_231</span>.jdk/Contents/Home/jre/lib/ext/nashorn.jar</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_231</span>.jdk/Contents/Home/jre/lib/ext/sunec.jar</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_231</span>.jdk/Contents/Home/jre/lib/ext/sunjce_provider.jar</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_231</span>.jdk/Contents/Home/jre/lib/ext/sunpkcs11.jar</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_231</span>.jdk/Contents/Home/jre/lib/ext/zipfs.jar</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_231</span>.jdk/Contents/Home/jre/lib/javaws.jar</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_231</span>.jdk/Contents/Home/jre/lib/jce.jar</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_231</span>.jdk/Contents/Home/jre/lib/jfr.jar</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_231</span>.jdk/Contents/Home/jre/lib/jfxswt.jar</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_231</span>.jdk/Contents/Home/jre/lib/jsse.jar</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_231</span>.jdk/Contents/Home/jre/lib/management-agent.jar</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_231</span>.jdk/Contents/Home/jre/lib/plugin.jar</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_231</span>.jdk/Contents/Home/jre/lib/resources.jar</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_231</span>.jdk/Contents/Home/jre/lib/rt.jar</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_231</span>.jdk/Contents/Home/lib/ant-javafx.jar</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_231</span>.jdk/Contents/Home/lib/dt.jar</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_231</span>.jdk/Contents/Home/lib/javafx-mx.jar</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_231</span>.jdk/Contents/Home/lib/jconsole.jar</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_231</span>.jdk/Contents/Home/lib/packager.jar</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_231</span>.jdk/Contents/Home/lib/sa-jdi.jar</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_231</span>.jdk/Contents/Home/lib/tools.jar</span><br><span class="line">/Users/chenjianyuan/IdeaProjects/course/target/classes</span><br><span class="line">/Applications/IntelliJ IDEA.app/Contents/lib/idea_rt.jar</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>观察上面输出内容发现一些本应该在 BootstrapClassLoader 和 ExtClassLoader 类加载器中加载的 jar 包也存在了 AppClassLoader 类加载器加载的路径下。这会不会造成类的重复加载呢，答案是不会的，这就涉及到了类加载器的双亲委派加载模型。</p><h3 id="JVM类加载机制">JVM类加载机制<a class="" href="#JVM类加载机制"></a></h3><ul><li><p><strong>全盘负责</strong>：当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入</p></li><li><p><strong>父类委托</strong>：先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类</p></li><li><p><strong>缓存机制</strong>：缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。这就是为什么修改了Class后，必须重启JVM，程序的修改才会生效</p></li></ul><h2 id="双亲委派模型（Parents-Delegation-Model）">双亲委派模型（Parents Delegation Model）<a class="" href="#双亲委派模型（Parents-Delegation-Model）"></a></h2><h3 id="何为双亲委派">何为双亲委派<a class="" href="#何为双亲委派"></a></h3><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/images/post/2020/08/image-20200820221249345.png" alt="双亲委派模型"></p><p>上图所示类加载器之间的层次关系就成为类加载器的双亲委派模型。</p><h3 id="类加载器之间结构和关系">类加载器之间结构和关系<a class="" href="#类加载器之间结构和关系"></a></h3><p>在深入理解双亲委派模型之前先运行一段代码：</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderTest</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();</span><br><span class="line">        System.out.println(<span class="string">"system classLoader is "</span> + systemClassLoader);</span><br><span class="line">        ClassLoader systemClassLoaderParent = systemClassLoader.getParent();</span><br><span class="line">        System.out.println(<span class="string">"system classLoader parent is "</span> + systemClassLoaderParent);</span><br><span class="line">        ClassLoader systemClassLoaderParentParent = systemClassLoaderParent.getParent();</span><br><span class="line">        System.out.println(<span class="string">"system classLoader parent's parent is "</span> + systemClassLoaderParentParent);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">==============</span><br><span class="line">system classLoader is sun.misc.Launcher$AppClassLoader@18b4aac2</span><br><span class="line">system classLoader parent is sun.misc.Launcher$ExtClassLoader@61bbe9ba</span><br><span class="line">system classLoader parent<span class="string">'s parent is null</span></span><br></pre></td></tr></tbody></table></figure><p>从上面的代码可以看出类加载之间的关系，AppClassLoader 为系统类加载器，上层加载器为 ExtClassLoader, ExtClassLoader 上层类加载器为 null 即为 BootstrapClassLoader，此处也说明如果我们想让自定义加载的上层类加载器为 BootstrapClassLoader 类加载器的话，可以直接将其 parent 属性置为 <code>null</code>。</p><p>值得注意的是此处的 parent 不能理解为父类加载器，类加载器之间的关系不是通过继承来实现的，而都是使用组合关系来复用上层类加载器的代码。可以通过 AppClassLoader、ExtClassLoader 的 UML 类图查看一下之间的关系。</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/images/post/2020/08/AppClassLoader.png" alt="ClassLoader"></p><p>AppClassLoader 和 ExtClassLoader 都继承了 URLClassLoader 最终继承了 ClassLoader 同时又依赖 ClassLoader即 AppClassLoader 依赖 ExtClassLoader。</p><h3 id="双亲委派模型工作过程">双亲委派模型工作过程<a class="" href="#双亲委派模型工作过程"></a></h3><p>自定义类加载器在收到一个类加载请求是，它不会自己首先去加载这个类，而是委托给上层类加载器也就是应用程序类加载器去加载，同样在应用程序类加载器收到类加载的请求时也不会去首先加载这个类，而是委托上层即 ExtClassLoader 类加载器去加载，这样一直到委托到顶层 BootstrapClassLoader，在 BootstrapClassLoader 接收到类加载请求后，会在自己的搜索范围内搜索这个类，如果搜索不到则返回至下层类加载器，让下层类加载器去自己的搜索范围内去搜索此类，直至最底层类加载器。如果所有的加载器都没有搜索到此类则会抛出 <code>ClassNotFoundException</code>。</p><h3 id="双亲委派模型源码解析">双亲委派模型源码解析<a class="" href="#双亲委派模型源码解析"></a></h3><p>在了解双亲委派模型运行机制之前要先熟悉 ClassLoader 类加载器的结构，其核心代码如下面所示：</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoader</span> </span>{</span><br><span class="line">  <span class="comment">// 上层类加载器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ClassLoader parent;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ClassLoader</span><span class="params">(Void unused, ClassLoader parent)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.parent = parent;</span><br><span class="line">        ...</span><br><span class="line">    }</span><br><span class="line">  <span class="comment">// 构造方法 初始化上层类加载器</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">ClassLoader</span><span class="params">(ClassLoader parent)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>(checkCreateClassLoader(), parent);</span><br><span class="line">    }</span><br><span class="line">  <span class="comment">// 默认上层类加载器为系统类加载器</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="title">ClassLoader</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>(checkCreateClassLoader(), getSystemClassLoader());</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 加载类方法 核心</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">        <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">synchronized</span> (getClassLoadingLock(name)) {</span><br><span class="line">            <span class="comment">// step1. 首先检查类是否已经被加载过</span></span><br><span class="line">            Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) {</span><br><span class="line">                <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    <span class="comment">// 被加载类如未被加载过，并且其上层类加载器不为空，委托上层类加载器进行加载。</span></span><br><span class="line">                    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) {</span><br><span class="line">                        c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                    } <span class="keyword">else</span> {</span><br><span class="line">                      <span class="comment">// 被加载类没有被加载过，并且此加载此类的类加载器没有上层类加载器，由 BootstapClassLoader 进行加载</span></span><br><span class="line">                        c = findBootstrapClassOrNull(name);</span><br><span class="line">                    }</span><br><span class="line">                } <span class="keyword">catch</span> (ClassNotFoundException e) { <span class="comment">// 此处的 ClassNotFoundException 为下面 findClass() 方法抛出，此处 catch 的为上层类加载器抛出的异常</span></span><br><span class="line">                    <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                    <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">                }</span><br><span class="line">  <span class="comment">// 从最底层类加载器一直委托到 BootStrapClassLoader 如果 BootStrapClassLoader 类加载器没有加载此类为空，</span></span><br><span class="line">                <span class="comment">// 由 BootStrapClassLoader 类加载器下层寻找，找不到此类抛出 ClassNotFoundException 并由 </span></span><br><span class="line">                <span class="comment">// BootStrapClassLoader 下层的下层捕获异常，一直到最底层找不到则程序抛出 ClassNotFoundException</span></span><br><span class="line">                <span class="keyword">if</span> (c == <span class="keyword">null</span>) {</span><br><span class="line">                    <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                    <span class="comment">// to find the class.</span></span><br><span class="line">                    <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                    <span class="comment">// 根据类的全限定名在当前类加载器搜索范围内查询需要被加载的类，如果找不到则</span></span><br><span class="line">         <span class="comment">// 抛出 ClassNotFoundException</span></span><br><span class="line">                    c = findClass(name);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                    sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (resolve) {</span><br><span class="line">                resolveClass(c);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</span><br><span class="line">    }</span><br><span class="line">  </span><br><span class="line">   <span class="keyword">protected</span> <span class="keyword">final</span> Class&lt;?&gt; findLoadedClass(String name) {</span><br><span class="line">        <span class="keyword">if</span> (!checkName(name))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> findLoadedClass0(name);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">final</span> Class&lt;?&gt; findLoadedClass0(String name);</span><br><span class="line">  </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>ClassLoader 类加载器整体结构如上所示，其加载类的核心方法为 loadClass 和 findClass，findClass 由其子类 URLClassLoader 重载实现。并由 URLClassLoader 子类 AppClassLoader 和 ExtClassLoader 继承获得实现。</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/images/post/2020/08/Launcher.png" alt="Launcher"></p><p>结合源码对 <code>Hello World</code> 程序运行进行分析：</p><ol><li><p>BootStrapClassLoader 在启动加载Launcher,并通过 getLauncher 获取 Launcher ①</p></li><li><p>Launcher 在 new 时会调用 ExtClassLoader.getExtClassLoader（②）创建 ExtClassLoader（③），查看 ExtClassLoader 创建方法</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ExtClassLoader</span><span class="params">(File[] var1)</span> <span class="keyword">throws</span> IOException </span>{</span><br><span class="line">        <span class="keyword">super</span>(getExtURLs(var1), (ClassLoader)<span class="keyword">null</span>, Launcher.factory);</span><br><span class="line">        SharedSecrets.getJavaNetAccess().getURLClassPath(<span class="keyword">this</span>).initLookupCache(<span class="keyword">this</span>);</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><p>可以看出 ExtClassLoader 初始化其 parent 属性为 null，根据 ClassLoader的 loadClass 方法即可知 ExtClassLoadClass 类加载器会委托 BootstrapClassLoader 类加载器进行类加载。在 ExtClassLoader 类加载器创建创完成后，会创建 AppClassLoader, 并且把已经创建的 ExtClassLoader 类加载赋值给 AppClassLoader 类加载器的 parent 属性（④）。最后由 AppClassLoader 创建实例并返回（⑤）赋值给 Luancher 类的 loader 属性(④)。</p></li><li><p>由 loader(AppClassLoader) 调用 loaderClass 方法加载<code>tech.stack.HelloWorld</code>。</p><ol><li>从 LoadedClass 缓存中查询 <code>tech.stack.HelloWorld</code> 类，此处为 Native 方法由虚拟机底层实现。</li><li>此处为<code>tech.stack.HelloWorld</code>首次加载，并不会在 loadedClass 缓存中查到 Class<helloworld> 对象</helloworld></li><li>判断 AppClassLoader 的 parent 是否为空，此处AppClassLoader.parent 为 extClassLoader加载器。</li><li>委托由 extClassLoader 类加载器加载 <code>tech.stack.HelloWorld</code> 类。</li><li>extClassLoader 同样进行 3.1、3.2步骤。</li><li>判断 extClassLoader 的 parent 对象是否为空，由 2 步骤可知 extClassLoader.parent 为 null。</li><li>委托由 BootstrapClassLoader 尝试加载<code>tech.stack.HelloWorld</code>，由于 BootstrapClassLoader 扫面范围内不存在<code>tech.stack.HelloWorld</code>类，因此返回 null。</li><li>Class<helloworld>对象为 null，则由 extClassLoader 通过在 URLClassLoader 类加载器继承到的 findClass 方法在 extClassLoader 搜索范围内查询<code>tech.stack.HelloWorld</code>类。</helloworld></li><li>在 extClassLoader 搜索范围内找不到<code>tech.stack.HelloWorld</code>类，抛出 <code>ClassNotFoundException</code>。</li><li><code>ClasseException</code>由 appClassLoader 捕获处理，然后在 AppClassLoader 搜索范围内查询<code>tech.stack.HelloWorld</code>类。</li><li>在 appClassLoader 搜索范围内可以找到<code>tech.stack.HelloWorld</code>类，将 Class<helloworld>对象返回，并判断是否需要解析。</helloworld></li><li>返回 Class<helloworld>对象。</helloworld></li></ol></li></ol><p>以上就是<code>tech.stack.HelloWorld</code> 通过双亲委派模型加载的整个流程。</p><blockquote><p>思维扩展：</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (getClassLoadingLock(name)){</span><br><span class="line">  ...</span><br><span class="line">} </span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getClassLoadingLock</span><span class="params">(String className)</span> </span>{</span><br><span class="line">        Object lock = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">if</span> (parallelLockMap != <span class="keyword">null</span>) {</span><br><span class="line">            Object newLock = <span class="keyword">new</span> Object();</span><br><span class="line">            lock = parallelLockMap.putIfAbsent(className, newLock);</span><br><span class="line">            <span class="keyword">if</span> (lock == <span class="keyword">null</span>) {</span><br><span class="line">                lock = newLock;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> lock;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>synchronized 保证了类加载器在加载类的过程中是线程安全的。保证了类加载过程中初始化阶段只会发生一次。同时在也是单例模式内部静态类这种写法能保证线程安全的基础。</p></blockquote><p>实现双亲委派的代码都集中在 loadClass() 方法之中，总结来说 loadClass 的逻辑就是：先检查类是否已经被加载过，若没有加载则调用上层加载器的 loadClass() 方法，若上层类加载器为空则默认使用启动类加载器。如果上层类加载器加载失败，抛出 ClassNotFoundException异常后，在调用自己的 findClass() 方法进行加载。</p><h3 id="为什么设计双亲委派机制">为什么设计双亲委派机制<a class="" href="#为什么设计双亲委派机制"></a></h3><ul><li>沙箱安全机制：可以防止核心 API 库被随意篡改。例如自己写的 java.lang.String.class 类就不会被加载。</li><li>避免类的重复加载：当上层类加载器已经加载了该类时，就没有必要在由下层类加载器加载一遍，保证了类的唯一性。</li></ul><p>在程序中编写如下代码：</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        System.out.println(<span class="string">"custom String Class"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">======</span><br><span class="line">错误: 在类 java.lang.String 中找不到 main 方法, 请将 main 方法定义为:</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">否则 JavaFX 应用程序类必须扩展javafx.application.Application</span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></tbody></table></figure><p>在项目中新建模块<code>loader-test</code> 并且创建<code>tech.stack.HelloWorld</code>之后将模块打包放入<code>JAVA_HOME/ext</code>目录下面，运行下面代码：</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        System.out.println(HelloWorld.class.getClassLoader());</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>上面代码输出<code>sun.misc.Launcher$ExtClassLoader@266474c2</code>说明 HelloWorld类是有 ExtClassLoader 类加载器进行加载的而不是有 AppClassLoader 进行加载。如果继续放到<code>JAVA_HOME/lib</code>目录下面，再次运行上面的代码，得到输出：<code>sun.misc.Launcher$ExtClassLoader@5e481248</code>，结果并没有改变，这其实和前面讲的双亲委派机制并不矛盾。虚拟机出于安全等因素考虑，不会加载&lt;JAVA_HOME&gt;/lib目录下存在的陌生类。换句话说，虚拟机只加载&lt;JAVA_HOME&gt;/lib目录下它可以识别的类。因此，开发者通过将要加载的非JDK自身的类放置到此目录下期待启动类加载器加载是不可能的。但是如果在运行时添加jvm 参数<code>-Xbootclasspath/a:/Users/chenjianyuan/IdeaProjects/course/loader-test/target/loader-test.jar</code> 输出的结果则为 <code>null</code> ，就变成了 BootstrapClassLoader 类加载器加载。</p><h2 id="Java-程序动态扩展方式">Java 程序动态扩展方式<a class="" href="#Java-程序动态扩展方式"></a></h2><p>类加载方式有三种：</p><ul><li>命令行启动应用时候由JVM初始化加载</li><li>通过Class.forName()方法动态加载</li><li>通过ClassLoader.loadClass()方法动态加载</li></ul><p>Java的连接模型允许用户运行时扩展引用程序，既可以通过当前虚拟机中预定义的加载器加载编译时已知的类或者接口，又允许用户自行定义类装载器，在运行时动态扩展用户的程序。通过用户自定义的类装载器，你的程序可以加载在编译时并不知道或者尚未存在的类或者接口，并动态连接它们并进行有选择的解析。运行时动态扩展java应用程序有如下两个途径：</p><h4 id="反射-调用java-lang-Class-forName-…-加载类">反射 (调用java.lang.Class.forName(…)加载类)<a class="" href="#反射-调用java-lang-Class-forName-…-加载类"></a></h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; forName(String className)</span><br><span class="line">               <span class="keyword">throws</span> ClassNotFoundException {</span><br><span class="line">       Class&lt;?&gt; caller = Reflection.getCallerClass();</span><br><span class="line">       <span class="keyword">return</span> forName0(className, <span class="keyword">true</span>, ClassLoader.getClassLoader(caller), caller);</span><br><span class="line">   }</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; forName(String name, <span class="keyword">boolean</span> initialize,</span><br><span class="line">                                  ClassLoader loader)</span><br><span class="line">       <span class="keyword">throws</span> ClassNotFoundException{</span><br><span class="line">       </span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure><p>这里的initialize参数是很重要的，它表示在加载同时是否完成初始化的工作（说明：单参数版本的forName方法默认是完成初始化的）。有些场景下需要将initialize设置为true来强制加载同时完成初始化，我们在程序中自己调用方法时一般都会直接初始化，典型的就是加载数据库驱动问题。因为JDBC驱动程序只有被注册后才能被应用程序使用，这就要求驱动程序类必须被初始化，而不单单被加载。</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 加载并实例化JDBC驱动类</span></span><br><span class="line">Class.forName(driver);</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// JDBC驱动类的实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Driver</span> <span class="keyword">extends</span> <span class="title">NonRegisteringDriver</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">sql</span>.<span class="title">Driver</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Driver</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>{</span><br><span class="line">    }</span><br><span class="line"><span class="comment">// 将initialize设置为true来强制加载同时完成初始化，实现驱动注册</span></span><br><span class="line">    <span class="keyword">static</span> {</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            DriverManager.registerDriver(<span class="keyword">new</span> Driver());</span><br><span class="line">        } <span class="keyword">catch</span> (SQLException var1) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Can\'t register driver!"</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="用户自定义类加载器">用户自定义类加载器<a class="" href="#用户自定义类加载器"></a></h4><p>通过前面的分析，我们可以看出，除了和本地实现密切相关的启动类加载器之外，包括扩展类加载器和系统类加载器在内的所有其他类加载器我们都可以当做自定义类加载器来对待，唯一区别是是否被虚拟机默认使用。</p><h3 id="实现自定义类加载器">实现自定义类加载器<a class="" href="#实现自定义类加载器"></a></h3><p>自定义类加载器只需要继承 java.lang.ClassLoader 类，该类有两个核心方法，一个是 loadClass()，实现了双亲委派机制，还有一个就是 findClass()，默认实现的是空方法，所以实现自定义类加载器主要是重写 fidClass 方法。</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String classPath;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClassLoader</span><span class="params">(String classPath)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.classPath = classPath;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException {</span><br><span class="line">        String fileName = name.replace(<span class="string">"."</span>, <span class="string">"/"</span>);</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            FileInputStream fin = <span class="keyword">new</span> FileInputStream(classPath + <span class="string">"/"</span> + fileName + <span class="string">".class"</span>);</span><br><span class="line">            <span class="keyword">int</span> available = fin.available();</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[available];</span><br><span class="line">            fin.read(bytes);</span><br><span class="line">            fin.close();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.defineClass(name, bytes, <span class="number">0</span>, bytes.length);</span><br><span class="line">        } <span class="keyword">catch</span> (Exception ignore) {</span><br><span class="line">            <span class="comment">// throw the end</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">//  将 tech.stack.HelloWorld.class copy 到 /Users/chenjianyuan/Documents 目录下面</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        MyClassLoader classLoader = <span class="keyword">new</span> MyClassLoader(<span class="string">"/Users/chenjianyuan/Documents"</span>);</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            Class&lt;?&gt; aClass = classLoader.loadClass(<span class="string">"tech.stack.HelloWorld"</span>);</span><br><span class="line">            System.out.println(aClass);</span><br><span class="line">            System.out.println(aClass.getClassLoader());</span><br><span class="line">        } <span class="keyword">catch</span> (ClassNotFoundException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// class tech.stack.HelloWorld</span></span><br><span class="line"><span class="comment">// tech.stack.classload.MyClassLoader@7b3300e5</span></span><br></pre></td></tr></tbody></table></figure><p>只要重写 findClass 方法，能获取到可以被虚拟机加载的.class 文件流就可以。因此可以自定义文件流的来源，譬如文件类加载器、网络类加载器、数据库类加载器等等。关于 defineClass() 就是类加载过程中其他验证、准备、解析、初始化等阶段。</p><h3 id="打破双亲委派模型">打破双亲委派模型<a class="" href="#打破双亲委派模型"></a></h3><h4 id="实现自定义加载器打破双亲委派模型">实现自定义加载器打破双亲委派模型<a class="" href="#实现自定义加载器打破双亲委派模型"></a></h4><p>上文分析出 ClassLoader 类加载器的 loadClass() 方法是实现双亲委派模型的关键，因此要实现自定义加载器打破双亲委派模型，重写 loadClass() 方法则为关键的步骤,还是上面的代码，不同的是在项目中添加<code>tech.stack.HelloWorld</code>类型，如下所示：</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/images/post/2020/08/image-20200821193934585.png" alt="HelloWorld"></p><p>再次运行查看输出日志：</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">tech</span>.<span class="title">stack</span>.<span class="title">HelloWorld</span></span></span><br><span class="line"><span class="class"><span class="title">sun</span>.<span class="title">misc</span>.<span class="title">Launcher</span>$<span class="title">AppClassLoader</span>@18<span class="title">b4aac2</span></span></span><br></pre></td></tr></tbody></table></figure><p>发现由于双亲委派模型，tech.stack.HelloWorld 是由 AppClassLoader 类加载器进行加载的。修改一下MyClassLoader 代码来打破双亲委派模型：</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String classPath;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClassLoader</span><span class="params">(String classPath)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.classPath = classPath;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve) <span class="keyword">throws</span> ClassNotFoundException {</span><br><span class="line">        <span class="keyword">synchronized</span> (getClassLoadingLock(name)) {</span><br><span class="line">            <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">            Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) {</span><br><span class="line">                <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">                <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                <span class="comment">// to find the class.</span></span><br><span class="line">                <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">              <span class="comment">// 此处需要进行判断  非自定义的类比如一些核心的类库（Object）还是需要让上层类加载器去加载</span></span><br><span class="line">                <span class="keyword">if</span> (!name.startsWith(<span class="string">"tech.stack"</span>)) { </span><br><span class="line">                    c = <span class="keyword">this</span>.getParent().loadClass(name);</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    c = findClass(name);</span><br><span class="line">                }</span><br><span class="line">                <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (resolve) {</span><br><span class="line">                resolveClass(c);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException {</span><br><span class="line">        String fileName = name.replace(<span class="string">"."</span>, <span class="string">"/"</span>);</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            FileInputStream fin = <span class="keyword">new</span> FileInputStream(classPath + <span class="string">"/"</span> + fileName + <span class="string">".class"</span>);</span><br><span class="line">            <span class="keyword">int</span> available = fin.available();</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[available];</span><br><span class="line">            fin.read(bytes);</span><br><span class="line">            fin.close();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.defineClass(name, bytes, <span class="number">0</span>, bytes.length);</span><br><span class="line">        } <span class="keyword">catch</span> (Exception ignore) {</span><br><span class="line">            <span class="comment">// throw the end</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        MyClassLoader classLoader = <span class="keyword">new</span> MyClassLoader(<span class="string">"/Users/chenjianyuan/Documents"</span>);</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            Class&lt;?&gt; aClass = classLoader.loadClass(<span class="string">"tech.stack.HelloWorld"</span>);</span><br><span class="line">            System.out.println(aClass);</span><br><span class="line">            System.out.println(aClass.getClassLoader());</span><br><span class="line">            Method sayHello = aClass.getMethod(<span class="string">"sayHello"</span>, <span class="keyword">null</span>);</span><br><span class="line">            sayHello.invoke(aClass.newInstance(), <span class="keyword">null</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// class tech.stack.HelloWorld</span></span><br><span class="line"><span class="comment">// tech.stack.classload.MyClassLoader@610455d6</span></span><br><span class="line"><span class="comment">// Hello world!</span></span><br></pre></td></tr></tbody></table></figure><p>此处只是简单的一个实现，不同的业务模型实现的模式不同，要根据实际问题具体分析。</p><blockquote><p>思维扩展</p><p>判断两个类是否相等的前提是这两个类是同一个类加载器加载的。如下代码：</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        MyClassLoader classLoader = <span class="keyword">new</span> MyClassLoader(<span class="string">"/Users/chenjianyuan/Documents"</span>);</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            Class&lt;?&gt; aClass = classLoader.loadClass(<span class="string">"tech.stack.HelloWorld"</span>);</span><br><span class="line">            System.out.println(aClass.newInstance() <span class="keyword">instanceof</span> HelloWorld);</span><br><span class="line">            Class&lt;?&gt; bClass = ClassLoader.getSystemClassLoader().loadClass(<span class="string">"tech.stack.HelloWorld"</span>);</span><br><span class="line">            System.out.println(bClass.newInstance() <span class="keyword">instanceof</span> HelloWorld);</span><br><span class="line">            System.out.println(aClass.equals(bClass));</span><br><span class="line">            System.out.println(bClass.equals(HelloWorld.class));</span><br><span class="line">        } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 输出结果为</span></span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></tbody></table></figure><p>这里所指的“相等”，包括代表类的Class对象的equals()方法、isAssignableFrom()方法、isInstance()方法的返回结果，也包括使用instanceof关键字做对象所属关系判定等情况。</p></blockquote><h4 id="为什么要打破双亲委派模型">为什么要打破双亲委派模型<a class="" href="#为什么要打破双亲委派模型"></a></h4><p>过双亲委派模型并不是一个强制性的约束模型，而是Java设计者推荐给开发者的类加载器实现方式。虽然双亲委派模型很好的保证了类库的安全和统一，但是一些情况下，这也会成为一些弊端：</p><ul><li>在核心底层代码需要调用上层用户代码，典型的便是 JNDI 服务，它的代码由启动类加载器去加载（rt.jar），但JNDI的目的就是对资源进行集中管理和查找，它需要调用由独立厂商实现并部署在应用程序的ClassPath下的JNDI接口提供者（SPI,Service Provider Interface）的代码。</li><li>程序追求动态性。比如代码热替换（HotSwap）、模块热部署（Hot Deployment）等。</li><li>为了保证环境隔离与资源共享。例如 Tomcat隔离多个 webApp jar 包冲突问题、Spring 读取Tomcat 环境中共享资源。</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Feign Api返回值为void时获取 Response信息</title>
      <link href="/post/164885659/"/>
      <url>/post/164885659/</url>
      
        <content type="html"><![CDATA[<h2 id="问题环境">问题环境<a class="" href="#问题环境"></a></h2><p>macOS 10.15.6  jdk1.8  <code>Springboot2.3.1RELEASE</code>  <code>spring-cloud-starter-openfeign2.2.3.RELEASE</code></p><h2 id="问题描述">问题描述<a class="" href="#问题描述"></a></h2><p>A、B 两个服务之间通过 Feign Api 进行通信， A 提供的 Api 包中包含一些返回值为 void 的方法。</p><figure class="highlight groovy"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/provider/product"</span>)</span><br><span class="line"><span class="meta">@CompileStatic</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IProductService</span> {</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 新增产品</span></span><br><span class="line"><span class="comment">     * @param ageConfigDTOList</span></span><br><span class="line"><span class="comment">     * @return</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">'/add'</span>)</span><br><span class="line">    <span class="keyword">void</span> save(<span class="meta">@Validated</span> <span class="meta">@RequestBody</span> ProductAO productAO)</span><br><span class="line">」</span><br></pre></td></tr></tbody></table></figure><p>A 服务进行了异常统一处理，接口出现异常时统一封装错误信息进行返回：</p><figure class="highlight groovy"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@ExceptionHandler</span>(BizException.<span class="keyword">class</span>)</span><br><span class="line">ResponseEntity&lt;ResponseBean&gt; handleBizException(BizException bizException, HandlerMethod handlerMethod) {</span><br><span class="line">    log.warn(<span class="string">"BizException caught of method with name [${handlerMethod.method.name}]. Message: [${bizException.message}]"</span>)</span><br><span class="line">    <span class="keyword">return</span> ResponseEntity.ok(ResponseBean.fail(ResponseCodeEnum.ERROR, bizException.message))</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> ResponseEntity&lt;ResponseBean&gt; handleMethodArgumentNotValid(MethodArgumentNotValidException ex, HttpHeaders headers, HttpStatus status, WebRequest request) {</span><br><span class="line">    log.warn(<span class="string">"MethodArgumentNotValidException caught of request [${request.getDescription(false)}]. Message: [${ex.message}]"</span>)</span><br><span class="line">    List&lt;FieldError&gt; errors = ex.bindingResult.fieldErrors</span><br><span class="line">    List&lt;String&gt; messageList = errors.collect { it.defaultMessage }</span><br><span class="line">    <span class="keyword">return</span> ResponseEntity.ok(ResponseBean.fail(ResponseCodeEnum.INVALID_INPUT, messageList.join(<span class="string">","</span>)))</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>当 A 服务 save 方法出现业务异常时，会将业务异常信息统一封装之后放入 ResponseBody 里面返回给 B 服务。但是由于提供的 Api 包 save 方法的返回值为 void，导致 B 服务获取不到错误信息。无法对信息进行处理（打印日志、返回前端、封装错误信息提示等）。</p><h2 id="解决方案">解决方案<a class="" href="#解决方案"></a></h2><ul><li>修改 A 服务提供的 Api 包，void 方法可改为<code>ResponseEntity&lt;Void&gt; save(@Validated @RequestBody ProductAO productAO)</code>或者其它自定义数据结构。</li><li>修改 A 服务统一异常处理方法，将<code> ResponseEntity.ok(ResponseBean.fail(ResponseCodeEnum.ERROR, bizException.message))</code>改为<code>return ResponseEntity.status(HttpStatus.SERVICE_UNAVAILABLE).body(ResponseBean.fail(ResponseCodeEnum.ERROR, bizException.message))</code></li></ul><h2 id="原理剖析">原理剖析<a class="" href="#原理剖析"></a></h2><h3 id="Feign-是什么">Feign 是什么<a class="" href="#Feign-是什么"></a></h3><p><a href="https://github.com/spring-cloud/spring-cloud-openfeign">spring-cloud-openfeign 在 Github 描述了其特性:</a></p><blockquote><p>Declarative REST Client: Feign creates a dynamic implementation of an interface decorated with JAX-RS or Spring MVC annotations</p></blockquote><p>Feign 利用注解来描述接口，简化了 Java HTTP Client 的调用过程，隐藏了实现细节。在应用启动时，Feign 会自动为<a href="https://github.com/FeignClient">@FeignClient</a>标记的接口动态创建实现类。在调用接口时，会根据接口上的注解信息来创建RequestTemplate，结合实际调用时的参数来创建Request，最后完成调用。具体的Http Client可以自由选择，如：Apache Http Client、OkHttp等都可以。</p><h3 id="源码跟踪">源码跟踪<a class="" href="#源码跟踪"></a></h3><h4 id="EnableFeignClients">EnableFeignClients<a class="" href="#EnableFeignClients"></a></h4><p>对于 Springboot 继承的这些第三方插件来说，搞明白其原理或者查看源码的第一步就是通过<code>@Enable*</code> 注解找到程序入口。对于 Feign 来说，第一步就是找到注解<code>@EnableFeignClients</code>。</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import(FeignClientsRegistrar.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableFeignClients</span><br></pre></td></tr></tbody></table></figure><p>它以<a href="https://github.com/Import">@Import</a>的方式将FeignClientsRegistrar实例注入到Spring Ioc 容器中。</p><h4 id="FeignClientsRegistrar">FeignClientsRegistrar<a class="" href="#FeignClientsRegistrar"></a></h4><p>FeignClientsRegistrar 用于处理 FeignClient 的全局配置和被<a href="https://github.com/FeignClient">@FeignClient</a>标记的接口，为接口动态创建实现类并添加到Ioc容器。</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FeignClientsRegistrar</span></span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span>, <span class="title">ResourceLoaderAware</span>, <span class="title">EnvironmentAware</span> </span>{</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata metadata,</span></span></span><br><span class="line"><span class="function"><span class="params">BeanDefinitionRegistry registry)</span> </span>{</span><br><span class="line">    <span class="comment">// 处理默认配置类</span></span><br><span class="line">registerDefaultConfiguration(metadata, registry);</span><br><span class="line">    <span class="comment">// 注册被 @FeignClient 标记的接口</span></span><br><span class="line">registerFeignClients(metadata, registry);</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在处理<code>@FeignClient</code>处理的接口时调用了<code>registerFeignClients(metadata, registry)</code></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerFeignClients</span><span class="params">(AnnotationMetadata metadata,</span></span></span><br><span class="line"><span class="function"><span class="params">BeanDefinitionRegistry registry)</span> </span>{</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (String basePackage : basePackages) {</span><br><span class="line">Set&lt;BeanDefinition&gt; candidateComponents = scanner</span><br><span class="line">.findCandidateComponents(basePackage);</span><br><span class="line"><span class="keyword">for</span> (BeanDefinition candidateComponent : candidateComponents) {</span><br><span class="line"><span class="keyword">if</span> (candidateComponent <span class="keyword">instanceof</span> AnnotatedBeanDefinition) {</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 注册 FeignClient</span></span><br><span class="line">registerFeignClient(registry, annotationMetadata, attributes);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>registerFeignClients(metadata, registry)</code>内部又调用了<code>registerFeignClient(registry, annotationMetadata, attributes)</code></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerFeignClient</span><span class="params">(BeanDefinitionRegistry registry,</span></span></span><br><span class="line"><span class="function"><span class="params">AnnotationMetadata annotationMetadata, Map&lt;String, Object&gt; attributes)</span> </span>{</span><br><span class="line">String className = annotationMetadata.getClassName();</span><br><span class="line">    <span class="comment">// 拿到FeignClientFactoryBean的BeanDefinitionBuilder</span></span><br><span class="line">BeanDefinitionBuilder definition = BeanDefinitionBuilder</span><br><span class="line">.genericBeanDefinition(FeignClientFactoryBean.class);</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">BeanDefinitionHolder holder = <span class="keyword">new</span> BeanDefinitionHolder(beanDefinition, className,</span><br><span class="line"><span class="keyword">new</span> String[] { alias });</span><br><span class="line">BeanDefinitionReaderUtils.registerBeanDefinition(holder, registry);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>从上述代码可以看出registerFeignClients()用来处理<a href="https://github.com/FeignClient">@FeignClient</a>标记的接口。首先扫描了classpath中<a href="https://github.com/FeignClient">@FeignClient</a>标记的接口，然后注册。由于<a href="https://github.com/FeignClient">@FeignClient</a>标记的是接口，不是普通对象，因此 Feign 利用了 FeignClientFactoryBean 来特殊处理<code>BeanDefinitionBuilderdefinition=BeanDefinitionBuilder.genericBeanDefinition(FeignClientFactoryBean.class)</code>。接着看 registerFeignClient()，最重要的是FeignClientFactoryBean.</p><p>也就是说，FeignClient 标记的接口实例会由 FeignClientFactoryBean.getObject() 来搞定。调试时在 getObject() 加个断点，在创建具体对象时会进入该方法。getObject()时会根据<a href="https://github.com/FeignClient">@FeignClient</a>注解的一些属性信息来创建bean。</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line"><span class="keyword">return</span> getTarget();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">&lt;T&gt; <span class="function">T <span class="title">getTarget</span><span class="params">()</span> </span>{</span><br><span class="line">FeignContext context = <span class="keyword">this</span>.applicationContext.getBean(FeignContext.class);</span><br><span class="line">Feign.Builder builder = feign(context);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果FeignClient没有指定URL(配置的是service)</span></span><br><span class="line">  <span class="keyword">if</span> (!StringUtils.hasText(<span class="keyword">this</span>.url)) {</span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">this</span>.name.startsWith(<span class="string">"http"</span>)) {</span><br><span class="line"><span class="keyword">this</span>.url = <span class="string">"http://"</span> + <span class="keyword">this</span>.name;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> {</span><br><span class="line"><span class="keyword">this</span>.url = <span class="keyword">this</span>.name;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">this</span>.url += cleanPath();</span><br><span class="line"><span class="keyword">return</span> (T) loadBalance(builder, context,</span><br><span class="line"><span class="keyword">new</span> HardCodedTarget&lt;&gt;(<span class="keyword">this</span>.type, <span class="keyword">this</span>.name, <span class="keyword">this</span>.url));</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> (StringUtils.hasText(<span class="keyword">this</span>.url) &amp;&amp; !<span class="keyword">this</span>.url.startsWith(<span class="string">"http"</span>)) {</span><br><span class="line"><span class="keyword">this</span>.url = <span class="string">"http://"</span> + <span class="keyword">this</span>.url;</span><br><span class="line">}</span><br><span class="line">String url = <span class="keyword">this</span>.url + cleanPath();</span><br><span class="line">Client client = getOptional(context, Client.class);</span><br><span class="line"><span class="keyword">if</span> (client != <span class="keyword">null</span>) {</span><br><span class="line"><span class="keyword">if</span> (client <span class="keyword">instanceof</span> LoadBalancerFeignClient) {</span><br><span class="line"><span class="comment">// not load balancing because we have a url,</span></span><br><span class="line"><span class="comment">// but ribbon is on the classpath, so unwrap</span></span><br><span class="line">client = ((LoadBalancerFeignClient) client).getDelegate();</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> (client <span class="keyword">instanceof</span> FeignBlockingLoadBalancerClient) {</span><br><span class="line"><span class="comment">// not load balancing because we have a url,</span></span><br><span class="line"><span class="comment">// but Spring Cloud LoadBalancer is on the classpath, so unwrap</span></span><br><span class="line">client = ((FeignBlockingLoadBalancerClient) client).getDelegate();</span><br><span class="line">}</span><br><span class="line">builder.client(client);</span><br><span class="line">}</span><br><span class="line">Targeter targeter = get(context, Targeter.class);</span><br><span class="line"><span class="keyword">return</span> (T) targeter.target(<span class="keyword">this</span>, builder, context,</span><br><span class="line"><span class="keyword">new</span> HardCodedTarget&lt;&gt;(<span class="keyword">this</span>.type, <span class="keyword">this</span>.name, url));</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>跟进(HystrixTargeter)targeter.target()，调用了<code>feign.target(target)</code> 最后会发现调用了SynchronousMethodHandler.create()方法。也就是说，FeignClientFactoryBean.getObject() 返回的是一个SynchronousMethodHandler对象。</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> MethodHandler <span class="title">create</span><span class="params">(Target&lt;?&gt; target, MethodMetadata md,</span></span></span><br><span class="line"><span class="function"><span class="params">                               RequestTemplate.Factory buildTemplateFromArgs,</span></span></span><br><span class="line"><span class="function"><span class="params">                               Options options, Decoder decoder, ErrorDecoder errorDecoder)</span> </span>{</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> SynchronousMethodHandler(target, client, retryer, requestInterceptors, logger,</span><br><span class="line">                                         logLevel, md, buildTemplateFromArgs, options, decoder,</span><br><span class="line">                                         errorDecoder, decode404);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>SynchronousMethodHandler是核心类，负责根据参数创建RequestTemplate，然后使用具体的http client执行请求。看一下SynchronousMethodHandler.invoke()方法。</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object[] argv)</span> <span class="keyword">throws</span> Throwable </span>{</span><br><span class="line">  <span class="comment">// 利用参数构建请求模板, argv 就是被MVC注解描述的各种参数</span></span><br><span class="line">  RequestTemplate template = buildTemplateFromArgs.create(argv);</span><br><span class="line">  Retryer retryer = <span class="keyword">this</span>.retryer.clone();</span><br><span class="line">  <span class="keyword">while</span> (<span class="keyword">true</span>) {</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">      <span class="comment">// 执行请求  </span></span><br><span class="line">      <span class="keyword">return</span> executeAndDecode(template);</span><br><span class="line">    } <span class="keyword">catch</span> (RetryableException e) {</span><br><span class="line">      retryer.continueOrPropagate(e);</span><br><span class="line">      <span class="keyword">if</span> (logLevel != Logger.Level.NONE) {</span><br><span class="line">        logger.logRetry(metadata.configKey(), logLevel);</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>具体执行由executeAndDecode()搞定，targetRequest()就是应用Feign的拦截器，decode()用于处理response，可以自定义Decoder.</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">Object <span class="title">executeAndDecode</span><span class="params">(RequestTemplate template)</span> <span class="keyword">throws</span> Throwable </span>{</span><br><span class="line">    <span class="comment">// 应用Feign 的拦截器</span></span><br><span class="line">    Request request = targetRequest(template);</span><br><span class="line">    Response response;</span><br><span class="line">    <span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">      <span class="comment">// 真正发起请求  </span></span><br><span class="line">      response = client.execute(request, options);</span><br><span class="line">      <span class="comment">// ensure the request is set. <span class="doctag">TODO:</span> remove in Feign 10</span></span><br><span class="line">      response.toBuilder().request(request).build();</span><br><span class="line">    } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">      ...</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">      <span class="comment">// response 处理机制，可以自定义Decoder来处理response</span></span><br><span class="line">      <span class="keyword">if</span> (response.status() &gt;= <span class="number">200</span> &amp;&amp; response.status() &lt; <span class="number">300</span>) {</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">void</span>.class == metadata.returnType()) {</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">          <span class="keyword">return</span> decode(response);</span><br><span class="line">        }</span><br><span class="line">      } <span class="keyword">else</span> <span class="keyword">if</span> (decode404 &amp;&amp; response.status() == <span class="number">404</span> &amp;&amp; <span class="keyword">void</span>.class != metadata.returnType()) {</span><br><span class="line">        <span class="keyword">return</span> decode(response);</span><br><span class="line">      } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">throw</span> errorDecoder.decode(metadata.configKey(), response);</span><br><span class="line">      }</span><br><span class="line">    } ...</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure><p>至此FeignClient 执行的主要流程就清楚了，回归到遇到的问题 Api void 方法无法获取到响应的 Response 信息，可以清楚的由上面 <code>executeAndDecode</code> 方法中的 <code> if (response.status() &gt;= 200 &amp;&amp; response.status() &lt; 300)</code>看出，对于 Api 中定义为 void 的方法执行了下面的代码：</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">void</span>.class == metadata.returnType()) {</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">} </span><br></pre></td></tr></tbody></table></figure><p>对于 Response code 在[200,300)范围内的 void 方法直接<code>return null</code> 程序没有进行 decode。至此解决方案就能很显然的的出来了。</p><blockquote><p>tips:</p><p>对于一些有返回值的 Api 接口，如果程序出现了业务异常而并不想使用 http code 为错误码返回，可以在调用者服务中编写自定义 decode 类进行 decode 处理。</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function">Decoder <span class="title">feignDecoder</span><span class="params">(ObjectFactory&lt;HttpMessageConverters&gt; messageConverters)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> OptionalDecoder(</span><br><span class="line">            <span class="keyword">new</span> ResponseEntityDecoder(<span class="keyword">new</span> BizExceptionDecoder(messageConverters)));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BizExceptionDecoder</span> <span class="keyword">extends</span> <span class="title">SpringDecoder</span> </span>{</span><br><span class="line">    BizExceptionDecoder(ObjectFactory&lt;HttpMessageConverters&gt; messageConverters) {</span><br><span class="line">        <span class="keyword">super</span>(messageConverters)</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">Object <span class="title">decode</span><span class="params">(Response response, Type type)</span> <span class="keyword">throws</span> IOException, DecodeException, FeignException </span>{</span><br><span class="line">        Response.Body body = response.body()</span><br><span class="line">        <span class="keyword">if</span> (body != <span class="keyword">null</span>) {</span><br><span class="line">            String result = Util.toString(body.asReader(Util.UTF_8));</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                ResponseBean responseBean = JsonUtil.parse(result, ResponseBean.class)</span><br><span class="line">                <span class="keyword">if</span> (!responseBean.success) {</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> BizException(responseBean.message)</span><br><span class="line">                }</span><br><span class="line">            } <span class="keyword">catch</span> (Exception ignore) {</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.decode(response, type)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> OpenFeign </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Springboot </tag>
            
            <tag> feign </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类加载过程</title>
      <link href="/post/164885508/"/>
      <url>/post/164885508/</url>
      
        <content type="html"><![CDATA[<p>之前在网上看到一道面试题，很形象的描述了类的加载初始化过程。要完全理解这道题，就不得不深入理解类加载的过程。面试题如下：</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleTon</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingleTon singleTon = <span class="keyword">new</span> SingleTon();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> count1;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> count2 = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingleTon</span><span class="params">()</span> </span>{</span><br><span class="line">        count1++;</span><br><span class="line">        count2++;</span><br><span class="line">    }</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingleTon <span class="title">getInstance</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> singleTon;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        SingleTon singleTon = SingleTon.getInstance();</span><br><span class="line">        System.out.println(<span class="string">"count1="</span> + singleTon.count1);</span><br><span class="line">        System.out.println(<span class="string">"count2="</span> + singleTon.count2);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这道题的正确答案为 :</p><p><strong>count1=1</strong></p><p><strong>count2=0</strong></p><p>至于为什么会是这个答案，这就涉及到了 JVM 类加载的过程。</p><h2 id="类的生命周期">类的生命周期<a class="" href="#类的生命周期"></a></h2><p>类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括加载、验证、准备、解析、初始化、使用和卸载 7 个阶段，其中验证、准备和解析 3 个阶段统称为连接，这 7 个阶段发生的顺序如下图所示。</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/images/2020/08/12/image-20200812153126606.png" alt="类的生命周期"></p><p>加载、验证、准备、初始化和卸载这 5 个阶段的顺序是确定的。解析阶段则不一定，由于支持运行时绑定，类可以在初始化之后再开始进行解析。同时这些阶段只是按照顺序进行开始，并不一定会按照顺序进行或者结束，因为这些阶段通常都是互相交叉地混合式进行的，通常会在一个阶段执行过程中调用、激活另外一个阶段。</p><h2 id="类的加载过程">类的加载过程<a class="" href="#类的加载过程"></a></h2><h3 id="加载">加载<a class="" href="#加载"></a></h3><p>加载是类加载过程的一个阶段，是根据特定名称查找类或接口类型的二进制表示（binary representation），并由此二进制表示来创建类或接口的过程。在加载阶段，虚拟机需要完成 3 件事：</p><ol><li>通过一个类的全限定名来获取定义此类的二进制字节流。</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li><li>在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口。</li></ol><h4 id="加载途径">加载途径<a class="" href="#加载途径"></a></h4><p>虚拟机加载的是类的二进制流，只是对内容格式做了限制，并没有指名要从哪里去获取、怎样获取一个类的二进制流，比较常见的有一下几种：</p><ul><li>从 jar、ear、war 包中读取。</li><li>从网络流中读取，这种场景的典型应用就是 Applet。</li><li>运行时计算生成，使用最多的就是动态代理技术。</li><li>其他文件生成，典型的场景是 JSP 应用，即由 JSP 文件生成对应的 Class 类。</li></ul><h4 id="加载方式">加载方式<a class="" href="#加载方式"></a></h4><ul><li>对于一个非数组类，加载阶段可以使用系统提供的引导类加载器来完成，也可以由用户自定义的类加载器去完成。</li><li>数组类是 Java 虚拟机直接创建的。一个数组类创建的过程遵循以下规则：<ul><li>数组的元素是引用类型，那就递归采用本文所讲的类加载过程加载这个元素，数组类将在加载该元素类型的类加载器的类名称空间上被标识。</li><li>如果数组的元素类型不是引用类型（例如:int[] 数组），Java 虚拟机将会把数组类标记与引导类加载器关联。</li><li>数组的可见性与他的元素类型的可见性一致，如果元素类型不是引用类型，那数组的可见性将默认为 public。</li></ul></li></ul><p>加载阶段完成后，二级制字节流就按照虚拟机所需的格式储存在方法区之中，然后在内存中实例化一个 java.lang.Class 对象，将这个对象作为程序访问方法区中的这些类型数据的外部接口。</p><h3 id="验证">验证<a class="" href="#验证"></a></h3><p>验证时连接阶段的第一步，这一步是为了保证 Class文件二进制字节流符合虚拟机规范，并且不会危害虚拟机自身的安全。<a href="https://docs.oracle.com/javase/specs/jvms/se7/html/index.html">Java 虚拟机规范</a>有大量的约束和验证规则，详细的描述的验证过程。验证过程主要还是围绕 Class 文件格式对各部分进行验证。Class 文件格式课参考另一篇博文<a href="https://www.techstack.tech/post/zi-jie-ma-wen-jian-jie-gou-xiang-jie/">字节码文件结构详解</a>。但从整体上看，验证阶段大致会完成下面 4 个阶段的验证动作。</p><h4 id="文件格式验证">文件格式验证<a class="" href="#文件格式验证"></a></h4><p>第一阶段要验证字节流是否符合 Class文件格式规范，并且能被当前版本的虚拟机处理。这一阶段可能包括下面验证点：</p><ul><li>是否一魔数 0xCAFEBEBE 开头。</li><li>主次版本号是否在当前虚拟机处理范围之内。</li><li>常量池中的常量是否有不被支持的常量类型（检查常量 tag 标志）。</li><li>指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量。</li><li>…</li></ul><p>第一阶段的验证远不止这些，该阶段的主要目的是保证输入的字节流能正确的解析并存储于方法区内。这阶段的验证是基于二进制字节流进行的，只有通过了这个阶段的验证后，字节流才会进入内存的方法区中进行存储，所以后面的3个验证阶段全部是基于方法区的存储结构进行的，不会再直接操作字节流。</p><h4 id="元数据验证">元数据验证<a class="" href="#元数据验证"></a></h4><p>元数据验证是对字节码描述的信息进行语义分析，确保其描述的信息符合 Java 语言规范的要求，这个阶段可能包括的验证点如下：</p><ul><li>这个类是否有父类（出了 java.lang.Object 之外，所有的类都应当有父类）。</li><li>这个类是否继承了不允许被继承的类（被 final 修饰的类）。</li><li>如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法。</li><li>类中的字段、方法是否与父类产生矛盾（例如覆盖了父类的final字段，或者出现不符合规则的方法重载，例如方法参数都一致，但返回值类型却不同等）。</li></ul><h4 id="字节码验证">字节码验证<a class="" href="#字节码验证"></a></h4><p>字节码验证将对类的方法体进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的事件。</p><ul><li>保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作。</li><li>保证跳转指令不会跳转到方法体以外的字节码指令上。</li><li>保证方法体中的类型转换是有效的。</li></ul><p>如果一个方法通过了字节码验证，也不能说明其一定就是安全的。</p><h4 id="符号引用验证">符号引用验证<a class="" href="#符号引用验证"></a></h4><p>符号引用验证可以看做是对类自身以外（常量池中的各种符号引用）的信息校验，通常需要校验一下内容：</p><ul><li>符号引用中通过字符串描述的全限定名是否能找到对应的类。</li><li>在指定类中是否存在符合方法的字段描述符以及简单名称所描述的方法和字段。</li><li>符号引用中的类、字段、方法的访问性（private、protected、public、default）是否可被当前类访问。</li></ul><p>如果一个类无法通过符号引用验证，那么将会抛出一个<code>java.lang.IncompatibleClassChangeError</code>异常的子类，如常见的<code>java.lang.IllegalAccessError</code>、<code>java.lang.NoSuchFieldError</code>、<code>java.lang.NoSuchMethodError</code>等。</p><h3 id="准备">准备<a class="" href="#准备"></a></h3><p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些类变量所使用的内存都将在方法区中进行分配。此处需要明确<code>类变量</code>的含义，即被<code>static</code>修饰的变量，而不包括实例变量，实例变量会在初始化阶段随着对象一起分配在 Java 堆中。此时分配的初始值是数据类型的<code>零值</code>，并不是我们定义的初始值。此处还要明确一个概念，如果变量被<code>final</code>修饰，则此字段的字段属性表存在 ConstantValue 属性，那么在准备阶段变量就会被初始化为 ConstantValue属性所指定的值。可通过下例代码来对照理解：</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> B = <span class="number">20</span>;</span><br></pre></td></tr></tbody></table></figure><p>其部分汇编字节码为：</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">Constant pool:</span><br><span class="line">  #2 = Fieldref           #3.#21         // tech/techstack/blog/Test.a:I</span><br><span class="line">  #3 = Class              #22            // tech/techstack/blog/Test</span><br><span class="line">  #5 = Utf8               a</span><br><span class="line">  #6 = Utf8               I</span><br><span class="line">  #21 = NameAndType        #5:#6          // a:I</span><br><span class="line">  #22 = Utf8               tech/techstack/blog/Test</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> a;</span><br><span class="line">  descriptor: I</span><br><span class="line">  flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> B;</span><br><span class="line">  descriptor: I</span><br><span class="line">  flags: ACC_PUBLIC, ACC_STATIC, ACC_FINAL</span><br><span class="line">  ConstantValue: <span class="keyword">int</span> <span class="number">20</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> {};</span><br><span class="line">  descriptor: ()V</span><br><span class="line">  flags: ACC_STATIC</span><br><span class="line">  Code:</span><br><span class="line">    stack=<span class="number">1</span>, locals=<span class="number">0</span>, args_size=<span class="number">0</span></span><br><span class="line">       <span class="number">0</span>: bipush        <span class="number">10</span></span><br><span class="line">       2: putstatic     #2                  // Field a:I</span><br><span class="line">       <span class="number">5</span>: <span class="keyword">return</span></span><br><span class="line">    LineNumberTable:</span><br><span class="line">      line <span class="number">8</span>: <span class="number">0</span></span><br><span class="line">      </span><br></pre></td></tr></tbody></table></figure><p>从上述代码可以看出，B 字段对应的 field_info 与 a 字段对应的 field_info 相比对了一个 Constant_Value 属性，而 Constant_Value 属性的值 20 就会在准备阶段直接赋给字段 B。同时在字节码第 19 行有一个 <code>static {};</code>方法，此方法对应的就是类的构造方法<code>&lt;clinit&gt;</code>在初始化阶段执行,它的<code>Code</code>属性中对应的字节码指令<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.bipush"><code>bipush 10</code></a>为往操作数栈压入 10，<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.putstatic"><code>putstatic</code></a> 则是将值 10 赋值给 a 字段。</p><blockquote><p>基本数据类型的零值：</p><table><thead><tr><th>数据类型</th><th>零值</th></tr></thead><tbody><tr><td>byte</td><td>(byte)0</td></tr><tr><td>char</td><td>‘\u0000’</td></tr><tr><td>short</td><td>(short)0</td></tr><tr><td>boolean</td><td>false</td></tr><tr><td>int</td><td>0</td></tr><tr><td>long</td><td>0l</td></tr><tr><td>float</td><td>0.0f</td></tr><tr><td>double</td><td>0.0</td></tr><tr><td>reference</td><td>null</td></tr></tbody></table></blockquote><h3 id="解析">解析<a class="" href="#解析"></a></h3><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，符号引用在 Class 文件中以 CONSTANT_Class_info、CONSTANT_Feildref_info、CONSTANT_Methodref_info 等类型的常量出现，具体可以参考博文<a href="https://www.techstack.tech/post/zi-jie-ma-wen-jian-jie-gou-xiang-jie/">字节码文件结构详解</a>。此处有符号引用和直接引用两个概念需要了解一下.</p><h4 id="符号引用（Symbolic-References）">符号引用（Symbolic References）<a class="" href="#符号引用（Symbolic-References）"></a></h4><p>符号引用以一组符号来描述所引用的目标，符号引用可以是任何形式的字面量，只要使用能无歧义地定义到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标不一定已经加载到内存中。各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用必须都是一致的。符号引用的字面量形式需要明确的定义在 Class 文件格式中。</p><h4 id="直接引用（Direct-References）">直接引用（Direct References）<a class="" href="#直接引用（Direct-References）"></a></h4><p>直接引用可以是直接执行目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是和虚拟机实现的内存布局相关的，同一个符号引用在不同的虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用目标必定已经出现在内存中。</p><blockquote><p>关于符号引用和直接引用两个概念看起来很空洞，此处放一个 <a href="https://www.zhihu.com/people/rednaxelafx/answers">R 大</a>的回答：<a href="https://www.zhihu.com/question/30300585">传送门</a></p></blockquote><p>虚拟机规范并未规定解析发生的具体时间，只要求在执行<code>anewarray</code>、<code>checkcast</code>、<code>getfield</code>、<code>getstatic</code>、<code>instanceof</code>、<code>invokedynamic</code>、<code>invokeinterface</code>、<code>invokespecial</code>、<code>invokestatic</code>、<code>invokevirtual</code>、<code>ldc</code>、<code>ldc_w</code>、<code>multianewarray</code>、<code>new</code>、<code>putfield</code>和 <code>putstatic</code>这 16 个用于操作符号引用的字节码指令之前，先对他们所使用的符号引用进行解析。所以虚拟机实现可以根据需要来判断到底是在类被加载和加载时就对常量池中的符号引用进行解析还是等到一个符号引用将要被使用前才去解析它。</p><blockquote><p>加载过程中的解析阶段为静态的将符号引用替换为直接引用的过程。可与虚拟机栈内存中的<a href="https://www.techstack.tech/post/jvm-nei-cun-jie-gou/#toc-heading-7">动态链接</a>参照记忆。</p></blockquote><p>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用限定符 7 类符号引用进行，分别对应于常量池的<code>CONSTANT_Class_info</code>、<code>CONSTANT_Fieldref_info</code>、<code>CONSTANT_Methodref_info</code>、<code>CONSTANT_InterfaceMethodref_info</code>、<code>CONSTANT_MethodType_info</code>、<code>CONSTANT_MethodHandle_info</code>和<code>CONSTANT_InvokeDynamic_info</code> 7种常量类型。</p><h3 id="初始化">初始化<a class="" href="#初始化"></a></h3><p>初始化阶段是类加载过程中的最后一步，此阶段才是真正执行类中定义的 Java 程序代码。初始化阶段和准备阶段的初始化是不同概念的，准备阶段的初始化是给类字段赋值零值的过程，而类加载过程中的初始化阶段可以看做是类对象的初始化。对于类的初始化反映到字节码中就是类的<code>&lt;clinit&gt;()</code>方法。从另外一个角度来讲，可以将初始化阶段理解成是执行类构造器＜clinit＞()方法的过程。同时对于<code>&lt;clinit&gt;()</code>方法，有几个概念要弄清楚。</p><ul><li><code>&lt;clinit&gt;()</code>方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块(static {})中的语句合并产生的。</li><li>编译器收集的顺序是由语句在源文件中出现的顺序决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在静态语句块中可以赋值，但不能访问。</li><li>在执行子类的<code>&lt;clinit&gt;()</code>方法之前，虚拟机会确保子类的<code>&lt;clinit&gt;()</code>方法已经执行完毕。因此在虚拟机中第一个被执行的＜clinit＞()方法的类肯定是java.lang.Object。</li><li>接口中不能使用静态代码块，但仍有变量初始化的赋值操作，因此接口也会生成<code>&lt;clinit&gt;()</code>方法。与类不同的是，执行接口<code>&lt;clinit&gt;()</code>方法不需要先执行父接口的<code>&lt;clinit&gt;()</code>方法。只有当父接口中定义的变量使用时，父接口才会初始化。接口的实现类在初始化时也不会执行接口的<code>&lt;clinit&gt;()</code>方法。</li><li>在多线程的情况下，虚拟机会保证一个类的<code>&lt;clinit&gt;()</code>方法只被一个线程调用，其它线程会被阻塞。同时，在一个类加载器下，一个类的<code>&lt;clinit&gt;()</code>方法只会被执行一次。</li></ul><blockquote><p>注：</p><p>本文所说的类对象与类实例不是一个概念。关于类对象与类实例以及 java.lang.Class 对象之间的关系，此处可以引用 <code>R 大</code>的一个回答<a href="https://www.zhihu.com/question/50258991/answer/120450561">传送门</a>：</p><blockquote><p>在HotSpot VM中，对象(类的实例对象)、类的元数据（InstanceKlass）、类的Java镜像（java.lang.Class 实例），三者之间的关系是这样的：</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">&gt;&gt;Java object      InstanceKlass       Java mirror</span><br><span class="line">[ _mark  ]                          (java.lang.Class instance)</span><br><span class="line">[ _klass ] --&gt; [ ...          ] &lt;-\              </span><br><span class="line">[ fields ]     [ _java_mirror ] --+&gt; [ _mark  ]</span><br><span class="line">               [ ...          ]   |  [ _klass ]</span><br><span class="line">                                  |  [ fields ]</span><br><span class="line">                                   \ [ klass  ]</span><br></pre></td></tr></tbody></table></figure><p>每个Java对象的对象头里，_klass字段会指向一个VM内部用来记录类的元数据用的InstanceKlass对象；InsanceKlass里有个_java_mirror字段，指向该类所对应的Java镜像——java.lang.Class实例。HotSpot VM会给Class对象注入一个隐藏字段“klass”，用于指回到其对应的InstanceKlass对象。这样，klass与mirror之间就有双向引用，可以来回导航。这个模型里，java.lang.Class实例并不负责记录真正的类元数据，而只是对VM内部的InstanceKlass对象的一个包装供Java的反射访问用。</p></blockquote><p>通过上面的引用，可以清楚的知道 Java Object, InstanceKlass, Java mirror(java.lang.Class instance)在内存中的分布了。</p></blockquote><p>对于初始化阶段可以通过代码来理解一下：</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperClass</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> superClassField = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> {</span><br><span class="line">        System.out.println(<span class="string">"supper class static code"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SuperClass</span><span class="params">()</span> </span>{</span><br><span class="line">        System.out.println(<span class="string">"supper class constructor"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SuperInterface</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> superInterfaceField = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">SuperClass</span> <span class="keyword">implements</span> <span class="title">SuperInterface</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> subClassField = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> {</span><br><span class="line">        System.out.println(<span class="string">"sub class static code."</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SubClass</span><span class="params">()</span> </span>{</span><br><span class="line">        System.out.println(<span class="string">"sub class constructor"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClassLoad</span> </span>{</span><br><span class="line">    <span class="keyword">static</span> {</span><br><span class="line">        System.out.println(<span class="string">"test class load"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>{</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">static</span> {</span><br><span class="line">        System.out.println(<span class="string">"App main static code"</span>);</span><br><span class="line">    }</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        System.out.println(SubClass.superClassField);</span><br><span class="line">        System.out.println(<span class="string">"----------------------"</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(SubClass::<span class="keyword">new</span>).start();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>在运行 SubClass 的时候加上 <code>-XX:+TraceClassLoading</code> 参数，打印出来运行过程中加载的类。上述代码运行结果为结果 1：</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 类加载日志（节选）</span></span><br><span class="line">[Loaded tech.stack.App from file:/Users/chenjianyuan/IdeaProjects/course/target/classes/]</span><br><span class="line">[Loaded tech.stack.SuperInterface from file:/Users/chenjianyuan/IdeaProjects/course/target/classes/]</span><br><span class="line">[Loaded tech.stack.SuperClass from file:/Users/chenjianyuan/IdeaProjects/course/target/classes/]</span><br><span class="line">[Loaded tech.stack.SubClass from file:/Users/chenjianyuan/IdeaProjects/course/target/classes/]</span><br><span class="line"></span><br><span class="line">App main <span class="keyword">static</span> code</span><br><span class="line">supper <span class="class"><span class="keyword">class</span> <span class="title">static</span> <span class="title">code</span></span></span><br><span class="line"><span class="class">1</span></span><br><span class="line"><span class="class">----------------------</span></span><br><span class="line"><span class="class"><span class="title">sub</span> <span class="title">class</span> <span class="title">static</span> <span class="title">code</span>.</span></span><br><span class="line"><span class="class"><span class="title">supper</span> <span class="title">class</span> <span class="title">constructor</span></span></span><br><span class="line"><span class="class"><span class="title">sub</span> <span class="title">class</span> <span class="title">constructor</span>  </span></span><br><span class="line"><span class="class">  </span></span><br></pre></td></tr></tbody></table></figure><p>注释掉<code>new Thread(SubClass::new).start();</code>重新运行程序，得到一下输出结果 2：</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">[Loaded tech.stack.App from file:/Users/chenjianyuan/IdeaProjects/course/target/classes/]</span><br><span class="line">[Loaded tech.stack.SuperInterface from file:/Users/chenjianyuan/IdeaProjects/course/target/classes/]</span><br><span class="line">[Loaded tech.stack.SuperClass from file:/Users/chenjianyuan/IdeaProjects/course/target/classes/]</span><br><span class="line">[Loaded tech.stack.SubClass from file:/Users/chenjianyuan/IdeaProjects/course/target/classes/]</span><br><span class="line"></span><br><span class="line">App main <span class="keyword">static</span> code</span><br><span class="line">supper <span class="class"><span class="keyword">class</span> <span class="title">static</span> <span class="title">code</span></span></span><br><span class="line"><span class="class">1</span></span><br><span class="line"><span class="class">----------------------</span></span><br></pre></td></tr></tbody></table></figure><p>然后将 <code>System.out.println(SubClass.superClassField);</code> 替换为 <code>System.out.println(SubClass.subClassField);</code> 再次运行程序，得到输出结果 3：</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">[Loaded tech.stack.App from file:/Users/chenjianyuan/IdeaProjects/course/target/classes/]</span><br><span class="line">[Loaded tech.stack.SuperInterface from file:/Users/chenjianyuan/IdeaProjects/course/target/classes/]</span><br><span class="line">[Loaded tech.stack.SuperClass from file:/Users/chenjianyuan/IdeaProjects/course/target/classes/]</span><br><span class="line">[Loaded tech.stack.SubClass from file:/Users/chenjianyuan/IdeaProjects/course/target/classes/]</span><br><span class="line"></span><br><span class="line">App main <span class="keyword">static</span> code</span><br><span class="line">supper <span class="class"><span class="keyword">class</span> <span class="title">static</span> <span class="title">code</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">sub</span> <span class="title">class</span> <span class="title">static</span> <span class="title">code</span>.</span></span><br><span class="line"><span class="class">20</span></span><br><span class="line"><span class="class">----------------------</span></span><br></pre></td></tr></tbody></table></figure><p>这几段代码信息量很大，根据上文所讲慢慢分析：</p><ul><li>加载<ul><li>从类加载日志从看到<code>TestClassLoad</code>类始终都没有被加载。而<code>App</code>、<code>SuperInterface</code>、<code>SuperClass</code>、<code>SubClass</code> 始终被加载，是不是可以证明属于 Applicatin 作用域范围内的类会在首次使用时加载。</li><li>对比结果 1 和结果 2 以及没有显示调用<code>SuperInterface</code>任何方法、变量可以看出对于子类来说，在加载子类时首先要加载实现的接口以及父类。</li></ul></li><li>初始化<ul><li><p>当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。</p></li><li><p>结果 1 结果 3 都表明父类的<code>&lt;clinit&gt;()</code>方法在子类<code>&lt;clinit&gt;()</code>方法之前调用。</p></li><li><p>结果 1 结果 2 对比表明通过子类调用父类的静态的变量只会引起父类的初始化并不会使子类初始化。</p></li><li><p>对比结果 1 和结果 2 说明在多线程的情况况下只要类加载器相同，类只初始化一次。</p></li><li><p>对比结果 1、2、3 能得出一个实例的初始化顺序</p><ol><li>父类 static 代码块即父类的<code>&lt;clinit&gt;()</code>方法。</li><li>子类的 static 代码块即子类的<code>&lt;clinit&gt;()</code>方法。</li><li>父类的构造方法即父类的<code>&lt;init&gt;()</code>方法。</li><li>子类的构造方法<code>&lt;init&gt;()</code>方法、</li></ol></li></ul></li></ul><blockquote><p>注：</p><ol><li><p>关于类实例的初始化过程即对象的实例化过程会专门在另一篇博客进行讲解。</p></li><li><p>关于"接口中不能使用静态代码块，但仍有变量初始化的赋值操作，因此接口也会生成<code>&lt;clinit&gt;()</code>方法。" 在接口中变量初始化赋值操作可参考如下代码：</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SuperInterface</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> superInterfaceField = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    SuperClass su = <span class="keyword">new</span> SuperClass();</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// bytecode</span></span><br><span class="line"></span><br><span class="line">{</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> superInterfaceField;</span><br><span class="line">    descriptor: I</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC, ACC_FINAL</span><br><span class="line">    ConstantValue: <span class="keyword">int</span> <span class="number">10</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> tech.stack.SuperClass su;</span><br><span class="line">    descriptor: Ltech/stack/SuperClass;</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC, ACC_FINAL</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> {};</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">0</span>, args_size=<span class="number">0</span></span><br><span class="line">         0: new           #1                  // class tech/stack/SuperClass</span><br><span class="line">         <span class="number">3</span>: dup</span><br><span class="line">         4: invokespecial #2                  // Method tech/stack/SuperClass."&lt;init&gt;":()V</span><br><span class="line">         7: putstatic     #3                  // Field su:Ltech/stack/SuperClass;</span><br><span class="line">        <span class="number">10</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">10</span>: <span class="number">0</span></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></li></ol></blockquote><h2 id="类的加载时机">类的加载时机<a class="" href="#类的加载时机"></a></h2><p>关于类在什么时候加载，我们可以有上面的代码窥见一斑。但是这只是在JDK1.8， Hotspot 虚拟机测试的情况下得出的结论，也不一定会是正确的，因为 Java 虚拟机规范中并没有进行强制约束，关于加载阶段，都是根据虚拟机的具体实现来自由把握。但是对于初始化阶段，虚拟机严格规定了<code>有且只有</code> 5 种情况必须立即对类进行<code>初始化</code>（而加载、验证、准备自然需要再次之前开始）：</p><ol><li>遇到<code>new</code>、<code>getstatic</code>、<code>putstatic</code>或<code>invokestatic</code>这4条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。生成这4条指令的最常见的Java代码场景是：使用new关键字实例化对象的时候、读取或设置一个类的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）的时候，以及调用一个类的静态方法的时候（已通过上文代码验证）。</li><li>使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。</li><li>当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化（上文代码也已验证）。</li><li>当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类（上文代码也已验证）。</li><li>当使用JDK 1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。</li></ol><p>尝试着补充解释一下这几条其中的原理，对于 <code>new</code> 关键字自然不用多说，<code>new</code> 关键字实例化类的实例对象之前自然会执行类的初始化操作，以完成 Java 程序对类的一些操作。<code>getstatic</code> <code>putstatic</code> 指令的含义为读取或设置一个类的静态字段，此处还是应用<code>R大</code>的回答，原文与上处引用出自同一处：</p><blockquote><p>从JDK 1.3到JDK 6的HotSpot VM，静态变量保存在类的元数据（InstanceKlass）的末尾。而从JDK 7开始的HotSpot VM，静态变量则是保存在类的Java镜像（java.lang.Class实例）的末尾。假如有这样的A类：</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>{</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>那么在JDK 6或之前的HotSpot VM里：</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">Java object      InstanceKlass       Java mirror</span><br><span class="line"> [ _mark  ]                          (java.lang.Class instance)</span><br><span class="line"> [ _klass ] --&gt; [ ...          ] &lt;-\              </span><br><span class="line"> [ fields ]     [ _java_mirror ] --+&gt; [ _mark  ]</span><br><span class="line">                [ ...          ]   |  [ _klass ]</span><br><span class="line">                [ A.value      ]   |  [ fields ]</span><br><span class="line">                                    \ [ klass  ]</span><br></pre></td></tr></tbody></table></figure><p>可以看到这个A.value静态字段就在InstanceKlass对象的末尾存着了。而在JDK 7或之后的HotSpot VM里：</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">Java object      InstanceKlass       Java mirror</span><br><span class="line"> [ _mark  ]                          (java.lang.Class instance)</span><br><span class="line"> [ _klass ] --&gt; [ ...          ] &lt;-\              </span><br><span class="line"> [ fields ]     [ _java_mirror ] --+&gt; [ _mark   ]</span><br><span class="line">                [ ...          ]   |  [ _klass  ]</span><br><span class="line">                                   |  [ fields  ]</span><br><span class="line">                                    \ [ klass   ]</span><br><span class="line">                                      [ A.value ]</span><br></pre></td></tr></tbody></table></figure><p>可以看到这个A.value静态字段就在java.lang.Class对象的末尾存着了。</p></blockquote><p>据此我们应该就能得出结论，在设置静态变量的时候已经需要根据<code>InstanceKlass</code>生成<code>java.lang.Class</code>对象了，而静态变量已经不能在方法区通过读取类元信息进行获取或者储存。而生成 Java mirror 必然要通过完整的类元信息，因此需要进行初始化动作。对于<code>java.lang.reflect</code>包的反射方法，其根据的就是 <code>java.lang.Class</code>对象。对于子类初始化时，因为 Java 的继承特性，继承的是父类完整的类信息。父类进行初始化也是理所当然的。</p><p>上述 5 种场景中的行为称为对一个类的主动引用。除此之外，所有的引用类的方式都不会触发初始化，称为被动引用。例：</p><ul><li><p>通过子类调用父类的静态字段（变量+常量），不会导致子类的初始化。代码可参考上文。</p></li><li><p>通过数组定义来引用类，不会触发此类的初始化</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">      SuperClass[] superClasses = <span class="keyword">new</span> SuperClass[<span class="number">10</span>];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p>常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstantClass</span> </span>{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String HELLO_WORLD = <span class="string">"hello world !"</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        System.out.println(ConstantClass.HELLO_WORLD);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这是因为虽然在Java源码中引用了ConstClass类中的常量HELLOWORLD，但其实在编译阶段通过常量传播优化，已经将此常量的值"hello world !"存储到了App类的常量池中，以后App对常量HELLO_WORLD的引用实际都被转化为App类对自身常量池的引用了。也就是说，实际上App的Class文件之中并没有ConstantClass类的符号引用入口，这两个类在编译成Class之后就不存在任何联系了。可以看一下App的字节码。</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">Constant pool:</span><br><span class="line"> #4 = String             #25            // hello world !</span><br><span class="line"> #25 = Utf8               hello world !</span><br><span class="line"></span><br><span class="line">{</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">         3: ldc           #4                  // String hello world !</span><br><span class="line">         5: invokevirtual #5                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">         <span class="number">8</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">10</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">11</span>: <span class="number">8</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">9</span>     <span class="number">0</span>  args   [Ljava/lang/String;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="例题解析">例题解析<a class="" href="#例题解析"></a></h2><p>其实讲到这里，这道题也算是分析完了，那么就根据上面所讲，总结一下这道题：</p><ol><li>运行 <code>Test</code> 类的 main 方法，回顾上文肯定要先加载、验证、初始化 <code>Test</code> 类（由于加载、验证必然发生在初始化之前，下面分析就忽略这两个阶段）。</li><li><code>SingleTon.getInstance()</code> 为 <code>Test</code> 类调用 <code>SingleTon</code> 类的静态方法，必然引起 <code>SingleTon</code> 类的初始化。</li><li><code>SingleTon</code> 类存在 <code>singleTon</code> <code>count1</code> <code>count2</code> 三个静态变量，因此这三个静态变量会被编译器<strong>顺序</strong>收集值到<code>&lt;clinit&gt;()</code>方法中。</li><li><code>&lt;clinit&gt;()</code> 开始就是 <code>new SingleTon()</code> 会创建 <code>SingleTon</code> 类的实例 <code>singleTon</code>，此时 ``singleTon.count1<code> </code>singleTon.count2` 值都为 1。</li><li><code>&lt;clinit&gt;()</code> 操作完第一个变量 <code>singleTon</code> 之后便是对第二个变量 <code>count1</code> 操作，此时就会将 1 赋值给 <code>SingleTon</code> 变量 <code>count1</code>。</li><li><code>&lt;clinit&gt;()</code> 后续操作便是执行 <code>count2 = 0</code> 即通过操作数栈将 0 赋值给<code>SingleTon</code> 变量 <code>count2</code>。</li></ol><p>查看<code>SingleTon</code> 的字节码：</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">{</span><br><span class="line"> <span class="keyword">static</span> {};</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">0</span>, args_size=<span class="number">0</span></span><br><span class="line">         0: new           #5                  // class tech/stack/SingleTon</span><br><span class="line">         <span class="number">3</span>: dup</span><br><span class="line">         4: invokespecial #6                  // Method "&lt;init&gt;":()V</span><br><span class="line">         7: putstatic     #4                  // Field singleTon:Ltech/stack/SingleTon;</span><br><span class="line">        <span class="number">10</span>: iconst_0</span><br><span class="line">        11: putstatic     #3                  // Field count2:I</span><br><span class="line">        <span class="number">14</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">4</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">6</span>: <span class="number">10</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>其 <code>static{}</code> 方法执行流程正如上文分析。不妨想一下如果将<code>private static SingleTon singleTon = new SingleTon();</code>移动到<code>public static int count2 = 0;</code>下面将会输出什么结果？</p><h2 id="总结">总结<a class="" href="#总结"></a></h2><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/images/2020/08/14/%E7%B1%BB%E5%8A%A0%E8%BD%BD.png" alt="类加载"></p><p>参考：</p><p>[1] 周志明.深入理解Java虚拟机：JVM高级特性与最佳实践.北京:机械工业出版社,2013.</p><p>[2] <a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-5.html">Chapter 5. Loading, Linking, and Initializing</a></p><p>[3] <a href="https://www.zhihu.com/question/30300585">JVM里的符号引用如何存储？</a></p><p>[4] <a href="https://www.zhihu.com/question/50258991/answer/120450561">JVM符号引用转换直接引用的过程?</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字节码文件结构详解</title>
      <link href="/post/164885506/"/>
      <url>/post/164885506/</url>
      
        <content type="html"><![CDATA[<p>“一次编写，到处运行（Write Once,Run Anywhere）“，这是 Java 诞生之时一个非常著名的口号。在学习 Java 之初，就了解到了我们所写的<code>.java</code>会被编译期编译成<code>.class</code>文件之后被 JVM 加载运行。JVM 全称为 <code>Java Virtual Machine</code>，一直以为 JVM 执行 Java 程序是一件理所当然的事情，但随着工作过程中接触到了越来越多的基于 JVM 实现的语言如<code>Groovy</code> <code>Kotlin</code> <code>Scala</code>等，就深刻的理解到了 JVM 和 Java 的无关性，JVM 运行的不是 Java 程序，而是符合 JVM 规范的<code>.class</code>字节码文件。字节码是各种不同平台的虚拟机与所有平台都统一使用的程序储存格式。是构成<code>Run Anywhere</code> 的基石。因此了解 Class 字节码文件对于我们开发、逆向都是十分有帮助的。</p><h2 id="Class-类文件的结构">Class 类文件的结构<a class="" href="#Class-类文件的结构"></a></h2><h3 id="概述">概述<a class="" href="#概述"></a></h3><p>Class文件是一组以 8位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在 Class 文件中，中间没有添加任何分隔符，这使得整个 Class 文件中存储的内容几乎全部是程序运行的必要数据，没有空隙存在。当遇到需要占用 8 位字节以上空间的数据项时，则会按照<code>Big-Endian</code>的方式分割成若干个 8 字节进行存储。<code>Big-Endian</code>具体是指最高位字节在地址最低位、最低位字节在地址最高位的顺序来存储数据。<code>SPARC</code>、<code>PowerPC</code>等处理器默认使用<code>Big-Endian</code>字节存储顺序，而<code>x86</code>等处理器则是使用了相反的<code>Little-Endian</code>顺序来存储数据。因此为了Class文件的保证平台无关性，JVM必须对其规范统一。</p><h3 id="Class-文件结构">Class 文件结构<a class="" href="#Class-文件结构"></a></h3><p>在讲解Class类文件结构之前需要先介绍两个概念：无符号数和表。一种类似 C 语言结构体的伪结构。</p><ul><li>无符号数：基本类型数据，一 u1、u2、u4、u8 来分别代表 1 个字节、2 个字节、4 个字节和 8 个字节的无符号数。用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串值。</li><li>表：由多个无符号数或者其他表作为数据项构成的复合数据类型，所有的表都习惯以<code>_info</code>结尾，用于描述有层次关系的复合结构的数据。</li></ul><p>当需要描述同一类型但数量不定的多个数据时，经常会使用一个前置的容量计数器加若干个连续的数据项的形式，这时就代表此类型的集合。整个 Class文件本质上就是一张表，其数据项如下伪代码所示：</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">ClassFile {</span><br><span class="line">  u4              magic;</span><br><span class="line">  u2              minor_version;</span><br><span class="line">  u2              major_version;</span><br><span class="line">  u2              constant_pool_count;</span><br><span class="line">  cp_info         constant_pool[constant_pool_count-<span class="number">1</span>];</span><br><span class="line">  u2              access_flags;</span><br><span class="line">  u2              this_class;</span><br><span class="line">  u2              super_class;</span><br><span class="line">  u2              interfaces_count;</span><br><span class="line">  u2              interfaces[interfaces_count];</span><br><span class="line">  u2              fields_count;</span><br><span class="line">  field_info      fields[fields_count];</span><br><span class="line">  u2              methods_count;</span><br><span class="line">  method_info     methods[methods_count];</span><br><span class="line">  u2              attributes_count;</span><br><span class="line">  attribute_info  attributes[attributes_count];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>每项数据项的含义我们可以对照下图参照表：</p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/images/2020/08/08/image-20200808150307745.png" alt="Class类文件结构"><p>同时我们将根据一个具体的 Java 类来分析 Class 文件结构</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteCode</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> username;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsername</span><span class="params">(String username)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>其.class 文件内容如下：</p><p id=".class"></p><img id=".class" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/images/2020/08/09/class%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84.png" alt="class文件结构"><p id="huibian"></p><p>使用 <code>javap</code> 命令可以得到反汇编代码：</p><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">Classfile /Users/chenjianyuan/IdeaProjects/blog/blog-web/target/test-classes/tech/techstack/blog/ByteCode.class</span><br><span class="line">  Last modified 2020-8-8; size 581 bytes</span><br><span class="line">  MD5 checksum 43eb79f48927d9c5bbecfa5507de0f3c</span><br><span class="line">  Compiled from "ByteCode.java"</span><br><span class="line">public class tech.techstack.blog.ByteCode</span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: 52</span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #1 = Methodref          #4.#21         // java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">   #2 = Fieldref           #3.#22         // tech/techstack/blog/ByteCode.username:Ljava/lang/String;</span><br><span class="line">   #3 = Class              #23            // tech/techstack/blog/ByteCode</span><br><span class="line">   #4 = Class              #24            // java/lang/Object</span><br><span class="line">   #5 = Utf8               username</span><br><span class="line">   #6 = Utf8               Ljava/lang/String;</span><br><span class="line">   #7 = Utf8               &lt;init&gt;</span><br><span class="line">   #8 = Utf8               ()V</span><br><span class="line">   #9 = Utf8               Code</span><br><span class="line">  #10 = Utf8               LineNumberTable</span><br><span class="line">  #11 = Utf8               LocalVariableTable</span><br><span class="line">  #12 = Utf8               this</span><br><span class="line">  #13 = Utf8               Ltech/techstack/blog/ByteCode;</span><br><span class="line">  #14 = Utf8               getUsername</span><br><span class="line">  #15 = Utf8               ()Ljava/lang/String;</span><br><span class="line">  #16 = Utf8               setUsername</span><br><span class="line">  #17 = Utf8               (Ljava/lang/String;)V</span><br><span class="line">  #18 = Utf8               MethodParameters</span><br><span class="line">  #19 = Utf8               SourceFile</span><br><span class="line">  #20 = Utf8               ByteCode.java</span><br><span class="line">  #21 = NameAndType        #7:#8          // "&lt;init&gt;":()V</span><br><span class="line">  #22 = NameAndType        #5:#6          // username:Ljava/lang/String;</span><br><span class="line">  #23 = Utf8               tech/techstack/blog/ByteCode</span><br><span class="line">  #24 = Utf8               java/lang/Object</span><br><span class="line">{</span><br><span class="line">  public tech.techstack.blog.ByteCode();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=1, locals=1, args_size=1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">         4: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 7: 0</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0       5     0  this   Ltech/techstack/blog/ByteCode;</span><br><span class="line"></span><br><span class="line">  public java.lang.String getUsername();</span><br><span class="line">    descriptor: ()Ljava/lang/String;</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=1, locals=1, args_size=1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: getfield      #2                  // Field username:Ljava/lang/String;</span><br><span class="line">         4: areturn</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 11: 0</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0       5     0  this   Ltech/techstack/blog/ByteCode;</span><br><span class="line"></span><br><span class="line">  public void setUsername(java.lang.String);</span><br><span class="line">    descriptor: (Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=2, args_size=2</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: aload_1</span><br><span class="line">         2: putfield      #2                  // Field username:Ljava/lang/String;</span><br><span class="line">         5: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 15: 0</span><br><span class="line">        line 16: 5</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0       6     0  this   Ltech/techstack/blog/ByteCode;</span><br><span class="line">            0       6     1 username   Ljava/lang/String;</span><br><span class="line">    MethodParameters:</span><br><span class="line">      Name                           Flags</span><br><span class="line">      username</span><br><span class="line">}</span><br><span class="line">SourceFile: "ByteCode.java"                                   </span><br></pre></td></tr></tbody></table></figure><h4 id="magic">magic<a class="" href="#magic"></a></h4><p>每个 Class 文件的头 4 个字节<code>0xCAFEBABE</code>称为魔数（Magic Number），用来确定这个文件是否为能被虚拟机接受的 Class 文件格式。</p><h4 id="minor-version-major-version">minor_version &amp; major_version<a class="" href="#minor-version-major-version"></a></h4><p>第 5、6 个字节为次版本号（minor_version），第 6、7 个字节是主版本号（major version）上图次版本号 <code>00 00</code> 转换为 10 进制为 0，主版本号 <code>00 34</code> 转换为十进制为 52，代表 JDK 1.8。观察<a href="#huibian">反汇编</a>代码也能得到次版本和主版本信息。高版本的 JDK 向下兼容低版本的 Class 文件，但低版本不能运行高版本的 Class 文件，即使文件格式没有发生任何变化，虚拟机也拒绝执行高于其版本号的 Class 文件。</p><h4 id="constant-pool-count-constant-pool">constant_pool_count &amp; constant_pool[]<a class="" href="#constant-pool-count-constant-pool"></a></h4><p>后面紧跟着的 2 个字节为常量池个数（constant_pool_count）,然后后面紧跟 constant_pool_count 个数的常量。constant_pool_count 是从 1 开始而不是从 0 开始，是为了将 0 项空出来标识后面某些指向常量池的索引值的数据在特定情况下不引用常量池，这种情况下就可以把索引值置为 0 来表示。（除常量池计数外，对于其他类型集合包括接口索引集合、字段表集合、方法表集合等的容量计数都与一般习惯相同，是从0开始的）</p><p>常量池（constant_pool）主要存放两大类常量：</p><ul><li>字面量<ul><li>字符串常量</li><li>final 的常量值</li><li>其他类文件的引用</li></ul></li><li>符号引用<ul><li>类和接口的全限定名</li><li>字段的名称和描述符</li><li>方法的名称和描述符</li></ul></li></ul><p>常量池中的每一个常量都是一个常量表，常量表开始的第一位是一个u1类型的标志位（tag），来区分常量表的类型。在JDK 1.7之前共有11种结构各不相同的表结构数据，在JDK 1.7中为了更好地支持动态语言调用，又额外增加了3种（CONSTANT_MethodHandle_info、CONSTANT_MethodType_info和CONSTANT_InvokeDynamic_info），14 中常量类型所代表的具体含义如下：</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/images/2020/08/08/image-20200808180458818.png" alt="常量池的项目类型"></p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/images/2020/08/08/image-20200808182307356.png" alt="常量池中的 14 种常量项的结构总表"></p><p>我们对其按照字面量和符号引用类型分类的话可以入下图所示</p><img id="常量表类型分类" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/images/2020/08/08/image-20200808170707933.png" alt="常量表类型分类"><p>Class文件中的常量池结构通过上例汇编代码可看出：</p><p id="constant_pool"></p><figure class="highlight"><table><tbody><tr><td class="code"><pre><span class="line">Constant pool:</span><br><span class="line">   #1 = Methodref          #4.#21         // java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">   #2 = Fieldref           #3.#22         // tech/techstack/blog/ByteCode.username:Ljava/lang/String;</span><br><span class="line">   #3 = Class              #23            // tech/techstack/blog/ByteCode</span><br><span class="line">   #4 = Class              #24            // java/lang/Object</span><br><span class="line">   #5 = Utf8               username</span><br><span class="line">   #6 = Utf8               Ljava/lang/String;</span><br><span class="line">   #7 = Utf8               &lt;init&gt;</span><br><span class="line">   #8 = Utf8               ()V</span><br><span class="line">   #9 = Utf8               Code</span><br><span class="line">  #10 = Utf8               LineNumberTable</span><br><span class="line">  #11 = Utf8               LocalVariableTable</span><br><span class="line">  #12 = Utf8               this</span><br><span class="line">  #13 = Utf8               Ltech/techstack/blog/ByteCode;</span><br><span class="line">  #14 = Utf8               getUsername</span><br><span class="line">  #15 = Utf8               ()Ljava/lang/String;</span><br><span class="line">  #16 = Utf8               setUsername</span><br><span class="line">  #17 = Utf8               (Ljava/lang/String;)V</span><br><span class="line">  #18 = Utf8               MethodParameters</span><br><span class="line">  #19 = Utf8               SourceFile</span><br><span class="line">  #20 = Utf8               ByteCode.java</span><br><span class="line">  #21 = NameAndType        #7:#8          // "&lt;init&gt;":()V</span><br><span class="line">  #22 = NameAndType        #5:#6          // username:Ljava/lang/String;</span><br><span class="line">  #23 = Utf8               tech/techstack/blog/ByteCode</span><br><span class="line">  #24 = Utf8               java/lang/Object</span><br></pre></td></tr></tbody></table></figure><p>观察上面<a href="#.class">Class</a>文件<code>00 19</code>表示有 25 个常量，依次往后数 24（25-1）个常量则为常量池中的常量。紧随其后的一个字节为第一个常量表的 tag 位 <code>0A</code> -&gt; <code>10</code>，通过<a href="#%E5%B8%B8%E9%87%8F%E8%A1%A8%E7%B1%BB%E5%9E%8B%E5%88%86%E7%B1%BB">常量表类型</a>查询可知 10 为 <code>CONSTANT_Methodref_info</code>，表内数据项为<code>u1: tag</code> <code>u2: class_info</code> <code>u2:  name_and_type_index</code>,结合<a href="#.class">Class文件</a>分析，这表示从第一个常量<code>CONSTANT_Methodref_info</code>占用 5 个字节，其中第一个字节<code>0A</code>为标志位，其后两个字节<code>00 04</code> -&gt; <code>4</code> 之后两个字节为 class_info，紧随 2 个字节<code>00 15</code> -&gt; <code>21</code>为 name_and_type_index。我们通过查询汇编代码<a href="#constant_pool">常量池</a>中的一个常量表为<code>#1 = Methodref          #4.#21</code>得出一个常量表正是方法引用，其数据项索引也是<code>#4</code>和<code>#21</code>。剩下的 24 种常量分析也是如此。也是因为这 14 中常量类型各自均有自己的结构，所以说常量池是最繁琐的数据。</p><blockquote><p>小知识：</p><p>由于Class文件中方法、字段等都需要引用CONSTANT_Utf8_info型常量来描述名称，所以CONSTANT_Utf8_info型常量的最大长度也就是Java中方法、字段名的最大长度。而这里的最大长度就是length的最大值，既u2类型能表达的最大值65535。所以Java程序中如果定义了超过64KB英文字符的变量或方法名，将会无法编译。</p></blockquote><h4 id="access-flags">access_flags<a class="" href="#access-flags"></a></h4><p>在常量池结束之后，紧接着两个字节代表访问标志（access_flag）这个标志用于识别一些类或接口层次的访问信息。具体标志位以及标志的含义见下表：</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/images/2020/08/08/image-20200808191213634.png" alt="类的访问权限查询书册"></p><blockquote><p>invokeSpecial 指令语义在 JDK1.0.2发生过改变，为了区别这条指令使用哪种语意，在 JDK1.0.2之后编译出来的类的这个标志都必须为真。</p></blockquote><p>分析[Class]文件我们得出 access_flag 为 <code>00 21</code>，但是查询上表确没有查询到对应的标志，这是因为 <code>ByteCode</code>是一个普通的 Java 类，不是接口、枚举或者注解，被public关键字修饰但没有被声明为final和abstract，并且它使用了JDK 1.2之后的编译器进行编译，因此它的ACC_PUBLIC、ACC_SUPER标志应当为真，而其余 6 个标志应当为假，因此它的access_flags的值应为：<code>0x0001|0x0020=0x0021</code>。而我们通过 <code>ByteCode</code> <a href="#huibian">汇编</a>代码查看得到 <code>  flags: ACC_PUBLIC, ACC_SUPER</code> 也证明了的确为上述所言。</p><h4 id="this-class-super-class-interfaces-count-interfaces">this_class &amp; super_class &amp;interfaces_count &amp; interfaces[]<a class="" href="#this-class-super-class-interfaces-count-interfaces"></a></h4><p>类索引（this_class）、父类索引（super_class）和 接口数量（interface_count）是一个 u2类型的数据，而接口索引集合 interfaces[] 是一组 u2 类型的数据的集合。这四项数据直接确定了这个类的继承关系。Java 不允许多继承但是允许实现多个接口，这就为什么super_class是一个而 interfaces 是一个集合。我们通过分析[Class]文件可以看出 this_class 对应<code>00 03 -&gt; 3</code> 从常量池中查询 #3 对应的常量</p><figure class="highlight"><table><tbody><tr><td class="code"><pre><span class="line">#3 = Class              #23            // tech/techstack/blog/ByteCode</span><br><span class="line">#23 = Utf8               tech/techstack/blog/ByteCode</span><br></pre></td></tr></tbody></table></figure><p>可以看出 #3 对应的就是当前类 <code>tech/techstack/blog/ByteCode</code>。后面同样为占两个字节的 super_class 对应的``00 04 -&gt; 4`从常量池中查询出来对应的常量为</p><figure class="highlight"><table><tbody><tr><td class="code"><pre><span class="line">#4 = Class              #24            // java/lang/Object</span><br><span class="line">#24 = Utf8               java/lang/Object</span><br></pre></td></tr></tbody></table></figure><p>所以 super_class 表示的为：<code>java/lang/Object</code>。随后便是 interface_count 对应的 <code>00 00 -&gt; 0</code> 说明 <code>ByteCode</code> 没有实现接口，因此就不存在后面的 interfaces[]。</p><h4 id="fields-count-fields">fields_count &amp; fields[]<a class="" href="#fields-count-fields"></a></h4><p>字段表（field_info）用于描述接口或者类中声明的变量。字段（field）包括类级变量以及实例级变量，但不包括在方法内部声明的局部变量。fields_count 类中 field_info 的数量。fields[] 则是 field_info 的集合。field_info 的结构如下图所示：</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/images/2020/08/08/10851.png" alt="field_info"></p><p>字段修饰符 access_flag 和类中的 access_flag十分相似：</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/images/2020/08/08/image-20200808212229634.png" alt="字段访问标志"></p><p>在实际情况中，ACC_PUBLIC、ACC_PRIVATE、ACC_PROTECTED三个标志最多只能选择其一，ACC_FINAL、ACC_VOLATILE不能同时选择。接口之中的字段必须有ACC_PUBLIC、ACC_STATIC、ACC_FINAL标志。</p><p>继续分析<a href="#.class">Class</a>文件，<code>00 01 00 02 00 05 00 06 00 00</code>。其中 <code>00 01 -&gt; 1</code>表示 field_count,很显然 <code>ByteCode</code> 类中的字段只有一个 <code>private String username;</code>。 参照上表继续取两个字节<code>00 02 -&gt; 2</code>表示access_flag,查询可知修饰符号为<code>ACC_PRIVATE</code>，继续取两个字节<code>00 05 -&gt; 5</code>表示 name_index,从<a href="#huibian">汇编</a>代码中查询常量池#5为</p><figure class="highlight"><table><tbody><tr><td class="code"><pre><span class="line">#5 = Utf8               username</span><br></pre></td></tr></tbody></table></figure><p>继续取两个字节<code>00 006 -&gt; 6</code>表示<code>descriptor_index</code>,指向的是常量池 #6 的常量</p><figure class="highlight"><table><tbody><tr><td class="code"><pre><span class="line">#6 = Utf8               Ljava/lang/String;</span><br></pre></td></tr></tbody></table></figure><p>后续的 <code>00 00 -&gt; 0</code>表示<code>attribute_count</code>的个数，此处为 0。</p><blockquote><p>名词释义:</p><ol><li><p>全限定名和简单名称把类名中的<code>.</code>替换成<code>/</code>，连续多个全限定名时，为了不产生混淆，在使用时最后一般都会加入一个<code>;</code>表示全限定名结束。</p></li><li><p>方法、字段索引描述</p><p>方法的参数列表（包括数量、类型以及顺序）和返回值。根据描述符规则，基本数据类型（byte、char、double、float、int、long、short、boolean）以及代表无返回值的void类型都用一个大写字符来表示，而对象类型则用字符L加对象的全限定名来表示。</p><ul><li><p>基本数据类型</p><p>B----&gt;byteC----&gt;charD----&gt;doubleF-----&gt;floatI------&gt;intJ------&gt;longS------&gt;shortZ------&gt;booleanV-------&gt;void</p></li><li><p>对象类型</p><p>String------&gt;Ljava/lang/String;</p></li><li><p>数组类型：每一个唯独都是用一个前置 [ 来表示</p><p>int[] ------&gt;[ I,</p><p>String [][]------&gt;[[Ljava.lang.String;</p></li></ul></li><li><p>用描述符来描述方法的,先参数列表，后返回值的格式，参数列表按照严格的顺序放在()中比如源码 String getUserInfoByIdAndName(int id,String name) 的方法描述符（I,Ljava/lang/String;）Ljava/lang/String;</p></li></ol></blockquote><h4 id="methods-count-methods">methods_count &amp; methods[]<a class="" href="#methods-count-methods"></a></h4><p>Class文件储存格式中对方法的描述与对字段的描述几乎采用了完全一致的方式。方法表的结构如下图所示：</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/images/2020/08/08/10855.png" alt="Method_info"></p><p>因为volatile关键字和transient关键字不能修饰方法，所以方法表的访问标志中没有了ACC_VOLATILE标志和ACC_TRANSIENT标志。与之相对的，synchronized、native、strictfp和abstract关键字可以修饰方法，所以方法表的访问标志中增加了ACC_SYNCHRONIZED、ACC_NATIVE、ACC_STRICTFP和ACC_ABSTRACT标志：</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/images/2020/08/08/image-20200808212552101.png" alt="方法访问标志"></p><p>同样根据<a href="#.class">Class</a>文件进行分析。<code>00 03</code>表示 method_count 说明<code>ByteCode</code>类的方法有三个，根据Method_info继续取出第一个方法的 8 个字节<code>00 01 00 07 00 08  00 01</code>，<code>00 01 -&gt; 0</code>表示的是方法的修饰符 表示的是access_flag 为 acc_public，<code>00 07 -&gt; 7</code>表示的是方法的名称(name_index) 指向常量池中#7常量</p><figure class="highlight"><table><tbody><tr><td class="code"><pre><span class="line">#7 = Utf8               &lt;init&gt;</span><br></pre></td></tr></tbody></table></figure><p>表示方法为<code>&lt;init&gt;</code>的构造方法。<code>00 08 -&gt;8</code>代表方法的描述符号（descriptor_index）,指向常量池 #8 常量</p><figure class="highlight"><table><tbody><tr><td class="code"><pre><span class="line">#8 = Utf8               ()V</span><br></pre></td></tr></tbody></table></figure><p>表示的是无参无返回值。<code>00 01 -&gt; 1</code>表示有一个方法属性的个数为 1。</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/images/2020/08/08/10890.png" alt="Method_info.attribute_info"></p><p>根据 attribute_info 结构继续从<a href="#.class">Class</a>文件中取出<code>00 09 00 00 00 2F</code> 。<code>00 09 -&gt; 9</code>表示方法属性名称（attribute_name_index）指向常量池 #9 常量</p><figure class="highlight"><table><tbody><tr><td class="code"><pre><span class="line">#9 = Utf8               Code</span><br></pre></td></tr></tbody></table></figure><p><code>00 00 00 2F -&gt;</code>表示<code>Code</code>属性的长度为 47 个字节。（特别特别需要注意这47个字节从Code属性表中第三个开始也就是max_stack开始，因为此 attribute_info为 Code_attribute 本身，attribute_name_index 和 attribute_length 为 Code 的属性）。</p><p>Code_attribute属性表结构如下：</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">Code_attribute {</span><br><span class="line">    u2 attribute_name_index; <span class="comment">// 属性名索引，常量值固定为"Code"</span></span><br><span class="line">    u4 attribute_length;  <span class="comment">//属性值长度，值为整个表的长度减去6个字节(attribute_name_index + attribute_length)</span></span><br><span class="line">    u2 max_stack; <span class="comment">//操作数栈深度最大值</span></span><br><span class="line">    u2 max_locals; <span class="comment">//局部变量表所需的存储空间，单位为"Slot"，Slot是虚拟机为局部变量分配内存所使用的最小的单位。</span></span><br><span class="line">    u4 code_length; <span class="comment">// 存储Java源程序编译后生成的字节码指令，每个指令为u1类型的单字节。虚拟机规范中明确限制了一个方法不允许超过65535条字节指令，实际上只用了u2长度。</span></span><br><span class="line">    u1 code[code_length]; <span class="comment">// 方法指向的具体指令码</span></span><br><span class="line">    u2 exception_table_length; <span class="comment">// 异常表的个数</span></span><br><span class="line">    {   u2 start_pc; <span class="comment">// start_pc 和 end_pc 表示在 Code 数组中的[start_pc, end_pc)处指令所抛出的异常由这个表处理。</span></span><br><span class="line">        u2 end_pc;</span><br><span class="line">        u2 handler_pc; <span class="comment">// 异常代码的开始处</span></span><br><span class="line">        u2 catch_type; <span class="comment">// 表示被处理流程的异常类型，指向常量池中具体的某一个异常类，catchType为 0 处理所有的异常</span></span><br><span class="line">    } exception_table[exception_table_length]; <span class="comment">// 异常表结构，用于存放异常信息</span></span><br><span class="line">    u2 attributes_count; <span class="comment">// 属性的个数</span></span><br><span class="line">    attribute_info attributes[attributes_count]; <span class="comment">// 属性的集合</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>第一个 Code 的汇编代码如下：</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">         <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">7</span>: <span class="number">0</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">5</span>     <span class="number">0</span>  <span class="keyword">this</span>   Ltech/techstack/blog/ByteCode;</span><br></pre></td></tr></tbody></table></figure><blockquote><p>Tips: args_size=1是因为在任何实例方法里面，都可以通过"this"关键字访问到此方法所属的对象。这个访问机制对Java程序的编写很重要，而它的实现却非常简单，仅仅是通过Javac编译器编译的时候把对this关键字的访问转变为对一个普通方法参数的访问，然后在虚拟机调用实例方法时自动传入此参数而已。因此在实例方法的局部变量表中至少会存在一个指向当前对象实例的局部变量，局部变量表中也会预留出第一个Slot位来存放对象实例的引用，方法参数值从1开始计算。</p></blockquote><p>回到示例代码，取出 47 位 Code 值：</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// _ 是本文自行添加方便表示数据项之间的间隔，Class 文件中是不存在的</span></span><br><span class="line"><span class="number">00</span> <span class="number">01</span>  _00 <span class="number">01</span> _00 <span class="number">00</span> <span class="number">00</span> <span class="number">05</span>  _2A B7 <span class="number">00</span> <span class="number">01</span> B1 _00 <span class="number">00</span>  _00 <span class="number">02</span>  _00 0A  _00 <span class="number">00</span> <span class="number">00</span> <span class="number">06</span>  _00 <span class="number">01</span>  _00 <span class="number">00</span>  _00 <span class="number">06</span>  _00 0B  _00 <span class="number">00</span> <span class="number">00</span> 0C  _00 <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">05</span> <span class="number">00</span> 0C <span class="number">00</span> <span class="number">0D</span> <span class="number">00</span> <span class="number">00</span></span><br></pre></td></tr></tbody></table></figure><p><code>00 01 -&gt; 1</code> 表示 操作数栈（max_stack）的最大深度为 1。后面的<code>00 01 -&gt; 1</code>表示局部变量表的长度(max_locals)为 1，正好与 Code 的汇编代码<code>stack=1</code> <code>locals=1</code>对应。紧接着后面 4 位<code>00 00 00 05 -&gt; 5</code>表示字节码指令长度（code_length）为 5。继续往后数 5 位<code>2A B7 00 01 B1</code>表示 JVM具体的字节码指令。</p><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">0: aload_0</span><br><span class="line">1: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">4: return</span><br></pre></td></tr></tbody></table></figure><blockquote><ol><li><p><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.aload_n">0x2A</a>:对应的字节码注记符是<code>aload_0</code>,作用就是把当前调用方法的栈帧中的局部变量表索引位置为0的局部变量推送到操作数栈的栈顶。</p></li><li><p><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.invokespecial">0xB7</a>:表示是 invokespecial 调用父类的方法 那么后面需要接入二个字节表示调用哪个方法，所以<code>00 01</code>表示的是指向常量池中第一个位置为为如下结构</p><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">1: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V</span><br></pre></td></tr></tbody></table></figure></li><li><p><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.return">0xB1</a>:对应的字节码指令值<code>retrun</code> `表示retrun void from method。</p></li></ol></blockquote><p><code>00 00</code>表示异常表个数（exception_table_length）为 0，方法没有抛出异常。</p><p><code>00 02 -&gt; 2</code>表示 Code_attribute 结构中属性表的个数为 2 个。<code>00 0A -&gt; 10</code>表示 attribute_name_index 指向常量池 #10 <code>LineNumberTable</code> 常量。继续后面 4 位<code>00 00 00 06 -&gt; 10</code> 表示 attribute_length 即 LineNumberTable 的长度。LineNumberTable 是用来描述Java源码行号与字节码行号（字节码偏移量）之间的对应关系，比如我们平时 debug 某一行代码。其结构如下所示：</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">LineNumberTable_attribute {</span><br><span class="line">    u2 attribute_name_index;</span><br><span class="line">    u4 attribute_length;</span><br><span class="line">    u2 line_number_table_length;</span><br><span class="line">    {   u2 start_pc;</span><br><span class="line">        u2 line_number;</span><br><span class="line">    } line_number_table[line_number_table_length];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>00 01 -&gt; 1</code>表示行号表的个数为 1，即只存在一个行号表。<code>00 00</code> 表示start_pc为字节码行号，<code>00 06 -&gt; 6</code>表示源码行号为第 7(6+1) 行。</p><p><code>00 0B -&gt; 11</code>表示第二个属性表对应常量池 #11 <code>LocalVariableTable</code> 常量。<code>00 00 00 0C -&gt; 12</code> 表示 <code>LocalVariableTable</code> 常量的长度为 12。LocalVariableTable 属性用于描述栈帧中局部变量表中的变量与Java源码中定义的变量之间的关系。其结构如下：</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">LocalVariableTable_attribute {</span><br><span class="line">    u2 attribute_name_index;</span><br><span class="line">    u4 attribute_length;</span><br><span class="line">    u2 local_variable_table_length;</span><br><span class="line">    {   u2 start_pc;</span><br><span class="line">        u2 length;</span><br><span class="line">        u2 name_index;</span><br><span class="line">        u2 descriptor_index;</span><br><span class="line">        u2 index;</span><br><span class="line">    } local_variable_table[local_variable_table_length];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>LocalVariableTable也不是运行时必需的属性，但默认会生成到Class文件之中，可以在Javac中分别使用<code>-g:none</code>或<code>-g:vars</code>选项来取消或要求生成这项信息。如果没有生成这项属性，最大的影响就是当其他人引用这个方法时，所有的参数名称都将会丢失，IDE将会使用诸如arg0、arg1之类的占位符代替原有的参数名，这对程序运行没有影响，但是会对代码编写带来较大不便，而且在调试期间无法根据参数名称从上下文中获得参数值。</p><p><code>00 01 -&gt; 1</code>表示本地变量表的个数 local_variable_table_length 为 1。<code>00 00</code>表示local_variable_table 的 start_pc 为 0，其含义为这个局部变量的生命周期开始的字节码偏移量。<code>00 05 -&gt; 5</code> 表示 local_variable_table 的 length 为 5，其含义为这个局部变量作用范围覆盖的长度。两者结合起来就是这个局部变量在字节码之中的作用域范围。<code>00 0C</code> <code>00 0D</code>分别表示 name_index 和 descriptor_index，分别指向常量池中 #12 <code>this</code> 和 #13 <code>Ltech/techstack/blog/ByteCode;</code>常量。分别代表了局部变量的名称以及这个局部变量的描述符。<code>00 00</code> 表示了这个变量在本地变量表中的index 即这个局部变量在栈帧局部变量表中Slot的位置。当这个变量数据类型是64位类型时（double和long），它占用的Slot为index和index+1两个。</p><h4 id="attributes-count-attributes">attributes_count &amp; attributes[]<a class="" href="#attributes-count-attributes"></a></h4><p>属性表（attribute_info）用于描述某些场景专有的信息。在Class文件、字段表、方法表都可以携带自己的属性表集合。所有的属性都具有一下常规格式：</p><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">attribute_info { </span><br><span class="line">    u2 attribute_name_index; </span><br><span class="line">    u4 attribute_length; </span><br><span class="line">    u1 info [attribute_length]; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>根据<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/index.html">The Java® Virtual Machine Specification</a>已经增加到了 23 项。根据其用途可以分为三组：</p><ol><li><p>五个属性对于<code>class</code>Java虚拟机正确解释文件至关重要 ：</p><ul><li><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.7.2">ConstantValue</a></li><li><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.7.3">Code</a></li><li><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.7.4">StackMapTable</a></li><li><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.7.5">Exceptions</a></li><li><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.7.23">BootstrapMethods</a></li></ul></li><li><p>十二个属性对于Java SE平台的类库正确解释<code>class</code>文件至关重要 ：</p><ul><li><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.7.6">InnerClasses</a></li><li><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.7.7">EnclosingMethod</a></li><li><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.7.8">Synthetic</a></li><li><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.7.9">Signature</a></li><li><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.7.16">RuntimeVisibleAnnotations</a></li><li><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.7.17">RuntimeInvisibleAnnotations</a></li><li><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.7.18">RuntimeVisibleParameterAnnotations</a></li><li><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.7.19">RuntimeInvisibleParameterAnnotations</a></li><li><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.7.20">RuntimeVisibleTypeAnnotations</a></li><li><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.7.21">RuntimeInvisibleTypeAnnotations</a></li><li><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.7.22">AnnotationDefault</a></li><li><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.7.24">MethodParameters</a></li></ul></li><li><p>六个属性对于classJava虚拟机或Java SE平台的类库对文件的正确解释不是至关重要的 ，但对于工具来说非常有用：</p><ul><li><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.7.10">SourceFile</a></li><li><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.7.11">SourceDebugExtension</a></li><li><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.7.12">LineNumberTable</a></li><li><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.7.13">LocalVariableTable</a></li><li><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.7.14">LocalVariableTypeTable</a></li><li><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.7.15">Deprecated</a></li></ul></li></ol><h5 id="属性汇总">属性汇总<a class="" href="#属性汇总"></a></h5><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/images/2020/08/09/image-20200809013940538.png" alt="按文件位置排序预定义属性"></p><p>参考：</p><p>[1] 周志明.深入理解Java虚拟机：JVM高级特性与最佳实践.北京:机械工业出版社,2013.</p><p>[2] <a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4">Chapter 4. Th class File Format</a></p><p>[3] <a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5">Chapter 6. The Java Virtual Machine Instruction Set</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM内存结构</title>
      <link href="/post/159683533/"/>
      <url>/post/159683533/</url>
      
        <content type="html"><![CDATA[<p>我们在开发 Java 程序的过程基本不用关心 Java 运行时的内存管理，是因为 Java 程序在运行时内存都由虚拟机来进行管理。Java 虚拟机在执行 Java 程序的过程中会把它所管理的内存划分为若干个不同的数据区域，我们称之为<code>运行时数据区域</code>。</p><h2 id="运行时数据区域">运行时数据区域<a class="" href="#运行时数据区域"></a></h2><p>根据《Java虚拟机规范（Java SE 7版）》的规定，Java虚拟机所管理的内存将会包括以下几个运行时数据区域。</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/images/2020/08/08/JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.png" alt="JVM内存结构"></p><p>我们可以通过不同的几个维度对上图稍作一下分析：</p><ol><li>JVM 内存结构由虚拟机栈、本地方法栈、方法区、堆、程序计数器组成。</li><li>方法区和堆为线程共享内存，虚拟机栈。本地方法栈和程序计数器是线程独享的内存。</li><li>JVM 不同内存区域所占大小不同，其中堆内存最大，程序计数器占内存最小。</li></ol><h3 id="程序计数器（Program-Counter-Register）">程序计数器（Program Counter Register）<a class="" href="#程序计数器（Program-Counter-Register）"></a></h3><p>程序计数器是一块较小的内存空间是，它可以看做是当前线程所执行的字节码的行号指示器。是线程私有的，每条线程都会有一个独立的程序计数器。是为了在多线程情况下，线程切换后能够恢复到正确的执行位置。此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。</p><p>程序计数器在线程执行不同方法时储存的内容会有所不同：如果线程正在执行的是一个 Java 方法，这个计数器记录的是正在执行的虚拟机字节码的内存地址；如果正在执行的是一个 native 方法，这个计数器值则为<strong>未定义（Undefined）</strong>。</p><blockquote><p>Q：Java多线程执行native方法时程序计数器为空，那么线程切换后如何找到之前执行到哪里了？</p><p>A: 对native方法而言，它的方法体并不是由Java字节码构成的，自然无法应用上述的“Java字节码地址”的概念。所以JVM规范规定，如果当前执行的方法是native的，那么pc寄存器的值<strong>未定义</strong>——是什么值都可以。Java线程总是需要以某种形式映射到OS线程上。映射模型可以是1:1（原生线程模型）、n:1（绿色线程 / 用户态线程模型）、m:n（混合模型）。</p><p>以HotSpot VM的实现为例，它目前在大多数平台上都使用1:1模型，也就是每个Java线程都直接映射到一个OS线程上执行。此时，native方法就由原生平台直接执行，并不需要理会抽象的JVM层面上的“pc寄存器”概念——原生的CPU上真正的PC寄存器是怎样就是怎样。就像一个用C或C++写的多线程程序，它在线程切换的时候是怎样的，Java的native方法也就是怎样的。 -Java线程总是需要以某种形式映射到OS线程上。映射模型可以是1:1（原生线程模型）、n:1（绿色线程 / 用户态线程模型）、m:n（混合模型）。</p><p>以HotSpot VM的实现为例，它目前在大多数平台上都使用1:1模型，也就是每个Java线程都直接映射到一个OS线程上执行。此时，native方法就由原生平台直接执行，并不需要理会抽象的JVM层面上的“pc寄存器”概念——原生的CPU上真正的PC寄存器是怎样就是怎样。就像一个用C或C++写的多线程程序，它在线程切换的时候是怎样的，Java的native方法也就是怎样的。 - <a href="https://www.zhihu.com/question/40598119/answer/87381512">RednaxelaFX</a></p></blockquote><h3 id="本地方法栈（Native-Method-Stack）">本地方法栈（Native Method Stack）<a class="" href="#本地方法栈（Native-Method-Stack）"></a></h3><p>本地方法栈是为虚拟机使用到的 Native 方法服务。关于 Native 方法,官方给的说明是""。即在虚拟机规范中对本地方法栈中方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。本地方法栈区域会抛出<code>StackOverflowError</code>和<code>OutOfMemoryError</code>异常</p><blockquote><p>Native Method:</p><p>A native method is a Java method whose implementation is provided by non-java code.</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">double</span> <span class="title">getDouble</span><span class="params">(Object array, <span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function">       <span class="keyword">throws</span> IllegalArgumentException, ArrayIndexOutOfBoundsException</span>;</span><br></pre></td></tr></tbody></table></figure><p>这些方法的声明描述了一些非java代码在这些java代码里看起来像什么样子。</p></blockquote><h3 id="虚拟机栈（VM-Stack）">虚拟机栈（VM Stack）<a class="" href="#虚拟机栈（VM-Stack）"></a></h3><p>Java 虚拟机栈是线程私有的，描述的是 Java 方法执行过程的内存模型：每个方法在执行同时都会创建一个栈帧。每个方法从调用到执行完成的过程，就对应着一个栈帧在虚拟机中入栈到出栈的过程。栈帧中储存局部变量表、操作数栈、动态链接、方法出口等信息。</p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/images/2020/08/image-20200807023603387.png" alt="Java 栈" style="zoom:50%;"><h4 id="局部变量表（Local-Variable-Table）">局部变量表（Local Variable Table）<a class="" href="#局部变量表（Local-Variable-Table）"></a></h4><p>是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量。存放了编译时期可知的各种基本数据类型（<em>boolean、byte、char、short、int、float、long、double</em>）和对象的引用。局部变量表在编译阶段就确定了需要分配的最大容量。</p><p>局部变量表的容量以变量槽（Variable Slot）为最小单位。每个 Slot 都应该能存放一个 boolean、byte、char、short、int、float、reference 或 returnAddress 类型的数据。</p><p>虚拟机通过索引定位的方式使用局部变量表，索引值的范围是从 0 开始至局部变量表最大的 Slot 数量。</p><p>下面我们看一个具体的代码示例：</p><div id="code"></div><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calc</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">200</span>;</span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">300</span>;</span><br><span class="line">    <span class="keyword">return</span> (a + b) * c;</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure><p>上述代码反编译后：</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calc</span><span class="params">()</span></span>;</span><br><span class="line">  descriptor: ()I</span><br><span class="line">  flags: ACC_PUBLIC</span><br><span class="line">  Code:</span><br><span class="line">    stack=<span class="number">2</span>, locals=<span class="number">4</span>, args_size=<span class="number">1</span></span><br><span class="line">       <span class="number">0</span>: bipush        <span class="number">100</span></span><br><span class="line">       <span class="number">2</span>: istore_1</span><br><span class="line">       <span class="number">3</span>: sipush        <span class="number">200</span></span><br><span class="line">       <span class="number">6</span>: istore_2</span><br><span class="line">       <span class="number">7</span>: sipush        <span class="number">300</span></span><br><span class="line">      <span class="number">10</span>: istore_3</span><br><span class="line">      <span class="number">11</span>: iload_1</span><br><span class="line">      <span class="number">12</span>: iload_2</span><br><span class="line">      <span class="number">13</span>: iadd</span><br><span class="line">      <span class="number">14</span>: iload_3</span><br><span class="line">      <span class="number">15</span>: imul</span><br><span class="line">      <span class="number">16</span>: ireturn</span><br><span class="line">    LineNumberTable:</span><br><span class="line">      line <span class="number">10</span>: <span class="number">0</span></span><br><span class="line">      line <span class="number">11</span>: <span class="number">3</span></span><br><span class="line">      line <span class="number">12</span>: <span class="number">7</span></span><br><span class="line">      line <span class="number">13</span>: <span class="number">11</span></span><br><span class="line">    LocalVariableTable:</span><br><span class="line">      Start  Length  Slot  Name   Signature</span><br><span class="line">          <span class="number">0</span>      <span class="number">17</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lai/advance/common/VariableLocal;</span><br><span class="line">          <span class="number">3</span>      <span class="number">14</span>     <span class="number">1</span>     a   I</span><br><span class="line">          <span class="number">7</span>      <span class="number">10</span>     <span class="number">2</span>     b   I</span><br><span class="line">         <span class="number">11</span>       <span class="number">6</span>     <span class="number">3</span>     c   I</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>我们注意到反编译后的代码第五行<code>locals=4</code>就说明了我们我们局部变量表的大小为 4 个 Slot，最下面的<code>LocalVariableTable</code> 展示了局部变量表里面具体的内容。对于实例方法（非 static）局部变量表第 0 位索引的 Slot 默认值实例的引用，也就是我们一直使用的<code>this</code>关键，其余局部变量依次排序。</p><h4 id="操作数栈">操作数栈<a class="" href="#操作数栈"></a></h4><p>操作数栈也称操作栈，它是一个后入先出（Last In First Out,LIFO）栈。同局部变量表一样，操作数栈的最大深度也在编译时期写入到 <code>Code</code>属性中，具体可参考上述<a href="#code">代码示例</a>中反编译后<code>stack=2</code>。</p><p>在一个方法刚开始执行的时候，这个方法的操作数栈是空的，在方法执行过程中，会有各种字节码指令往操作数栈中写入和提取内容，也就是说出栈/入栈操作。</p><h4 id="动态链接">动态链接<a class="" href="#动态链接"></a></h4><p>动态链接是程序在运行期间将字节码中的符号引用转化为直接引用的过程。Class 文件的常量池中有大量的符号引用，字节码中的方法的调用指令调用常量池中存放的字面量符号，而这些字面量符号指向具体的方法。</p><ul><li>部分符号在类加载或者第一次使用的时候就转化为直接引用，这种称之为静态链接。</li><li>部分符号引用在运行期间转化为直接引用,这种转化为<strong>动态链接</strong></li></ul><h4 id="方法返回地址">方法返回地址<a class="" href="#方法返回地址"></a></h4><p>一个方法开始执行后只有两种方式可以退出这个方法。</p><h5 id="正常完成出口（Normal-Method-Invocation-Completion）">正常完成出口（Normal Method Invocation Completion）<a class="" href="#正常完成出口（Normal-Method-Invocation-Completion）"></a></h5><p>执行引擎遇到任意一个方法返回的字节码指令，根据返回指令来决定是否将返回值和返回值的类型传递给上层的方法调用者。</p><p>一般来说，方法正常退出时，调用者的 PC 计数器的值可以作为返回地址，栈帧中很可能会保存这个计数器值。</p><h5 id="异常完成出口（Abrupt-Method-Invocation-Completion）">异常完成出口（Abrupt Method Invocation Completion）<a class="" href="#异常完成出口（Abrupt-Method-Invocation-Completion）"></a></h5><p>在方法执行过程中遇到了异常，并且这个异常没有在方法体内得到处理。异常完成出口的方式是不会给上层调用者产生任何返回值的。</p><p>异常退出时，返回地址是要通过异常处理表来确定的，所以栈帧中一般不会保存这部分信息。</p><h3 id="堆（Heap）">堆（Heap）<a class="" href="#堆（Heap）"></a></h3><p>Java 堆是 Java 虚拟机所管理的内存中最大的一块。堆为所有线程共享的内存区域，在虚拟机启动时创建。堆唯一的目的就是存放对象的实例，几乎所有的对象都在堆内存区域存放。此区域也是发生 OOM 的重灾区。</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/images/post/2020/08/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9oZWxsby5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70-20200807161258296.jpeg" alt="Java 堆"></p><p>堆的内存结构可以划分为<strong>新生代</strong>和<strong>老年代</strong>，默认<code>1:2</code>，其中新生代又被细分为 <code>Eden</code> 和两个个<code>Survivor</code>区域，两个<code>Servivor</code>分别以<code>from</code> <code>to</code> 来进行区分，Eden:from:to 默认为 <code>8：1：1</code>。</p><p><strong>JVM 每次只会使用 Eden 和其中的一块 Survivor 区域来为对象服务，所以无论什么时候，总是有一块 Survivor 区域是空闲着的。</strong></p><h3 id="方法区（Method-Area）">方法区（Method Area）<a class="" href="#方法区（Method-Area）"></a></h3><p>方法区和堆一样，是各个线程共享的内存区域，它用于储存已被虚拟机加载的类信息（InstanceKlass）、常量、静态变量、及时编译期编译后的代码等数据(比如spring 使用IOC或者AOP创建bean时，或者使用cglib，反射的形式动态生成class信息等)。对于方法区的具体实现，会根据不同的 JVM 以及不同的版本而有所区别。在目前已经发布的JDK 1.7的HotSpot中，已经把原本放在永久代的字符串常量池移出。根据Java虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。</p><h4 id="运行时常量池">运行时常量池<a class="" href="#运行时常量池"></a></h4><p>运行时常量池（Runtime Constant Pool）是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用。这部分内容将在类加载后进入方法区的运行时常量池中存放。运行时常量池具备动态性，在运行期间也可以将新的常量放入池中，当常量池无法再申请到内存时会抛出OutOfMemoryError异常。</p><blockquote><p>补充说明：</p><ol><li><p>方法区在逻辑上属于堆的一部分，但是为了与堆进行区分，通常又叫“非堆”（Non-Heap）。</p></li><li><p>永久代（Permanent Generation）：永久带是 Hotspot 虚拟机独有的概念，因为 Hotspot 虚拟机把 GC 分代收集扩展至方法区，或者说用永久代来实现方法区。而对于其他虚拟机（BEA JRockit IBM J9等）是没有永久代的概念的。</p></li><li><p>同样对于 Hotspot 虚拟机在jdk1.6、jdk1.7、jdk1.8 版本对方法区的实现时有所不同的：</p><ol><li>永久带的概念存在小于等于1.7 版本。对于字符串常量池来讲 1.7 以前的版本存放于方法区，1.7版本字符串常量池和类的静态变量存放于堆中，符号引用(Symbols)转移到了native heap。</li><li>1.8 没有了永久带的概念，方法区又元空间（Metaspace）来实现，不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制。</li><li>1.8 元空间在储存内容方面和 1.7 没有发生改变，依然静态变量和字符串常量池在堆内存放，符号引用在 Native Heap 存放，元空间只存放储类和类加载器的元数据信息。只是在内存限制、垃圾回收等机制上改变较大。元空间的出现就是为了解决突出的类和类加载器元数据过多导致的OOM问题。</li></ol></li><li><p>JDK 8 中永久代向元空间的转换</p><ol><li>字符串存在永久代中，容易出现性能问题和内存溢出。</li><li>类及方法的信息等比较难确定其大小，因此对于永久代的大小指定比较困难，太小容易出现永久代溢出，太大则容易导致老年代溢出。</li><li>永久代会为 GC 带来不必要的复杂度，并且回收效率偏低。</li><li>Oracle 可能会将HotSpot 与 JRockit 合二为一。</li></ol></li></ol></blockquote><h2 id="总结">总结<a class="" href="#总结"></a></h2><p>本文只是讲述了一些 JVM 的内存结构，以及不同内存区域的基本概念，对于不同内存区域的参数调整，以及会出现怎么样的异常等内容会专门用一篇文章来讲解。上面我们已经讲明白了JVM 内存区域的划分以及概念，下面根据脑图归纳总结一下：</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/images/2020/08/JVM%20%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84xmid.png" alt="JVM 内存结构xmid"></p><p>参考：</p><p>[1] 周志明.深入理解Java虚拟机：JVM高级特性与最佳实践.北京:机械工业出版社,2013</p><p>[2] <a href="https://www.zhihu.com/people/rednaxelafx">RednaxelaFX</a>.<a href="https://www.zhihu.com/question/40598119/answer/87381512">Java多线程执行native方法时程序计数器为空，那么线程切换后如何找到之前执行到哪里了？</a></p><p>[3] <a href="https://www.zhihu.com/people/rednaxelafx">RednaxelaFX</a>.<a href="https://www.zhihu.com/question/50258991/answer/120450561">JVM符号引用转换直接引用的过程?</a></p><p>[4] <a href="https://juejin.im/user/3368559359568696">secbro2 </a>.<a href="https://juejin.im/post/6844903969349697543">JVM之内存结构详解</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maven-POM</title>
      <link href="/post/164885517/"/>
      <url>/post/164885517/</url>
      
        <content type="html"><![CDATA[<p>POM( Project Object Model，项目对象模型 ) 是 Maven 工程的基本工作单元，是一个XML文件，包含了项目的基本信息，用于描述项目如何构建，声明项目依赖，等等。</p><p>执行任务或目标时，Maven 会在当前目录中查找 POM。它读取 POM，获取所需的配置信息，然后执行目标。</p><p>POM 中可以指定以下配置：</p><ul><li>项目依赖</li><li>插件</li><li>执行目标</li><li>项目构建 profile</li><li>项目版本</li><li>项目开发者列表</li><li>相关邮件列表信息</li></ul><p>在创建 POM 之前，我们首先需要描述项目组 (groupId), 项目的唯一ID。</p><figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span> = <span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span> = <span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span> = <span class="string">"http://maven.apache.org/POM/4.0.0</span></span></span><br><span class="line"><span class="tag"><span class="string">    http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">&lt;!-- 模型版本 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 公司或者组织的唯一标志，并且配置时生成的路径也是由此生成， 如com.companyname.project-group，maven会将该项目打成的jar包放本地路径：/com/companyname/project-group --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.companyname.project-group<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">&lt;!-- 项目的唯一ID，一个groupId下面可能多个项目，就是靠artifactId来区分的 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>project<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">&lt;!-- 版本号 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>所有 POM 文件都需要 project 元素和三个必需字段：groupId，artifactId，version。</p><table><thead><tr><th>节点</th><th>描述</th></tr></thead><tbody><tr><td>project</td><td>工程的根标签。</td></tr><tr><td>modelVersion</td><td>模型版本需要设置为 4.0。</td></tr><tr><td>groupId</td><td>这是工程组的标识。它在一个组织或者项目中通常是唯一的。例如，一个银行组织 com.companyname.project-group 拥有所有的和银行相关的项目。</td></tr><tr><td>artifactId</td><td>这是工程的标识。它通常是工程的名称。例如，消费者银行。groupId 和 artifactId 一起定义了 artifact 在仓库中的位置。</td></tr><tr><td>version</td><td>这是工程的版本号。在 artifact 的仓库中，它用来区分不同的版本</td></tr></tbody></table><p><strong>POM 标签大全详解</strong></p><figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0http://maven.apache.org/maven-v4_0_0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--父项目的坐标。如果项目中没有规定某个元素的值，那么父项目中的对应值即为项目的默认值。 坐标包括group ID，artifact ID和 </span></span><br><span class="line"><span class="comment">        version。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--被继承的父项目的构件标识符 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--被继承的父项目的全球唯一标识符 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--被继承的父项目的版本 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 父项目的pom.xml文件的相对路径。相对路径允许你选择一个不同的路径。默认值是../pom.xml。Maven首先在构建当前项目的地方寻找父项 </span></span><br><span class="line"><span class="comment">            目的pom，其次在文件系统的这个位置（relativePath位置），然后在本地仓库，最后在远程仓库寻找父项目的pom。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--声明项目描述符遵循哪一个POM模型版本。模型本身的版本很少改变，虽然如此，但它仍然是必不可少的，这是为了当Maven引入了新的特性或者其他模型变更的时候，确保稳定性。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--项目的全球唯一标识符，通常使用全限定的包名区分该项目和其他项目。并且构建时生成的路径也是由此生成， 如com.mycompany.app生成的相对路径为：/com/mycompany/app --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>asia.banseon<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 构件的标识符，它和group ID一起唯一标识一个构件。换句话说，你不能有两个不同的项目拥有同样的artifact ID和groupID；在某个 </span></span><br><span class="line"><span class="comment">        特定的group ID下，artifact ID也必须是唯一的。构件是项目产生的或使用的一个东西，Maven为项目产生的构件包括：JARs，源 码，二进制发布和WARs等。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>banseon-maven2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--项目产生的构件类型，例如jar、war、ear、pom。插件可以创建他们自己的构件类型，所以前面列的不是全部构件类型 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--项目当前版本，格式为:主版本.次版本.增量版本-限定版本号 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--项目的名称, Maven产生的文档用 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>banseon-maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--项目主页的URL, Maven产生的文档用 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://www.baidu.com/banseon<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 项目的详细描述, Maven 产生的文档用。 当这个元素能够用HTML格式描述时（例如，CDATA中的文本会被解析器忽略，就可以包含HTML标 </span></span><br><span class="line"><span class="comment">        签）， 不鼓励使用纯文本描述。如果你需要修改产生的web站点的索引页面，你应该修改你自己的索引页文件，而不是调整这里的文档。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>A maven project to study maven.<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--描述了这个项目构建环境中的前提条件。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">prerequisites</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--构建该项目或使用该插件所需要的Maven的最低版本 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">prerequisites</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--项目的问题管理系统(Bugzilla, Jira, Scarab,或任何你喜欢的问题管理系统)的名称和URL，本例为 jira --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">issueManagement</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--问题管理系统（例如jira）的名字， --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">system</span>&gt;</span>jira<span class="tag">&lt;/<span class="name">system</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--该项目使用的问题管理系统的URL --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://jira.baidu.com/banseon<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">issueManagement</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--项目持续集成信息 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ciManagement</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--持续集成系统的名字，例如continuum --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">system</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--该项目使用的持续集成系统的URL（如果持续集成系统有web接口的话）。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--构建完成时，需要通知的开发者/用户的配置项。包括被通知者信息和通知条件（错误，失败，成功，警告） --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">notifiers</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--配置一种方式，当构建中断时，以该方式通知用户/开发者 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">notifier</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--传送通知的途径 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">type</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--发生错误时是否通知 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">sendOnError</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--构建失败时是否通知 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">sendOnFailure</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--构建成功时是否通知 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">sendOnSuccess</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--发生警告时是否通知 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">sendOnWarning</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--不赞成使用。通知发送到哪里 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">address</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--扩展配置项 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">notifier</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">notifiers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ciManagement</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--项目创建年份，4位数字。当产生版权信息时需要使用这个值。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">inceptionYear</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--项目相关邮件列表信息 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mailingLists</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--该元素描述了项目相关的所有邮件列表。自动产生的网站引用这些信息。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mailingList</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--邮件的名称 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>Demo<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--发送邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">post</span>&gt;</span>banseon@126.com<span class="tag">&lt;/<span class="name">post</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--订阅邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">subscribe</span>&gt;</span>banseon@126.com<span class="tag">&lt;/<span class="name">subscribe</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--取消订阅邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">unsubscribe</span>&gt;</span>banseon@126.com<span class="tag">&lt;/<span class="name">unsubscribe</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--你可以浏览邮件信息的URL --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">archive</span>&gt;</span>http:/hi.baidu.com/banseon/demo/dev/<span class="tag">&lt;/<span class="name">archive</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">mailingList</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mailingLists</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--项目开发者列表 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">developers</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--某个项目开发者的信息 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">developer</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--SCM里项目开发者的唯一标识符 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>HELLO WORLD<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--项目开发者的全名 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>banseon<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--项目开发者的email --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">email</span>&gt;</span>banseon@126.com<span class="tag">&lt;/<span class="name">email</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--项目开发者的主页的URL --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span> /&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--项目开发者在项目中扮演的角色，角色元素描述了各种角色 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">roles</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">role</span>&gt;</span>Project Manager<span class="tag">&lt;/<span class="name">role</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">role</span>&gt;</span>Architect<span class="tag">&lt;/<span class="name">role</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">roles</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--项目开发者所属组织 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">organization</span>&gt;</span>demo<span class="tag">&lt;/<span class="name">organization</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--项目开发者所属组织的URL --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">organizationUrl</span>&gt;</span>http://hi.baidu.com/banseon<span class="tag">&lt;/<span class="name">organizationUrl</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--项目开发者属性，如即时消息如何处理等 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">dept</span>&gt;</span>No<span class="tag">&lt;/<span class="name">dept</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--项目开发者所在时区， -11到12范围内的整数。 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">timezone</span>&gt;</span>-5<span class="tag">&lt;/<span class="name">timezone</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">developer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">developers</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--项目的其他贡献者列表 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">contributors</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--项目的其他贡献者。参见developers/developer元素 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">contributor</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">email</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">organization</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">organizationUrl</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">roles</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">timezone</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">properties</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">contributor</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">contributors</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--该元素描述了项目所有License列表。 应该只列出该项目的license列表，不要列出依赖项目的 license列表。如果列出多个license，用户可以选择它们中的一个而不是接受所有license。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">licenses</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--描述了项目的license，用于生成项目的web站点的license页面，其他一些报表和validation也会用到该元素。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">license</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--license用于法律上的名称 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>Apache 2<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--官方的license正文页面的URL --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://www.baidu.com/banseon/LICENSE-2.0.txt<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--项目分发的主要方式： repo，可以从Maven库下载 manual， 用户必须手动下载和安装依赖 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">distribution</span>&gt;</span>repo<span class="tag">&lt;/<span class="name">distribution</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--关于license的补充信息 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">comments</span>&gt;</span>A business-friendly OSS license<span class="tag">&lt;/<span class="name">comments</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">license</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">licenses</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--SCM(Source Control Management)标签允许你配置你的代码库，供Maven web站点和其它插件使用。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scm</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--SCM的URL,该URL描述了版本库和如何连接到版本库。欲知详情，请看SCMs提供的URL格式和列表。该连接只读。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">connection</span>&gt;</span></span><br><span class="line">            scm:svn:http://svn.baidu.com/banseon/maven/banseon/banseon-maven2-trunk(dao-trunk)</span><br><span class="line">        <span class="tag">&lt;/<span class="name">connection</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--给开发者使用的，类似connection元素。即该连接不仅仅只读 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">developerConnection</span>&gt;</span></span><br><span class="line">            scm:svn:http://svn.baidu.com/banseon/maven/banseon/dao-trunk</span><br><span class="line">        <span class="tag">&lt;/<span class="name">developerConnection</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--当前代码的标签，在开发阶段默认为HEAD --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tag</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--指向项目的可浏览SCM库（例如ViewVC或者Fisheye）的URL。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://svn.baidu.com/banseon<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">scm</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--描述项目所属组织的各种属性。Maven产生的文档用 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">organization</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--组织的全名 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>demo<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--组织主页的URL --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://www.baidu.com/banseon<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">organization</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--构建项目需要的信息 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--该元素设置了项目源码目录，当构建项目的时候，构建系统会编译目录里的源码。该路径是相对于pom.xml的相对路径。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sourceDirectory</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--该元素设置了项目脚本源码目录，该目录和源码目录不同：绝大多数情况下，该目录下的内容 会被拷贝到输出目录(因为脚本是被解释的，而不是被编译的)。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scriptSourceDirectory</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--该元素设置了项目单元测试使用的源码目录，当测试项目的时候，构建系统会编译目录里的源码。该路径是相对于pom.xml的相对路径。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">testSourceDirectory</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--被编译过的应用程序class文件存放的目录。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">outputDirectory</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--被编译过的测试class文件存放的目录。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">testOutputDirectory</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--使用来自该项目的一系列构建扩展 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">extensions</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--描述使用到的构建扩展。 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">extension</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--构建扩展的groupId --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--构建扩展的artifactId --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--构建扩展的版本 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">extension</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">extensions</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--当项目没有规定目标（Maven2 叫做阶段）时的默认值 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">defaultGoal</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--这个元素描述了项目相关的所有资源路径列表，例如和项目相关的属性文件，这些资源被包含在最终的打包文件里。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--这个元素描述了项目相关或测试相关的所有资源路径 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 描述了资源的目标路径。该路径相对target/classes目录（例如${project.build.outputDirectory}）。举个例 </span></span><br><span class="line"><span class="comment">                    子，如果你想资源在特定的包里(org.apache.maven.messages)，你就必须该元素设置为org/apache/maven /messages。然而，如果你只是想把资源放到源码目录结构里，就不需要该配置。 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">targetPath</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--是否使用参数值代替参数名。参数值取自properties元素或者文件里配置的属性，文件在filters元素里列出。 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">filtering</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--描述存放资源的目录，该路径相对POM路径 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">directory</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--包含的模式列表，例如**/*.xml. --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">includes</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--排除的模式列表，例如**/*.xml --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">excludes</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--这个元素描述了单元测试相关的所有资源路径，例如和单元测试相关的属性文件。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">testResources</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--这个元素描述了测试相关的所有资源路径，参见build/resources/resource元素的说明 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">testResource</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">targetPath</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">filtering</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">directory</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">includes</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">excludes</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">testResource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">testResources</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--构建产生的所有文件存放的目录 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">directory</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--产生的构件的文件名，默认值是${artifactId}-${version}。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">finalName</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--当filtering开关打开时，使用到的过滤器属性文件列表 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filters</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--子项目可以引用的默认插件信息。该插件配置项直到被引用时才会被解析或绑定到生命周期。给定插件的任何本地配置都会覆盖这里的配置 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">pluginManagement</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--使用的插件列表 。 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--plugin元素包含描述插件所需要的信息。 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--插件在仓库里的group ID --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span> /&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--插件在仓库里的artifact ID --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span> /&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--被使用的插件的版本（或版本范围） --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">version</span> /&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--是否从该插件下载Maven扩展（例如打包和类型处理器），由于性能原因，只有在真需要下载时，该元素才被设置成enabled。 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">extensions</span> /&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--在构建生命周期中执行一组目标的配置。每个目标可能有不同的配置。 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!--execution元素包含了插件执行需要的信息 --&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                            <span class="comment">&lt;!--执行目标的标识符，用于标识构建过程中的目标，或者匹配继承过程中需要合并的执行目标 --&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">id</span> /&gt;</span></span><br><span class="line">                            <span class="comment">&lt;!--绑定了目标的构建生命周期阶段，如果省略，目标会被绑定到源数据里配置的默认阶段 --&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">phase</span> /&gt;</span></span><br><span class="line">                            <span class="comment">&lt;!--配置的执行目标 --&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">goals</span> /&gt;</span></span><br><span class="line">                            <span class="comment">&lt;!--配置是否被传播到子POM --&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">inherited</span> /&gt;</span></span><br><span class="line">                            <span class="comment">&lt;!--作为DOM对象的配置 --&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">configuration</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--项目引入插件所需要的额外依赖 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!--参见dependencies/dependency元素 --&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                            ......</span><br><span class="line">                        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--任何配置是否被传播到子项目 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">inherited</span> /&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--作为DOM对象的配置 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">configuration</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">pluginManagement</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--使用的插件列表 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--参见build/pluginManagement/plugins/plugin元素 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">extensions</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">id</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">phase</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goals</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">inherited</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">configuration</span> /&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--参见dependencies/dependency元素 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                        ......</span><br><span class="line">                    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">goals</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">inherited</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--在列的项目构建profile，如果被激活，会修改构建处理 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--根据环境参数或命令行参数激活某个构建处理 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--构建配置的唯一标识符。即用于命令行激活，也用于在继承时合并具有相同标识符的profile。 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span> /&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--自动触发profile的条件逻辑。Activation是profile的开启钥匙。profile的力量来自于它 能够在某些特定的环境中自动使用某些特定的值；这些环境通过activation元素指定。activation元素并不是激活profile的唯一方式。 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--profile默认是否激活的标志 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">activeByDefault</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--当匹配的jdk被检测到，profile被激活。例如，1.4激活JDK1.4，1.4.0_2，而!1.4激活所有版本不是以1.4开头的JDK。 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">jdk</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--当匹配的操作系统属性被检测到，profile被激活。os元素可以定义一些操作系统相关的属性。 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">os</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--激活profile的操作系统的名字 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">name</span>&gt;</span>Windows XP<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--激活profile的操作系统所属家族(如 'windows') --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">family</span>&gt;</span>Windows<span class="tag">&lt;/<span class="name">family</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--激活profile的操作系统体系结构 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">arch</span>&gt;</span>x86<span class="tag">&lt;/<span class="name">arch</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--激活profile的操作系统版本 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.2600<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">os</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--如果Maven检测到某一个属性（其值可以在POM中通过${名称}引用），其拥有对应的名称和值，Profile就会被激活。如果值 字段是空的，那么存在属性名称字段就会激活profile，否则按区分大小写方式匹配属性值字段 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--激活profile的属性的名称 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">name</span>&gt;</span>mavenVersion<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--激活profile的属性的值 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">value</span>&gt;</span>2.0.3<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--提供一个文件名，通过检测该文件的存在或不存在来激活profile。missing检查文件是否存在，如果不存在则激活 profile。另一方面，exists则会检查文件是否存在，如果存在则激活profile。 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">file</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--如果指定的文件存在，则激活profile。 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">exists</span>&gt;</span>/usr/local/hudson/hudson-home/jobs/maven-guide-zh-to-production/workspace/</span><br><span class="line">                    <span class="tag">&lt;/<span class="name">exists</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--如果指定的文件不存在，则激活profile。 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">missing</span>&gt;</span>/usr/local/hudson/hudson-home/jobs/maven-guide-zh-to-production/workspace/</span><br><span class="line">                    <span class="tag">&lt;/<span class="name">missing</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--构建项目所需要的信息。参见build元素 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">defaultGoal</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">targetPath</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">filtering</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">directory</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">includes</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">excludes</span> /&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">testResources</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">testResource</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">targetPath</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">filtering</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">directory</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">includes</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">excludes</span> /&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">testResource</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">testResources</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">directory</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">finalName</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">filters</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">pluginManagement</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!--参见build/pluginManagement/plugins/plugin元素 --&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">groupId</span> /&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">artifactId</span> /&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">version</span> /&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">extensions</span> /&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">id</span> /&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">phase</span> /&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">goals</span> /&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">inherited</span> /&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">configuration</span> /&gt;</span></span><br><span class="line">                                <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">                                <span class="comment">&lt;!--参见dependencies/dependency元素 --&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                                    ......</span><br><span class="line">                                <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">goals</span> /&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">inherited</span> /&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">configuration</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">pluginManagement</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--参见build/pluginManagement/plugins/plugin元素 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">groupId</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">artifactId</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">version</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">extensions</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">id</span> /&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">phase</span> /&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">goals</span> /&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">inherited</span> /&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">configuration</span> /&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">                            <span class="comment">&lt;!--参见dependencies/dependency元素 --&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                                ......</span><br><span class="line">                            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goals</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">inherited</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">configuration</span> /&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--模块（有时称作子项目） 被构建成项目的一部分。列出的每个模块元素是指向该模块的目录的相对路径 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">modules</span> /&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--发现依赖和扩展的远程仓库列表。 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--参见repositories/repository元素 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">enabled</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">updatePolicy</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">checksumPolicy</span> /&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">enabled</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">updatePolicy</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">checksumPolicy</span> /&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">id</span> /&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">name</span> /&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">url</span> /&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">layout</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--发现插件的远程仓库列表，这些插件用于构建和报表 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pluginRepositories</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--包含需要连接到远程插件仓库的信息.参见repositories/repository元素 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">pluginRepository</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">enabled</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">updatePolicy</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">checksumPolicy</span> /&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">enabled</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">updatePolicy</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">checksumPolicy</span> /&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">id</span> /&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">name</span> /&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">url</span> /&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">layout</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">pluginRepository</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">pluginRepositories</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--该元素描述了项目相关的所有依赖。 这些依赖组成了项目构建过程中的一个个环节。它们自动从项目定义的仓库中下载。要获取更多信息，请看项目依赖机制。 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--参见dependencies/dependency元素 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                    ......</span><br><span class="line">                <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--不赞成使用. 现在Maven忽略该元素. --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">reports</span> /&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--该元素包括使用报表插件产生报表的规范。当用户执行"mvn site"，这些报表就会运行。 在页面导航栏能看到所有报表的链接。参见reporting元素 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">reporting</span>&gt;</span></span><br><span class="line">                ......</span><br><span class="line">            <span class="tag">&lt;/<span class="name">reporting</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--参见dependencyManagement元素 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--参见dependencies/dependency元素 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                        ......</span><br><span class="line">                    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--参见distributionManagement元素 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">distributionManagement</span>&gt;</span></span><br><span class="line">                ......</span><br><span class="line">            <span class="tag">&lt;/<span class="name">distributionManagement</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--参见properties元素 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">properties</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--模块（有时称作子项目） 被构建成项目的一部分。列出的每个模块元素是指向该模块的目录的相对路径 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modules</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--发现依赖和扩展的远程仓库列表。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--包含需要连接到远程仓库的信息 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--如何处理远程仓库里发布版本的下载 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--true或者false表示该仓库是否为下载某种类型构件（发布版，快照版）开启。 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">enabled</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--该元素指定更新发生的频率。Maven会比较本地POM和远程POM的时间戳。这里的选项是：always（一直），daily（默认，每日），interval：X（这里X是以分钟为单位的时间间隔），或者never（从不）。 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">updatePolicy</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--当Maven验证构件校验文件失败时该怎么做：ignore（忽略），fail（失败），或者warn（警告）。 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">checksumPolicy</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 如何处理远程仓库里快照版本的下载。有了releases和snapshots这两组配置，POM就可以在每个单独的仓库中，为每种类型的构件采取不同的 </span></span><br><span class="line"><span class="comment">                策略。例如，可能有人会决定只为开发目的开启对快照版本下载的支持。参见repositories/repository/releases元素 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">enabled</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">updatePolicy</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">checksumPolicy</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--远程仓库唯一标识符。可以用来匹配在settings.xml文件里配置的远程仓库 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>banseon-repository-proxy<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--远程仓库名称 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>banseon-repository-proxy<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--远程仓库URL，按protocol://hostname/path形式 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://192.168.1.169:9999/repository/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 用于定位和排序构件的仓库布局类型-可以是default（默认）或者legacy（遗留）。Maven 2为其仓库提供了一个默认的布局；然 </span></span><br><span class="line"><span class="comment">                而，Maven 1.x有一种不同的布局。我们可以使用该元素指定布局是default（默认）还是legacy（遗留）。 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">layout</span>&gt;</span>default<span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--发现插件的远程仓库列表，这些插件用于构建和报表 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">pluginRepositories</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--包含需要连接到远程插件仓库的信息.参见repositories/repository元素 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">pluginRepository</span>&gt;</span></span><br><span class="line">            ......</span><br><span class="line">        <span class="tag">&lt;/<span class="name">pluginRepository</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">pluginRepositories</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="comment">&lt;!--该元素描述了项目相关的所有依赖。 这些依赖组成了项目构建过程中的一个个环节。它们自动从项目定义的仓库中下载。要获取更多信息，请看项目依赖机制。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--依赖的group ID --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--依赖的artifact ID --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-artifact<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--依赖的版本号。 在Maven 2里, 也可以配置成版本号的范围。 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 依赖类型，默认类型是jar。它通常表示依赖的文件的扩展名，但也有例外。一个类型可以被映射成另外一个扩展名或分类器。类型经常和使用的打包方式对应， </span></span><br><span class="line"><span class="comment">                尽管这也有例外。一些类型的例子：jar，war，ejb-client和test-jar。如果设置extensions为 true，就可以在 plugin里定义新的类型。所以前面的类型的例子不完整。 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 依赖的分类器。分类器可以区分属于同一个POM，但不同构建方式的构件。分类器名被附加到文件名的版本号后面。例如，如果你想要构建两个单独的构件成 </span></span><br><span class="line"><span class="comment">                JAR，一个使用Java 1.4编译器，另一个使用Java 6编译器，你就可以使用分类器来生成两个单独的JAR构件。 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">classifier</span>&gt;</span><span class="tag">&lt;/<span class="name">classifier</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--依赖范围。在项目发布过程中，帮助决定哪些构件被包括进来。欲知详情请参考依赖机制。 - compile ：默认范围，用于编译 - provided：类似于编译，但支持你期待jdk或者容器提供，类似于classpath </span></span><br><span class="line"><span class="comment">                - runtime: 在执行时需要使用 - test: 用于test任务时使用 - system: 需要外在提供相应的元素。通过systemPath来取得 </span></span><br><span class="line"><span class="comment">                - systemPath: 仅用于范围为system。提供相应的路径 - optional: 当项目自身被依赖时，标注依赖是否传递。用于连续依赖时使用 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--仅供system范围使用。注意，不鼓励使用这个元素，并且在新的版本中该元素可能被覆盖掉。该元素为依赖规定了文件系统上的路径。需要绝对路径而不是相对路径。推荐使用属性匹配绝对路径，例如${java.home}。 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">systemPath</span>&gt;</span><span class="tag">&lt;/<span class="name">systemPath</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--当计算传递依赖时， 从依赖构件列表里，列出被排除的依赖构件集。即告诉maven你只依赖指定的项目，不依赖项目的依赖。此元素主要用于解决版本冲突问题 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--可选依赖，如果你在项目B中把C依赖声明为可选，你就需要在依赖于B的项目（例如项目A）中显式的引用对C的依赖。可选依赖阻断依赖的传递性。 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--不赞成使用. 现在Maven忽略该元素. --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">reports</span>&gt;</span><span class="tag">&lt;/<span class="name">reports</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--该元素描述使用报表插件产生报表的规范。当用户执行"mvn site"，这些报表就会运行。 在页面导航栏能看到所有报表的链接。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">reporting</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--true，则，网站不包括默认的报表。这包括"项目信息"菜单中的报表。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">excludeDefaults</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--所有产生的报表存放到哪里。默认值是${project.build.directory}/site。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">outputDirectory</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--使用的报表插件和他们的配置。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--plugin元素包含描述报表插件需要的信息 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--报表插件在仓库里的group ID --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--报表插件在仓库里的artifact ID --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--被使用的报表插件的版本（或版本范围） --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--任何配置是否被传播到子项目 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">inherited</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--报表插件的配置 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--一组报表的多重规范，每个规范可能有不同的配置。一个规范（报表集）对应一个执行目标 。例如，有1，2，3，4，5，6，7，8，9个报表。1，2，5构成A报表集，对应一个执行目标。2，5，8构成B报表集，对应另一个执行目标 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">reportSets</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--表示报表的一个集合，以及产生该集合的配置 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">reportSet</span>&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!--报表集合的唯一标识符，POM继承时用到 --&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">id</span> /&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!--产生报表集合时，被使用的报表的配置 --&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">configuration</span> /&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!--配置是否被继承到子POMs --&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">inherited</span> /&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!--这个集合里使用到哪些报表 --&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">reports</span> /&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">reportSet</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">reportSets</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">reporting</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 继承自该项目的所有子项目的默认依赖信息。这部分的依赖信息不会被立即解析,而是当子项目声明一个依赖（必须描述group ID和 artifact </span></span><br><span class="line"><span class="comment">        ID信息），如果group ID和artifact ID以外的一些信息没有描述，则通过group ID和artifact ID 匹配到这里的依赖，并使用这里的依赖信息。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--参见dependencies/dependency元素 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                ......</span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--项目分发信息，在执行mvn deploy后表示要发布的位置。有了这些信息就可以把网站部署到远程服务器或者把构件部署到远程仓库。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">distributionManagement</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--部署项目产生的构件到远程仓库需要的信息 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--是分配给快照一个唯一的版本号（由时间戳和构建流水号）？还是每次都使用相同的版本号？参见repositories/repository元素 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">uniqueVersion</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>banseon-maven2<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>banseon maven2<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>file://${basedir}/target/deploy<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">layout</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--构件的快照部署到哪里？如果没有配置该元素，默认部署到repository元素配置的仓库，参见distributionManagement/repository元素 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">snapshotRepository</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">uniqueVersion</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>banseon-maven2<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>Banseon-maven2 Snapshot Repository<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>scp://svn.baidu.com/banseon:/usr/local/maven-snapshot<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">layout</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">snapshotRepository</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--部署项目的网站需要的信息 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">site</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--部署位置的唯一标识符，用来匹配站点和settings.xml文件里的配置 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>banseon-site<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--部署位置的名称 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>business api website<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--部署位置的URL，按protocol://hostname/path形式 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span></span><br><span class="line">                scp://svn.baidu.com/banseon:/var/www/localhost/banseon-web</span><br><span class="line">            <span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">site</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--项目下载页面的URL。如果没有该元素，用户应该参考主页。使用该元素的原因是：帮助定位那些不在仓库里的构件（由于license限制）。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">downloadUrl</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--如果构件有了新的group ID和artifact ID（构件移到了新的位置），这里列出构件的重定位信息。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relocation</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--构件新的group ID --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span> /&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--构件新的artifact ID --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span> /&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--构件新的版本号 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span> /&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--显示给用户的，关于移动的额外信息，例如原因。 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">message</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">relocation</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 给出该构件在远程仓库的状态。不得在本地项目中设置该元素，因为这是工具自动更新的。有效的值有：none（默认），converted（仓库管理员从 </span></span><br><span class="line"><span class="comment">            Maven 1 POM转换过来），partner（直接从伙伴Maven 2仓库同步过来），deployed（从Maven 2实例部 署），verified（被核实时正确的和最终的）。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">status</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">distributionManagement</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--以值替代名称，Properties可以在整个POM中使用，也可以作为触发条件（见settings.xml配置文件里activation元素的说明）。格式是&lt;name&gt;value&lt;/name&gt;。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Maven </category>
          
      </categories>
      
      
        <tags>
            
            <tag> maven </tag>
            
            <tag> idea </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maven-Idea查看解决jar包冲突</title>
      <link href="/post/164885513/"/>
      <url>/post/164885513/</url>
      
        <content type="html"><![CDATA[<p>在实际项目开发过程中，会引用很多的依赖，由于依赖本身也有依赖，如果使用了不同的版本，就会很容易遇到jar包冲突问题，因此，解决jar包冲突问题就显得尤为重要。</p><p>本文主要利用图文讲述IDEA解决办法<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/images/post/2020/08/1240-20200803141607506.png" alt="maven">1.选择<code>Maven Project</code>2.选中<code>Dependencies</code>3.点击 <code>Show Dependencies</code></p><p>效果如下图所示<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/images/post/2020/08/1240-20200803141619378.png" alt="image.png">如果显示太小看不清楚，右键选择下图所示<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/images/post/2020/08/1240-20200803141634662.png" alt="放大">放大后<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/images/post/2020/08/1240-20200803141647033.png" alt="image.png"></p><p>如果我们仔细观察上图，会发现在项目依赖图中，有一些红色标记的线，实际上，这些红色标记出来的线所指向的 jar 包，就是项目中冲突的 jar 包！且在我们点击 jar 包之后，还会显示出多条指向 jar 包的红色虚线，其代表着该 jar 包被多次引用，及具体引用路径。如上图所示，想要排除冲突的 jar 包，其方法为：点击冲突的 jar 包，右键呼出菜单栏，点击Exclude选项。<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/images/post/2020/08/1240-20200803141709839.png" alt="排除jar包">如下图所示，在排除冲突的 jar 包之后，pom.xml文件会自动更新，添加排除语句。<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/images/post/2020/08/1240-20200803141721952.png" alt=""></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Maven </category>
          
      </categories>
      
      
        <tags>
            
            <tag> maven </tag>
            
            <tag> idea </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maven-插件</title>
      <link href="/post/164885524/"/>
      <url>/post/164885524/</url>
      
        <content type="html"><![CDATA[<p>Maven本质上是一个插件框架，它的核心并不执行任何具体的构建任务，所有这些任务都交给插件来完成。<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/images/2020/08/1240.png" alt="概念模型"></p><p>Maven 有以下三个标准的生命周期：</p><ul><li>**clean：**项目清理的处理</li><li>**default(或 build)：**项目部署的处理</li><li>**site：**项目站点文档创建的处理</li></ul><p>每个生命周期中都包含着一系列的阶段(phase)。这些 phase 就相当于 Maven 提供的统一的接口，然后这些 phase 的实现由 Maven 的插件来完成。认识上述Maven插件的基本概念能帮助你理解Maven的工作机制，不过要想更高效率地使用Maven，了解一些常用的插件还是很有必要的，这可以帮助你避免一不小心重新发明轮子。多年来Maven社区积累了大量的经验，并随之形成了一个成熟的插件生态圈。</p><p>Maven官方有两个插件列表：</p><ul><li>http://maven.apache.org/plugins/index.html。</li><li>http://mojo.codehaus.org/plugins.html。</li></ul><p>我们在输入 <code>mvn</code> 命令的时候 比如 <code>mvn clean</code>，<code>clean</code> 对应的就是 Clean 生命周期中的 clean 阶段。但是 clean 的具体操作是由 <code>maven-clean-plugin</code> 来实现的。</p><p>所以说 Maven 生命周期的每一个阶段的具体实现都是由 Maven 插件实现的。</p><p>Maven 实际上是一个依赖插件执行的框架，每个任务实际上是由插件完成。Maven 插件通常被用来：</p><ul><li>创建 jar 文件</li><li>创建 war 文件</li><li>编译代码文件</li><li>代码单元测试</li><li>创建工程文档</li><li>创建工程报告插件通常提供了一个目标的集合，并且可以使用下面的语法执行：</li></ul><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">mvn [plugin-name]:[goal-name]</span><br></pre></td></tr></tbody></table></figure><p>例如，一个 Java 工程可以使用 <code>maven-compiler-plugin</code> 的 <code>compile-goal</code> 编译，使用以下命令：</p><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">mvn compiler:compile</span><br></pre></td></tr></tbody></table></figure><p>Maven 提供了下面两种类型的插件：</p><table><thead><tr><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>Build plugins</td><td>在构建时执行，并在 pom.xml 的 元素中配置。</td></tr><tr><td>Reporting plugins</td><td>在网站生成过程中执行，并在 pom.xml 的 元素中配置。</td></tr></tbody></table><p>下面是一些常用插件的列表：</p><table><thead><tr><th>插件</th><th>描述</th></tr></thead><tbody><tr><td>clean</td><td>构建之后清理目标文件。删除目标目录。</td></tr><tr><td>compiler</td><td>编译 Java 源文件。</td></tr><tr><td>surefile</td><td>运行 JUnit 单元测试。创建测试报告。</td></tr><tr><td>jar</td><td>从当前工程中构建 JAR 文件。</td></tr><tr><td>war</td><td>从当前工程中构建 WAR 文件。</td></tr><tr><td>javadoc</td><td>为工程生成 Javadoc。</td></tr><tr><td>antrun</td><td>从构建过程的任意一个阶段中运行一个 ant 任务的集合。</td></tr></tbody></table><p>除了这些核心插件之外，还有很多优秀的第三方插件，可以帮助我们快捷、方便的构架项目。当使用到某些功能或者特性的时候多加搜索，往往得到让你惊喜的效果。例如，项目中使用了*<code>Mybatis</code><em>，就有一款神奇的maven插件，运行一个命令，就可以根据数据库的表，自动生成</em><code>Mybatis</code>*的<code>mapper</code>配置文件以及DAO层接口模板。在<code>pom.xml</code>中添加<code>plugin</code>：</p><figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.generator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-generator-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">configurationFile</span>&gt;</span>src/main/resources/mybatis-generator/generatorConfig.xml<span class="tag">&lt;/<span class="name">configurationFile</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">verbose</span>&gt;</span>true<span class="tag">&lt;/<span class="name">verbose</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">overwrite</span>&gt;</span>true<span class="tag">&lt;/<span class="name">overwrite</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">id</span>&gt;</span>Generate MyBatis Artifacts<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">goal</span>&gt;</span>generate<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.generator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-generator-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>定义<code>generatorConfig.xml</code></p><figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">generatorConfiguration</span></span></span><br><span class="line"><span class="meta">  <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN"</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">"http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置生成器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">generatorConfiguration</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 可以用于加载配置项或者配置文件，在整个配置文件中就可以使用${propertyKey}的方式来引用配置项</span></span><br><span class="line"><span class="comment">    resource：配置资源加载地址，使用resource，MBG从classpath开始找，比如com/myproject/generatorConfig.properties        </span></span><br><span class="line"><span class="comment">    url：配置资源加载地质，使用URL的方式，比如file:///C:/myfolder/generatorConfig.properties.</span></span><br><span class="line"><span class="comment">    注意，两个属性只能选址一个;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    另外，如果使用了mybatis-select-maven-plugin，那么在pom.xml中定义的properties都可以直接在generatorConfig.xml中使用</span></span><br><span class="line"><span class="comment">&lt;properties resource="" url="" /&gt;</span></span><br><span class="line"><span class="comment"> --&gt;</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">&lt;!-- 在MBG工作的时候，需要额外加载的依赖包</span></span><br><span class="line"><span class="comment">     location属性指明加载jar/zip包的全路径</span></span><br><span class="line"><span class="comment">&lt;classPathEntry location="/Program Files/IBM/SQLLIB/java/db2java.zip" /&gt;</span></span><br><span class="line"><span class="comment">  --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">    context:生成一组对象的环境 </span></span><br><span class="line"><span class="comment">    id:必选，上下文id，用于在生成错误时提示</span></span><br><span class="line"><span class="comment">    defaultModelType:指定生成对象的样式</span></span><br><span class="line"><span class="comment">        1，conditional：类似hierarchical；</span></span><br><span class="line"><span class="comment">        2，flat：所有内容（主键，blob）等全部生成在一个对象中；</span></span><br><span class="line"><span class="comment">        3，hierarchical：主键生成一个XXKey对象(key class)，Blob等单独生成一个对象，其他简单属性在一个对象中(record class)</span></span><br><span class="line"><span class="comment">    targetRuntime:</span></span><br><span class="line"><span class="comment">        1，MyBatis3：默认的值，生成基于MyBatis3.x以上版本的内容，包括XXXBySample；</span></span><br><span class="line"><span class="comment">        2，MyBatis3Simple：类似MyBatis3，只是不生成XXXBySample；</span></span><br><span class="line"><span class="comment">    introspectedColumnImpl：类全限定名，用于扩展MBG</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context</span> <span class="attr">id</span>=<span class="string">"mysql"</span> <span class="attr">defaultModelType</span>=<span class="string">"hierarchical"</span> <span class="attr">targetRuntime</span>=<span class="string">"MyBatis3Simple"</span> &gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 自动识别数据库关键字，默认false，如果设置为true，根据SqlReservedWords中定义的关键字列表；</span></span><br><span class="line"><span class="comment">        一般保留默认值，遇到数据库关键字（Java关键字），使用columnOverride覆盖</span></span><br><span class="line"><span class="comment">     --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"autoDelimitKeywords"</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 生成的Java文件的编码 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"javaFileEncoding"</span> <span class="attr">value</span>=<span class="string">"UTF-8"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 格式化java代码 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"javaFormatter"</span> <span class="attr">value</span>=<span class="string">"org.mybatis.generator.api.dom.DefaultJavaFormatter"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 格式化XML代码 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"xmlFormatter"</span> <span class="attr">value</span>=<span class="string">"org.mybatis.generator.api.dom.DefaultXmlFormatter"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- beginningDelimiter和endingDelimiter：指明数据库的用于标记数据库对象名的符号，比如ORACLE就是双引号，MYSQL默认是`反引号； --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"beginningDelimiter"</span> <span class="attr">value</span>=<span class="string">"`"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"endingDelimiter"</span> <span class="attr">value</span>=<span class="string">"`"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 必须要有的，使用这个配置链接数据库</span></span><br><span class="line"><span class="comment">        @<span class="doctag">TODO:</span>是否可以扩展</span></span><br><span class="line"><span class="comment">     --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">jdbcConnection</span> <span class="attr">driverClass</span>=<span class="string">"com.mysql.jdbc.Driver"</span> <span class="attr">connectionURL</span>=<span class="string">"jdbc:mysql:///pss"</span> <span class="attr">userId</span>=<span class="string">"root"</span> <span class="attr">password</span>=<span class="string">"admin"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 这里面可以设置property属性，每一个property属性都设置到配置的Driver上 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">jdbcConnection</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- java类型处理器 </span></span><br><span class="line"><span class="comment">        用于处理DB中的类型到Java中的类型，默认使用JavaTypeResolverDefaultImpl；</span></span><br><span class="line"><span class="comment">        注意一点，默认会先尝试使用Integer，Long，Short等来对应DECIMAL和 NUMERIC数据类型； </span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">javaTypeResolver</span> <span class="attr">type</span>=<span class="string">"org.mybatis.generator.internal.types.JavaTypeResolverDefaultImpl"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">            true：使用BigDecimal对应DECIMAL和 NUMERIC数据类型</span></span><br><span class="line"><span class="comment">            false：默认,</span></span><br><span class="line"><span class="comment">                scale&gt;0;length&gt;18：使用BigDecimal;</span></span><br><span class="line"><span class="comment">                scale=0;length[10,18]：使用Long；</span></span><br><span class="line"><span class="comment">                scale=0;length[5,9]：使用Integer；</span></span><br><span class="line"><span class="comment">                scale=0;length&lt;5：使用Short；</span></span><br><span class="line"><span class="comment">         --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"forceBigDecimals"</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">javaTypeResolver</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- java模型创建器，是必须要的元素</span></span><br><span class="line"><span class="comment">        负责：1，key类（见context的defaultModelType）；2，java类；3，查询类</span></span><br><span class="line"><span class="comment">        targetPackage：生成的类要放的包，真实的包受enableSubPackages属性控制；</span></span><br><span class="line"><span class="comment">        targetProject：目标项目，指定一个存在的目录下，生成的内容会放到指定目录中，如果目录不存在，MBG不会自动建目录</span></span><br><span class="line"><span class="comment">     --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">javaModelGenerator</span> <span class="attr">targetPackage</span>=<span class="string">"com._520it.mybatis.domain"</span> <span class="attr">targetProject</span>=<span class="string">"src/main/java"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--  for MyBatis3/MyBatis3Simple</span></span><br><span class="line"><span class="comment">            自动为每一个生成的类创建一个构造方法，构造方法包含了所有的field；而不是使用setter；</span></span><br><span class="line"><span class="comment">         --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"constructorBased"</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 在targetPackage的基础上，根据数据库的schema再生成一层package，最终生成的类放在这个package下，默认为false --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"enableSubPackages"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- for MyBatis3 / MyBatis3Simple</span></span><br><span class="line"><span class="comment">            是否创建一个不可变的类，如果为true，</span></span><br><span class="line"><span class="comment">            那么MBG会创建一个没有setter方法的类，取而代之的是类似constructorBased的类</span></span><br><span class="line"><span class="comment">         --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"immutable"</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 设置一个根对象，</span></span><br><span class="line"><span class="comment">            如果设置了这个根对象，那么生成的keyClass或者recordClass会继承这个类；在Table的rootClass属性中可以覆盖该选项</span></span><br><span class="line"><span class="comment">            注意：如果在key class或者record class中有root class相同的属性，MBG就不会重新生成这些属性了，包括：</span></span><br><span class="line"><span class="comment">                1，属性名相同，类型相同，有相同的getter/setter方法；</span></span><br><span class="line"><span class="comment">         --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"rootClass"</span> <span class="attr">value</span>=<span class="string">"com._520it.mybatis.domain.BaseDomain"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 设置是否在getter方法中，对String类型字段调用trim()方法 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"trimStrings"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">javaModelGenerator</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 生成SQL map的XML文件生成器，</span></span><br><span class="line"><span class="comment">        注意，在Mybatis3之后，我们可以使用mapper.xml文件+Mapper接口（或者不用mapper接口），</span></span><br><span class="line"><span class="comment">            或者只使用Mapper接口+Annotation，所以，如果 javaClientGenerator配置中配置了需要生成XML的话，这个元素就必须配置</span></span><br><span class="line"><span class="comment">        targetPackage/targetProject:同javaModelGenerator</span></span><br><span class="line"><span class="comment">     --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sqlMapGenerator</span> <span class="attr">targetPackage</span>=<span class="string">"com._520it.mybatis.mapper"</span> <span class="attr">targetProject</span>=<span class="string">"src/main/resources"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 在targetPackage的基础上，根据数据库的schema再生成一层package，最终生成的类放在这个package下，默认为false --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"enableSubPackages"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">sqlMapGenerator</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 对于mybatis来说，即生成Mapper接口，注意，如果没有配置该元素，那么默认不会生成Mapper接口 </span></span><br><span class="line"><span class="comment">        targetPackage/targetProject:同javaModelGenerator</span></span><br><span class="line"><span class="comment">        type：选择怎么生成mapper接口（在MyBatis3/MyBatis3Simple下）：</span></span><br><span class="line"><span class="comment">            1，ANNOTATEDMAPPER：会生成使用Mapper接口+Annotation的方式创建（SQL生成在annotation中），不会生成对应的XML；</span></span><br><span class="line"><span class="comment">            2，MIXEDMAPPER：使用混合配置，会生成Mapper接口，并适当添加合适的Annotation，但是XML会生成在XML中；</span></span><br><span class="line"><span class="comment">            3，XMLMAPPER：会生成Mapper接口，接口完全依赖XML；</span></span><br><span class="line"><span class="comment">        注意，如果context是MyBatis3Simple：只支持ANNOTATEDMAPPER和XMLMAPPER</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">javaClientGenerator</span> <span class="attr">targetPackage</span>=<span class="string">"com._520it.mybatis.mapper"</span> <span class="attr">type</span>=<span class="string">"ANNOTATEDMAPPER"</span> <span class="attr">targetProject</span>=<span class="string">"src/main/java"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 在targetPackage的基础上，根据数据库的schema再生成一层package，最终生成的类放在这个package下，默认为false --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"enableSubPackages"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 可以为所有生成的接口添加一个父接口，但是MBG只负责生成，不负责检查</span></span><br><span class="line"><span class="comment">        &lt;property name="rootInterface" value=""/&gt;</span></span><br><span class="line"><span class="comment">         --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">javaClientGenerator</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 选择一个table来生成相关文件，可以有一个或多个table，必须要有table元素</span></span><br><span class="line"><span class="comment">        选择的table会生成一下文件：</span></span><br><span class="line"><span class="comment">        1，SQL map文件</span></span><br><span class="line"><span class="comment">        2，生成一个主键类；</span></span><br><span class="line"><span class="comment">        3，除了BLOB和主键的其他字段的类；</span></span><br><span class="line"><span class="comment">        4，包含BLOB的类；</span></span><br><span class="line"><span class="comment">        5，一个用户生成动态查询的条件类（selectByExample, deleteByExample），可选；</span></span><br><span class="line"><span class="comment">        6，Mapper接口（可选）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        tableName（必要）：要生成对象的表名；</span></span><br><span class="line"><span class="comment">        注意：大小写敏感问题。正常情况下，MBG会自动的去识别数据库标识符的大小写敏感度，在一般情况下，MBG会</span></span><br><span class="line"><span class="comment">            根据设置的schema，catalog或tablename去查询数据表，按照下面的流程：</span></span><br><span class="line"><span class="comment">            1，如果schema，catalog或tablename中有空格，那么设置的是什么格式，就精确的使用指定的大小写格式去查询；</span></span><br><span class="line"><span class="comment">            2，否则，如果数据库的标识符使用大写的，那么MBG自动把表名变成大写再查找；</span></span><br><span class="line"><span class="comment">            3，否则，如果数据库的标识符使用小写的，那么MBG自动把表名变成小写再查找；</span></span><br><span class="line"><span class="comment">            4，否则，使用指定的大小写格式查询；</span></span><br><span class="line"><span class="comment">        另外的，如果在创建表的时候，使用的""把数据库对象规定大小写，就算数据库标识符是使用的大写，在这种情况下也会使用给定的大小写来创建表名；</span></span><br><span class="line"><span class="comment">        这个时候，请设置delimitIdentifiers="true"即可保留大小写格式；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        可选：</span></span><br><span class="line"><span class="comment">        1，schema：数据库的schema；</span></span><br><span class="line"><span class="comment">        2，catalog：数据库的catalog；</span></span><br><span class="line"><span class="comment">        3，alias：为数据表设置的别名，如果设置了alias，那么生成的所有的SELECT SQL语句中，列名会变成：alias_actualColumnName</span></span><br><span class="line"><span class="comment">        4，domainObjectName：生成的domain类的名字，如果不设置，直接使用表名作为domain类的名字；可以设置为somepck.domainName，那么会自动把domainName类再放到somepck包里面；</span></span><br><span class="line"><span class="comment">        5，enableInsert（默认true）：指定是否生成insert语句；</span></span><br><span class="line"><span class="comment">        6，enableSelectByPrimaryKey（默认true）：指定是否生成按照主键查询对象的语句（就是getById或get）；</span></span><br><span class="line"><span class="comment">        7，enableSelectByExample（默认true）：MyBatis3Simple为false，指定是否生成动态查询语句；</span></span><br><span class="line"><span class="comment">        8，enableUpdateByPrimaryKey（默认true）：指定是否生成按照主键修改对象的语句（即update)；</span></span><br><span class="line"><span class="comment">        9，enableDeleteByPrimaryKey（默认true）：指定是否生成按照主键删除对象的语句（即delete）；</span></span><br><span class="line"><span class="comment">        10，enableDeleteByExample（默认true）：MyBatis3Simple为false，指定是否生成动态删除语句；</span></span><br><span class="line"><span class="comment">        11，enableCountByExample（默认true）：MyBatis3Simple为false，指定是否生成动态查询总条数语句（用于分页的总条数查询）；</span></span><br><span class="line"><span class="comment">        12，enableUpdateByExample（默认true）：MyBatis3Simple为false，指定是否生成动态修改语句（只修改对象中不为空的属性）；</span></span><br><span class="line"><span class="comment">        13，modelType：参考context元素的defaultModelType，相当于覆盖；</span></span><br><span class="line"><span class="comment">        14，delimitIdentifiers：参考tableName的解释，注意，默认的delimitIdentifiers是双引号，如果类似MYSQL这样的数据库，使用的是`（反引号，那么还需要设置context的beginningDelimiter和endingDelimiter属性）</span></span><br><span class="line"><span class="comment">        15，delimitAllColumns：设置是否所有生成的SQL中的列名都使用标识符引起来。默认为false，delimitIdentifiers参考context的属性</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        注意，table里面很多参数都是对javaModelGenerator，context等元素的默认属性的一个复写；</span></span><br><span class="line"><span class="comment">     --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span> <span class="attr">tableName</span>=<span class="string">"userinfo"</span> &gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 参考 javaModelGenerator 的 constructorBased属性--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"constructorBased"</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 默认为false，如果设置为true，在生成的SQL中，table名字不会加上catalog或schema； --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"ignoreQualifiersAtRuntime"</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 参考 javaModelGenerator 的 immutable 属性 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"immutable"</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 指定是否只生成domain类，如果设置为true，只生成domain类，如果还配置了sqlMapGenerator，那么在mapper XML文件中，只生成resultMap元素 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"modelOnly"</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 参考 javaModelGenerator 的 rootClass 属性 </span></span><br><span class="line"><span class="comment">        &lt;property name="rootClass" value=""/&gt;</span></span><br><span class="line"><span class="comment">         --&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 参考javaClientGenerator 的  rootInterface 属性</span></span><br><span class="line"><span class="comment">        &lt;property name="rootInterface" value=""/&gt;</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 如果设置了runtimeCatalog，那么在生成的SQL中，使用该指定的catalog，而不是table元素上的catalog </span></span><br><span class="line"><span class="comment">        &lt;property name="runtimeCatalog" value=""/&gt;</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 如果设置了runtimeSchema，那么在生成的SQL中，使用该指定的schema，而不是table元素上的schema </span></span><br><span class="line"><span class="comment">        &lt;property name="runtimeSchema" value=""/&gt;</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 如果设置了runtimeTableName，那么在生成的SQL中，使用该指定的tablename，而不是table元素上的tablename </span></span><br><span class="line"><span class="comment">        &lt;property name="runtimeTableName" value=""/&gt;</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 注意，该属性只针对MyBatis3Simple有用；</span></span><br><span class="line"><span class="comment">            如果选择的runtime是MyBatis3Simple，那么会生成一个SelectAll方法，如果指定了selectAllOrderByClause，那么会在该SQL中添加指定的这个order条件；</span></span><br><span class="line"><span class="comment">         --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"selectAllOrderByClause"</span> <span class="attr">value</span>=<span class="string">"age desc,username asc"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 如果设置为true，生成的model类会直接使用column本身的名字，而不会再使用驼峰命名方法，比如BORN_DATE，生成的属性名字就是BORN_DATE,而不会是bornDate --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"useActualColumnNames"</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- generatedKey用于生成生成主键的方法，</span></span><br><span class="line"><span class="comment">            如果设置了该元素，MBG会在生成的&lt;insert&gt;元素中生成一条正确的&lt;selectKey&gt;元素，该元素可选</span></span><br><span class="line"><span class="comment">            column:主键的列名；</span></span><br><span class="line"><span class="comment">            sqlStatement：要生成的selectKey语句，有以下可选项：</span></span><br><span class="line"><span class="comment">                Cloudscape:相当于selectKey的SQL为： VALUES IDENTITY_VAL_LOCAL()</span></span><br><span class="line"><span class="comment">                DB2       :相当于selectKey的SQL为： VALUES IDENTITY_VAL_LOCAL()</span></span><br><span class="line"><span class="comment">                DB2_MF    :相当于selectKey的SQL为：SELECT IDENTITY_VAL_LOCAL() FROM SYSIBM.SYSDUMMY1</span></span><br><span class="line"><span class="comment">                Derby      :相当于selectKey的SQL为：VALUES IDENTITY_VAL_LOCAL()</span></span><br><span class="line"><span class="comment">                HSQLDB      :相当于selectKey的SQL为：CALL IDENTITY()</span></span><br><span class="line"><span class="comment">                Informix  :相当于selectKey的SQL为：select dbinfo('sqlca.sqlerrd1') from systables where tabid=1</span></span><br><span class="line"><span class="comment">                MySql      :相当于selectKey的SQL为：SELECT LAST_INSERT_ID()</span></span><br><span class="line"><span class="comment">                SqlServer :相当于selectKey的SQL为：SELECT SCOPE_IDENTITY()</span></span><br><span class="line"><span class="comment">                SYBASE      :相当于selectKey的SQL为：SELECT @@IDENTITY</span></span><br><span class="line"><span class="comment">                JDBC      :相当于在生成的insert元素上添加useGeneratedKeys="true"和keyProperty属性</span></span><br><span class="line"><span class="comment">        &lt;generatedKey column="" sqlStatement=""/&gt;</span></span><br><span class="line"><span class="comment">         --&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">            该元素会在根据表中列名计算对象属性名之前先重命名列名，非常适合用于表中的列都有公用的前缀字符串的时候，</span></span><br><span class="line"><span class="comment">            比如列名为：CUST_ID,CUST_NAME,CUST_EMAIL,CUST_ADDRESS等；</span></span><br><span class="line"><span class="comment">            那么就可以设置searchString为"^CUST_"，并使用空白替换，那么生成的Customer对象中的属性名称就不是</span></span><br><span class="line"><span class="comment">            custId,custName等，而是先被替换为ID,NAME,EMAIL,然后变成属性：id，name，email；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            注意，MBG是使用java.util.regex.Matcher.replaceAll来替换searchString和replaceString的，</span></span><br><span class="line"><span class="comment">            如果使用了columnOverride元素，该属性无效；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        &lt;columnRenamingRule searchString="" replaceString=""/&gt;</span></span><br><span class="line"><span class="comment">         --&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">         <span class="comment">&lt;!-- 用来修改表中某个列的属性，MBG会使用修改后的列来生成domain的属性；</span></span><br><span class="line"><span class="comment">             column:要重新设置的列名；</span></span><br><span class="line"><span class="comment">             注意，一个table元素中可以有多个columnOverride元素哈~</span></span><br><span class="line"><span class="comment">          --&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">columnOverride</span> <span class="attr">column</span>=<span class="string">"username"</span>&gt;</span></span><br><span class="line">             <span class="comment">&lt;!-- 使用property属性来指定列要生成的属性名称 --&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"property"</span> <span class="attr">value</span>=<span class="string">"userName"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">             <span class="comment">&lt;!-- javaType用于指定生成的domain的属性类型，使用类型的全限定名</span></span><br><span class="line"><span class="comment">             &lt;property name="javaType" value=""/&gt;</span></span><br><span class="line"><span class="comment">              --&gt;</span></span><br><span class="line"></span><br><span class="line">             <span class="comment">&lt;!-- jdbcType用于指定该列的JDBC类型 </span></span><br><span class="line"><span class="comment">             &lt;property name="jdbcType" value=""/&gt;</span></span><br><span class="line"><span class="comment">              --&gt;</span></span><br><span class="line"></span><br><span class="line">             <span class="comment">&lt;!-- typeHandler 用于指定该列使用到的TypeHandler，如果要指定，配置类型处理器的全限定名</span></span><br><span class="line"><span class="comment">                 注意，mybatis中，不会生成到mybatis-config.xml中的typeHandler</span></span><br><span class="line"><span class="comment">                 只会生成类似：where id = #{id,jdbcType=BIGINT,typeHandler=com._520it.mybatis.MyTypeHandler}的参数描述</span></span><br><span class="line"><span class="comment">             &lt;property name="jdbcType" value=""/&gt;</span></span><br><span class="line"><span class="comment">             --&gt;</span></span><br><span class="line"></span><br><span class="line">             <span class="comment">&lt;!-- 参考table元素的delimitAllColumns配置，默认为false</span></span><br><span class="line"><span class="comment">             &lt;property name="delimitedColumnName" value=""/&gt;</span></span><br><span class="line"><span class="comment">              --&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">columnOverride</span>&gt;</span></span><br><span class="line"></span><br><span class="line">         <span class="comment">&lt;!-- ignoreColumn设置一个MGB忽略的列，如果设置了改列，那么在生成的domain中，生成的SQL中，都不会有该列出现 </span></span><br><span class="line"><span class="comment">             column:指定要忽略的列的名字；</span></span><br><span class="line"><span class="comment">             delimitedColumnName：参考table元素的delimitAllColumns配置，默认为false</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">             注意，一个table元素中可以有多个ignoreColumn元素</span></span><br><span class="line"><span class="comment">         &lt;ignoreColumn column="deptId" delimitedColumnName=""/&gt;</span></span><br><span class="line"><span class="comment">         --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">context</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">generatorConfiguration</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Maven </category>
          
      </categories>
      
      
        <tags>
            
            <tag> maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maven-构建生命周期</title>
      <link href="/post/164885525/"/>
      <url>/post/164885525/</url>
      
        <content type="html"><![CDATA[<p>Maven 构建生命周期定义了一个项目构建跟发布的过程。我们在开发项目的时候，不断地在编译、测试、打包、部署等过程，maven的生命周期就是对所有构建过程抽象与统一，生命周期包含项目的清理、初始化、编译、测试、打包、集成测试、验证、部署、站点生成等几乎所有的过程。</p><h3 id="Maven-有以下三个标准的生命周期：">Maven 有以下三个标准的生命周期：<a class="" href="#Maven-有以下三个标准的生命周期："></a></h3><ul><li>clean：项目清理的处理</li><li>default(或 build)：项目部署的处理</li><li>site：项目站点文档创建的处理</li></ul><h3 id="构建阶段由插件目标构成">构建阶段由插件目标构成<a class="" href="#构建阶段由插件目标构成"></a></h3><p>一个插件目标代表一个特定的任务（比构建阶段更为精细），这有助于项目的构建和管理。这些目标可能被绑定到多个阶段或者无绑定。不绑定到任何构建阶段的目标可以在构建生命周期之外通过直接调用执行。这些目标的执行顺序取决于调用目标和构建阶段的顺序。</p><p>例如下面的命令：</p><figure class="highlight plain"><figcaption><span>和 ```pakage``` 是构建阶段，```dependency:copy-dependencies``` 是目标</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line">```shell</span><br><span class="line">mvn clean dependency:copy-dependencies package</span><br></pre></td></tr></tbody></table></figure><p>这里的 <code>clean</code> 阶段将会被首先执行，然后 <code>dependency:copy-dependencies</code> 目标会被执行，最终 <code>package</code> 阶段被执行。</p><hr><h3 id="Clean-生命周期">Clean 生命周期<a class="" href="#Clean-生命周期"></a></h3><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/images/post/2020/08/1240-20200803123444089.png" alt="CleanLifecycle">当我们执行 mvn post-clean 命令时，Maven 调用 clean 生命周期，它包含以下阶段：</p><ul><li>**pre-clean：**执行一些需要在clean之前完成的工作</li><li>**clean：**移除所有上一次构建生成的文件</li><li>**post-clean：**执行一些需要在clean之后立刻完成的工作</li></ul><p><code>mvn clean</code> 中的 <code>clean</code> 就是上面的 <code>clean</code>，在一个生命周期中，运行某个阶段的时候，它之前的所有阶段都会被运行，也就是说，<code>mvn clean</code> 等同于<code>mvn pre-clean clean</code> ，如果我们运行<code> mvn post-clean</code> ，那么 <code>pre-clean</code>，<code>clean</code> 都会被运行。</p><h3 id="Default-Build-生命周期">Default (Build) 生命周期<a class="" href="#Default-Build-生命周期"></a></h3><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/images/post/2020/08/1240-20200803123608210.png" alt="DefaultLifecycle">这是 Maven 的主要生命周期，被用于构建应用，包括下面的 23 个阶段：</p><table><thead><tr><th>生命周期阶段</th><th>描述</th></tr></thead><tbody><tr><td>validate</td><td>检查工程配置是否正确，完成构建过程的所有必要信息是否能够获取到。</td></tr><tr><td>initialize</td><td>初始化构建状态，例如设置属性。</td></tr><tr><td>generate-sources</td><td>生成编译阶段需要包含的任何源码文件。</td></tr><tr><td>process-sources</td><td>处理源代码，例如，过滤任何值（filter any value）。</td></tr><tr><td>generate-resources</td><td>生成工程包中需要包含的资源文件。</td></tr><tr><td>process-resources</td><td>拷贝和处理资源文件到目的目录中，为打包阶段做准备。</td></tr><tr><td>compile</td><td>编译工程源码。</td></tr><tr><td>process-classes</td><td>处理编译生成的文件，例如 Java Class 字节码的加强和优化。</td></tr><tr><td>generate-test-sources</td><td>生成编译阶段需要包含的任何测试源代码。</td></tr><tr><td>process-test-sources</td><td>处理测试源代码，例如，过滤任何值（filter any values)。</td></tr><tr><td>test-compile</td><td>编译测试源代码到测试目的目录。</td></tr><tr><td>process-test-classes</td><td>处理测试代码文件编译后生成的文件。</td></tr><tr><td>test</td><td>使用适当的单元测试框架（例如JUnit）运行测试。</td></tr><tr><td>prepare-package</td><td>在真正打包之前，为准备打包执行任何必要的操作。</td></tr><tr><td>package</td><td>获取编译后的代码，并按照可发布的格式进行打包，例如 JAR、WAR 或者 EAR 文件。</td></tr><tr><td>pre-integration-test</td><td>在集成测试执行之前，执行所需的操作。例如，设置所需的环境变量。</td></tr><tr><td>integration-test</td><td>处理和部署必须的工程包到集成测试能够运行的环境中。</td></tr><tr><td>post-integration-test</td><td>在集成测试被执行后执行必要的操作。例如，清理环境。</td></tr><tr><td>verify</td><td>运行检查操作来验证工程包是有效的，并满足质量要求。</td></tr><tr><td>install</td><td>安装工程包到本地仓库中，该仓库可以作为本地其他工程的依赖。</td></tr><tr><td>deploy</td><td>拷贝最终的工程包到远程仓库中，以共享给其他开发人员和工程。</td></tr></tbody></table><blockquote><p>有一些与 Maven 生命周期相关的重要概念需要说明：当一个阶段通过 Maven 命令调用时，例如 <code>mvn compile</code>，只有该阶段之前以及包括该阶段在内的所有阶段会被执行。不同的 maven 目标将根据打包的类型（<code>JAR / WAR / EAR</code>），被绑定到不同的 Maven 生命周期阶段。</p></blockquote><h3 id="Site-生命周期">Site 生命周期<a class="" href="#Site-生命周期"></a></h3><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/images/post/2020/08/1240-20200803123731048.png" alt="SiteLifecycle">Maven Site 插件一般用来创建新的报告文档、部署站点等。</p><table><thead><tr><th>生命周期阶段</th><th>描述</th></tr></thead><tbody><tr><td>pre-site</td><td>执行一些需要在生成站点文档之前完成的工作</td></tr><tr><td>site</td><td>生成项目的站点文档</td></tr><tr><td>post-site</td><td>执行一些需要在生成站点文档之后完成的工作，并且为部署做准备</td></tr><tr><td>site-deploy</td><td>将生成的站点文档部署到特定的服务器上</td></tr></tbody></table><p>这里经常用到的是site阶段和site-deploy阶段，用以生成和发布Maven站点，这可是Maven相当强大的功能。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Maven </category>
          
      </categories>
      
      
        <tags>
            
            <tag> maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maven-约定优于配置</title>
      <link href="/post/164885526/"/>
      <url>/post/164885526/</url>
      
        <content type="html"><![CDATA[<p>maven的配置文件看似很复杂，其实只需要根据项目的实际背景，设置个别的几个配置项而已。maven有自己的一套默认配置，使用者除非必要，并不需要去修改那些约定内容。这就是所谓的“约定优于配置”。</p><h2 id="文件目录">文件目录<a class="" href="#文件目录"></a></h2><p>maven默认的文件存放结构如下：<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/images/post/2020/08/1240-20200803141332066.png" alt="maven项目文件目录">每一个阶段的任务都知道怎么正确完成自己的工作，比如compile任务就知道从src/main/java下编译所有的java文件，并把它的输出class文件存放到target/classes中。</p><p>对maven来说，采用"约定优于配置"的策略可以减少修改配置的工作量，也可以降低学习成本，更重要的是，给项目引入了统一的规范。</p><h2 id="版本规范">版本规范<a class="" href="#版本规范"></a></h2><p>maven有自己的版本规范，一般是如下定义：<code>&lt;majorversion&gt;.&lt;minor version&gt;.&lt;incremental version&gt;-&lt;qualifier&gt;</code>比如1.2.3-beta-01。要说明的是，maven自己判断版本的算法是<code>major</code>,<code>minor</code>,<code>incremental</code>部分用数字比较，qualifier部分用字符串比较，所以要小心 alpha-2和alpha-15的比较关系，最好用 alpha-02的格式。</p><p>maven在版本管理时候可以使用几个特殊的字符串 <code>SNAPSHOT</code> ,<code>LATEST</code> ,<code>RELEASE </code>。比如<code>1.0-SNAPSHOT</code>。各个部分的含义和处理逻辑如下说明：</p><p><strong>l&nbsp;&nbsp; SNAPSHOT</strong>如果一个版本包含字符串"SNAPSHOT"，Maven就会在安装或发布这个组件的时候将该符号展开为一个日期和时间值，转换为UTC时间。例如，"1.0-SNAPSHOT"会在2010年5月5日下午2点10分发布时候变成1.0-20100505-141000-1。</p><p>这个词只能用于开发过程中，因为一般来说，项目组都会频繁发布一些版本，最后实际发布的时候，会在这些snapshot版本中寻找一个稳定的，用于正式发 布，比如1.4版本发布之前，就会有一系列的1.4-SNAPSHOT，而实际发布的1.4，也是从中拿出来的一个稳定版。</p><p><strong>l&nbsp;&nbsp; LATEST</strong>指某个特定构件的最新发布，这个发布可能是一个发布版，也可能是一个snapshot版，具体看哪个时间最后。</p><p><strong>l&nbsp;&nbsp; RELEASE</strong>指最后一个发布版。</p><h2 id="Maven变量">Maven变量<a class="" href="#Maven变量"></a></h2><p>除了在setting.xml以及pom.xml当中用properties定义的常量，maven还提供了一些隐式的变量，用来访问系统环境变量。</p><table><thead><tr><th>类别</th><th>例子</th></tr></thead><tbody><tr><td>内置属性</td><td>${basedir}表示项目根目录,即包含pom.xml文件的目录<br>${version}表示项目版本<br>${project.basedir}同${basedir}<br>${project.baseUri}表示项目文件地址<br>${maven.build.timestamp}表示项目构件开始时间</td></tr><tr><td>setting属性</td><td>${settings.localRepository }表示本地仓库路径</td></tr><tr><td>POM属性</td><td>${project.build.directory}表示主源码路径<br>${project.build.sourceEncoding}表示主源码的编码格式<br>${project.build.sourceDirectory}表示主源码路径<br>${project.build.finalName}表示输出文件名称<br>${project.version}表示项目版本,与${version}相同</td></tr><tr><td>Java系统属性</td><td>${user.home}表示用户目录<br>${java.version}表示Java版本</td></tr><tr><td>环境变量属性</td><td>${env.JAVA_HOME}表示JAVA_HOME环境变量的值<br>${env.HOME }表示用户目录</td></tr><tr><td>上级工程变量</td><td>上级工程的pom中的变量用前缀 ${project.parent } 引用。上级工程的版本也可以这样引用: ${parent.version }</td></tr></tbody></table><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Maven </category>
          
      </categories>
      
      
        <tags>
            
            <tag> maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maven-项目模板</title>
      <link href="/post/164885528/"/>
      <url>/post/164885528/</url>
      
        <content type="html"><![CDATA[<h2 id="Archetype介绍">Archetype介绍<a class="" href="#Archetype介绍"></a></h2><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">官方文档:[https://maven.apache.org/archetype/index.html](https://maven.apache.org/archetype/index.html)</span><br><span class="line"></span><br><span class="line">## Archetype使用</span><br><span class="line"></span><br><span class="line"> #### IDEA中创建</span><br><span class="line"></span><br><span class="line">在IDEA中，我们可以通过```New Project – Maven – Create from archetype```,选择某个```archetype```快速创建模板项目</span><br><span class="line">![IDEA创建模板](https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/images/post/2020/08/1240-20200803140403890.png)</span><br><span class="line"></span><br><span class="line">#### 命令创建</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>mvn archetype:generate</p><pre><code>* 输入命令后，Archetype插件会输出一个Archetype列表供用户选择；选择自己想要使用的Archetype，输入对应编号* 提示输入一些基本参数，如groupId,artifactId,version,package等* Archetype插件生成项目骨架  ![命令创建](https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/images/post/2020/08/1240-20200803140408427.png)  #### 过滤器方式创建  ![过滤器方式](https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/images/post/2020/08/1240-20200803140423448.png)  跳过了选择```archetype```步骤## 常用的archetype  ```maven-archetype-quickstart```默认的Archetype,基本内容包括： * 一个包含junit依赖声明的pom.xml* src/main/java主代码目录及一个名为App的类* src/test/java测试代码目录及一个名为AppTest的测试用例```maven-archetype-webapp```一个最简单的Maven war项目模板，当需要快速创建一个Web应用的时候可以使用它。生成的项目内容包括：* 一个packaging为war且带有junit依赖声明的pom.xml* src/main/webapp/目录* src/main/webapp/index.jsp文件* src/main/webapp/WEB-INF/web.xml文件## Archetype开发### 创建自定义模板1.在maven项目下，执行`mvn archetype:create-from-project`，在`target/generated-sources/archetype`目录下生成Archetype project2.`cd target/generated-sources/archetype`后，`mvn install`安装archetype project到本地仓库ps：如果是maven多模块项目，在根目录下执行mvn archetype:create-from-projectmvn install后，会在本地的maven仓库，按照maven坐标创建对应的archetype文件![步骤](https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/images/post/2020/08/1240-20200803140439037.png)官方介绍：[https://maven.apache.org/archetype/maven-archetype-plugin/advanced-usage.html](https://maven.apache.org/archetype/maven-archetype-plugin/advanced-usage.html)**例子:**![](https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/images/post/2020/08/1240-20200803140452727.png)![](https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/images/post/2020/08/1240-20200803140504705.png)本地仓库中生成的archetype模板![](https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/images/post/2020/08/1240-20200803140601497.png)### 使用自定义模板1.在当前的目录下，`mvn archetype:generate -DarchetypeCatalog=local`，查看本地archetype列表2.choose number，按步骤输入基本参数groupId/artifactId/version/package3.在当前目录下，以artifactId为目录创建一个新的项目![](https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/images/post/2020/08/1240-20200803140623582.png)### ![](https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/images/post/2020/08/1240-20200803140637636.png)### 添加到IDEA![](https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/images/post/2020/08/1240-20200803140651482.png)![](https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/images/post/2020/08/1240-20200803140710775.png)添加自定义属性参数![](https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/images/post/2020/08/1240-20200803140729528.png)## Archetype配置`mvn archetype:generate -DarchetypeCatalog=local`对应的本地archetype列表，在本地maven仓库的archetype-catalog.xml中&nbsp;,比如:&nbsp;~/.m2/repository/archetype-catalog.xml![](https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/images/post/2020/08/1240-20200803140738072.png)IDEA中的archtype配置,在 ~/Library/Caches/IntelliJIdea2017.1/Maven/Indices/UserArchetypes.xml中![](https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/images/post/2020/08/1240-20200803140741778.png)![](https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/images/post/2020/08/1240-20200803140754303.png)</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Maven </category>
          
      </categories>
      
      
        <tags>
            
            <tag> maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maven-setting-xml</title>
      <link href="/post/164885518/"/>
      <url>/post/164885518/</url>
      
        <content type="html"><![CDATA[<p><code>setting.xml</code>配置文件<code>maven</code>的配置文件<code>settings.xml</code>存在于两个地方：</p><p>1.安装的地方：<code>${M2_HOME}/conf/settings.xml</code></p><p>2.用户的目录：<code>${user.home}/.m2/settings.xml</code></p><p>前者又被叫做全局配置，对操作系统的所有使用者生效；后者被称为用户配置，只对当前操作系统的使用者生效。如果两者都存在，它们的内容将被合并，并且用户范围的<code>settings.xml</code>会覆盖全局的<code>settings.xml</code>。</p><p>Maven安装后，用户目录下不会自动生成<code>settings.xml</code>，只有全局配置文件。如果需要创建用户范围的<code>settings.xml</code>，可以将安装路径下的settings复制到目录<code>${user.home}/.m2</code>/。Maven默认的<code>settings.xml</code>是一个包含了注释和例子的模板，可以快速的修改它来达到你的要求。</p><p>全局配置一旦更改，所有的用户都会受到影响，而且如果maven进行升级，所有的配置都会被清除，所以要提前复制和备份<code>${M2_HOME}/conf/settings.xml</code>文件，一般情况下不推荐配置全局的<code>settings.xml</code>。</p><figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;<span class="name">settings</span>   <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span>  </span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span>  </span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd"</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">&lt;!--本地仓库。该值表示构建系统本地仓库的路径。其默认值为${user.home}/.m2/repository。  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">localRepository</span>&gt;</span>usr/local/maven<span class="tag">&lt;/<span class="name">localRepository</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">&lt;!--Maven是否需要和用户交互以获得输入。如果Maven需要和用户交互以获得输入，则设置成true，反之则应为false。默认为true。 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">interactiveMode</span>&gt;</span>true<span class="tag">&lt;/<span class="name">interactiveMode</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">&lt;!--Maven是否需要使用plugin-registry.xml文件来管理插件版本。  --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--如果设置为true，则在{user.home}/.m2下需要有一个plugin-registry.xml来对plugin的版本进行管理  --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--默认为false。 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">usePluginRegistry</span>&gt;</span>false<span class="tag">&lt;/<span class="name">usePluginRegistry</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">&lt;!--表示Maven是否需要在离线模式下运行。如果构建系统需要在离线模式下运行，则为true，默认为false。  --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--当由于网络设置原因或者安全因素，构建服务器不能连接远程仓库的时候，该配置就十分有用。  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">offline</span>&gt;</span>false<span class="tag">&lt;/<span class="name">offline</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">&lt;!--当插件的组织Id（groupId）没有显式提供时，供搜寻插件组织Id（groupId）的列表。  --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--该元素包含一个pluginGroup元素列表，每个子元素包含了一个组织Id（groupId）。  --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--当我们使用某个插件，并且没有在命令行为其提供组织Id（groupId）的时候，Maven就会使用该列表。  --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--默认情况下该列表包含了org.apache.maven.plugins。  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">pluginGroups</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">&lt;!--plugin的组织Id（groupId）  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">pluginGroup</span>&gt;</span>org.codehaus.mojo<span class="tag">&lt;/<span class="name">pluginGroup</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;/<span class="name">pluginGroups</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">&lt;!--用来配置不同的代理，多代理profiles可以应对笔记本或移动设备的工作环境：通过简单的设置profile id就可以很容易的更换整个代理配置。  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">proxies</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">&lt;!--代理元素包含配置代理时需要的信息 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">proxy</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">&lt;!--代理的唯一定义符，用来区分不同的代理元素。 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span>&gt;</span>myproxy<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">&lt;!--该代理是否是激活的那个。true则激活代理。当我们声明了一组代理，而某个时候只需要激活一个代理的时候，该元素就可以派上用处。  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">active</span>&gt;</span>true<span class="tag">&lt;/<span class="name">active</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">&lt;!--代理的协议。 协议://主机名:端口，分隔成离散的元素以方便配置。 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">protocol</span>&gt;</span>http://…<span class="tag">&lt;/<span class="name">protocol</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">&lt;!--代理的主机名。协议://主机名:端口，分隔成离散的元素以方便配置。   --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">host</span>&gt;</span>proxy.somewhere.com<span class="tag">&lt;/<span class="name">host</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">&lt;!--代理的端口。协议://主机名:端口，分隔成离散的元素以方便配置。  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">port</span>&gt;</span>8080<span class="tag">&lt;/<span class="name">port</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"> <span class="comment">&lt;!--代理的用户名，用户名和密码表示代理服务器认证的登录名和密码。  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">username</span>&gt;</span>proxyuser<span class="tag">&lt;/<span class="name">username</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">&lt;!--代理的密码，用户名和密码表示代理服务器认证的登录名和密码。  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">password</span>&gt;</span>somepassword<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">&lt;!--不该被代理的主机名列表。该列表的分隔符由代理服务器指定；例子中使用了竖线分隔符，使用逗号分隔也很常见。 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">nonProxyHosts</span>&gt;</span>*.google.com|ibiblio.org<span class="tag">&lt;/<span class="name">nonProxyHosts</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;/<span class="name">proxy</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;/<span class="name">proxies</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">&lt;!--配置服务端的一些设置。一些设置如安全证书不应该和pom.xml一起分发。这种类型的信息应该存在于构建服务器上的settings.xml文件中。 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servers</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">&lt;!--服务器元素包含配置服务器时需要的信息  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">server</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">&lt;!--这是server的id（注意不是用户登陆的id），该id与distributionManagement中repository元素的id相匹配。 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span>&gt;</span>server001<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">&lt;!--鉴权用户名。鉴权用户名和鉴权密码表示服务器认证所需要的登录名和密码。  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">username</span>&gt;</span>my_login<span class="tag">&lt;/<span class="name">username</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">&lt;!--鉴权密码 。鉴权用户名和鉴权密码表示服务器认证所需要的登录名和密码。  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">password</span>&gt;</span>my_password<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">&lt;!--鉴权时使用的私钥位置。和前两个元素类似，私钥位置和私钥密码指定了一个私钥的路径（默认是/home/hudson/.ssh/id_dsa）以及如果需要的话，一个密钥 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--将来passphrase和password元素可能会被提取到外部，但目前它们必须在settings.xml文件以纯文本的形式声明。  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">privateKey</span>&gt;</span>${usr.home}/.ssh/id_dsa<span class="tag">&lt;/<span class="name">privateKey</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">&lt;!--鉴权时使用的私钥密码。 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">passphrase</span>&gt;</span>some_passphrase<span class="tag">&lt;/<span class="name">passphrase</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">&lt;!--文件被创建时的权限。如果在部署的时候会创建一个仓库文件或者目录，这时候就可以使用权限（permission）。--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--这两个元素合法的值是一个三位数字，其对应了unix文件系统的权限，如664，或者775。  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filePermissions</span>&gt;</span>664<span class="tag">&lt;/<span class="name">filePermissions</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">&lt;!--目录被创建时的权限。  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">directoryPermissions</span>&gt;</span>775<span class="tag">&lt;/<span class="name">directoryPermissions</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">&lt;!--传输层额外的配置项  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;/<span class="name">server</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;/<span class="name">servers</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">&lt;!--为仓库列表配置的下载镜像列表。  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mirrors</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">&lt;!--给定仓库的下载镜像。  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">&lt;!--该镜像的唯一标识符。id用来区分不同的mirror元素。  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span>&gt;</span>planetmirror.com<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">&lt;!--镜像名称  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>PlanetMirror Australia<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">&lt;!--该镜像的URL。构建系统会优先考虑使用该URL，而非使用默认的服务器URL。  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url</span>&gt;</span>http://downloads.planetmirror.com/pub/maven2<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">&lt;!--被镜像的服务器的id。例如，如果我们要设置了一个Maven中央仓库（http://repo1.maven.org/maven2）的镜像，--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--就需要将该元素设置成central。这必须和中央仓库的id central完全一致。 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;/<span class="name">mirrors</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">&lt;!--根据环境参数来调整构建配置的列表。settings.xml中的profile元素是pom.xml中profile元素的裁剪版本。--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--它包含了id，activation, repositories, pluginRepositories和 properties元素。--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--这里的profile元素只包含这五个子元素是因为这里只关心构建系统这个整体（这正是settings.xml文件的角色定位），而非单独的项目对象模型设置。--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--如果一个settings中的profile被激活，它的值会覆盖任何其它定义在POM中或者profile.xml中的带有相同id的profile。  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">&lt;!--根据环境参数来调整的构件的配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">&lt;!--该配置的唯一标识符。  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span>&gt;</span>test<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">&lt;!--自动触发profile的条件逻辑。Activation是profile的开启钥匙。--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--如POM中的profile一样，profile的力量来自于它能够在某些特定的环境中自动使用某些特定的值；这些环境通过activation元素指定。--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--activation元素并不是激活profile的唯一方式。settings.xml文件中的activeProfile元素可以包含profile的id。--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--profile也可以通过在命令行，使用-P标记和逗号分隔的列表来显式的激活（如，-P test）。 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">&lt;!--profile默认是否激活的标识 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>false<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">&lt;!--activation有一个内建的java版本检测，如果检测到jdk版本与期待的一样，profile被激活。 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">jdk</span>&gt;</span>1.7<span class="tag">&lt;/<span class="name">jdk</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">&lt;!--当匹配的操作系统属性被检测到，profile被激活。os元素可以定义一些操作系统相关的属性。 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">os</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">&lt;!--激活profile的操作系统的名字  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>Windows XP<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">&lt;!--激活profile的操作系统所属家族(如 'windows')   --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">family</span>&gt;</span>Windows<span class="tag">&lt;/<span class="name">family</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">&lt;!--激活profile的操作系统体系结构   --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">arch</span>&gt;</span>x86<span class="tag">&lt;/<span class="name">arch</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">&lt;!--激活profile的操作系统版本 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.2600<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">os</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">&lt;!--如果Maven检测到某一个属性（其值可以在POM中通过${名称}引用），其拥有对应的名称和值，Profile就会被激活。--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--如果值字段是空的，那么存在属性名称字段就会激活profile，否则按区分大小写方式匹配属性值字段 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">&lt;!--激活profile的属性的名称 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>mavenVersion<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">&lt;!--激活profile的属性的值  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>2.0.3<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">&lt;!--提供一个文件名，通过检测该文件的存在或不存在来激活profile。missing检查文件是否存在，如果不存在则激活profile。--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--另一方面，exists则会检查文件是否存在，如果存在则激活profile。 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">file</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">&lt;!--如果指定的文件存在，则激活profile。  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exists</span>&gt;</span>/usr/local/hudson/hudson-home/jobs/maven-guide-zh-to-production/workspace/<span class="tag">&lt;/<span class="name">exists</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">&lt;!--如果指定的文件不存在，则激活profile。 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">missing</span>&gt;</span>/usr/local/hudson/hudson-home/jobs/maven-guide-zh-to-production/workspace/<span class="tag">&lt;/<span class="name">missing</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">   </span><br><span class="line"><span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"> <span class="comment">&lt;!--对应profile的扩展属性列表。Maven属性和Ant中的属性一样，可以用来存放一些值。这些值可以在POM中的任何地方使用标记${X}来使用，这里X是指属性的名称。--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--属性有五种不同的形式，并且都能在settings.xml文件中访问。   --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--1. env.X: 在一个变量前加上"env."的前缀，会返回一个shell环境变量。例如,"env.PATH"指代了$path环境变量（在Windows上是%PATH%）。  --&gt;</span> </span><br><span class="line"><span class="comment">&lt;!--2. project.x：指代了POM中对应的元素值。      --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--3. settings.x: 指代了settings.xml中对应元素的值。   --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--4. Java System Properties: 所有可通过java.lang.System.getProperties()访问的属性都能在POM中使用该形式访问，   --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--   如/usr/lib/jvm/java-1.6.0-openjdk-1.6.0.0/jre。      --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--5. x: 在&lt;properties/&gt;元素中，或者外部文件中设置，以${someVar}的形式使用。  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 如果这个profile被激活，那么属性${user.install}就可以被访问了 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">user.install</span>&gt;</span>usr/local/winner/jobs/maven-guide<span class="tag">&lt;/<span class="name">user.install</span>&gt;</span></span><br><span class="line">   </span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">&lt;!--远程仓库列表，它是Maven用来填充构建系统本地仓库所使用的一组远程项目。  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">&lt;!--包含需要连接到远程仓库的信息  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">&lt;!--远程仓库唯一标识 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span>&gt;</span>codehausSnapshots<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">&lt;!--远程仓库名称  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>Codehaus Snapshots<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">&lt;!--如何处理远程仓库里发布版本的下载 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">&lt;!--true或者false表示该仓库是否为下载某种类型构件（发布版，快照版）开启。   --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">enabled</span>&gt;</span>false<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">&lt;!--该元素指定更新发生的频率。Maven会比较本地POM和远程POM的时间戳。这里的选项是：--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--always（一直），daily（默认，每日），interval：X（这里X是以分钟为单位的时间间隔），或者never（从不）。  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">updatePolicy</span>&gt;</span>always<span class="tag">&lt;/<span class="name">updatePolicy</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">&lt;!--当Maven验证构件校验文件失败时该怎么做:--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--ignore（忽略），fail（失败），或者warn（警告）。 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">checksumPolicy</span>&gt;</span>warn<span class="tag">&lt;/<span class="name">checksumPolicy</span>&gt;</span></span><br><span class="line">     </span><br><span class="line"><span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">&lt;!--如何处理远程仓库里快照版本的下载。有了releases和snapshots这两组配置，POM就可以在每个单独的仓库中，为每种类型的构件采取不同的策略。--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--例如，可能有人会决定只为开发目的开启对快照版本下载的支持。参见repositories/repository/releases元素 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">      </span><br><span class="line"><span class="tag">&lt;<span class="name">enabled</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">updatePolicy</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">checksumPolicy</span> /&gt;</span></span><br><span class="line">     </span><br><span class="line"><span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">&lt;!--远程仓库URL，按protocol://hostname/path形式  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url</span>&gt;</span>http://snapshots.maven.codehaus.org/maven2<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">&lt;!--用于定位和排序构件的仓库布局类型-可以是default（默认）或者legacy（遗留）。--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--Maven 2为其仓库提供了一个默认的布局；然而，Maven 1.x有一种不同的布局。我们可以使用该元素指定布局是default（默认）还是legacy（遗留）。  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">layout</span>&gt;</span>default<span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">   </span><br><span class="line"><span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">&lt;!--发现插件的远程仓库列表。仓库是两种主要构件的家。第一种构件被用作其它构件的依赖。这是中央仓库中存储的大部分构件类型。另外一种构件类型是插件。--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--Maven插件是一种特殊类型的构件。由于这个原因，插件仓库独立于其它仓库。pluginRepositories元素的结构和repositories元素的结构类似。--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--每个pluginRepository元素指定一个Maven可以用来寻找新插件的远程地址。 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">pluginRepositories</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">&lt;!--包含需要连接到远程插件仓库的信息.参见profiles/profile/repositories/repository元素的说明 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">pluginRepository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">enabled</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">updatePolicy</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">checksumPolicy</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line">     </span><br><span class="line"><span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">enabled</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">updatePolicy</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">checksumPolicy</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">     </span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">layout</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">pluginRepository</span>&gt;</span></span><br><span class="line">        </span><br><span class="line"><span class="tag">&lt;/<span class="name">pluginRepositories</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">&lt;!--手动激活profiles的列表，按照profile被应用的顺序定义activeProfile。 该元素包含了一组activeProfile元素，每个activeProfile都含有一个profile id。--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--任何在activeProfile中定义的profile id，不论环境设置如何，其对应的 profile都会被激活。--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--如果没有匹配的profile，则什么都不会发生。例如，env-test是一个activeProfile，则在pom.xml（或者profile.xml）中对应id的profile会被激活。--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--如果运行过程中找不到这样一个profile，Maven则会像往常一样运行。  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">activeProfiles</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;<span class="name">activeProfile</span>&gt;</span>env-test<span class="tag">&lt;/<span class="name">activeProfile</span>&gt;</span></span><br><span class="line">   </span><br><span class="line"><span class="tag">&lt;/<span class="name">activeProfiles</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>上面的配置文件对各个节点的含义及作用都有注解。实际应用中，经常使用的是<code>&lt;localRepository&gt;</code>、<code>&lt;servers&gt;</code>、<code>&lt;mirrors&gt;</code>、<code>&lt;profiles&gt;</code>有限几个节点，其他节点使用默认值足够应对大部分的应用场景。<profile>节点在仓库的配置一节中，已经对setting.xml中的常用节点做了详细的说明。在这里需要特别介绍一下的是<code>&lt;profile&gt;</code>节点的配置，<code>profile</code>是maven的一个重要特性。</profile></p><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line">profile可以让maven能够自动适应外部的环境变化，比如同一个项目，在linux下编译linux的版本，在win下编译win的版本等。一个项目可以设置多个profile，也可以在同一时间设置多个profile被激活（active）的。自动激活的 profile的条件可以是各种各样的设定条件，组合放置在activation节点中，也可以通过命令行直接指定。如果认为profile设置比较复杂，可以将所有的profiles内容移动到专门的 ```profiles.xml``` 文件中，不过记得和pom.xml放在一起。</span><br><span class="line"></span><br><span class="line">activation节点是设置该profile在什么条件下会被激活，常见的条件有如下几个：</span><br><span class="line"></span><br><span class="line">1.&nbsp;&nbsp; os</span><br><span class="line"></span><br><span class="line">判断操作系统相关的参数，它包含如下可以自由组合的子节点元素</span><br><span class="line"></span><br><span class="line">message - 规则失败之后显示的消息</span><br><span class="line"></span><br><span class="line">arch - 匹配cpu结构，常见为x86</span><br><span class="line"></span><br><span class="line">family - 匹配操作系统家族，常见的取值为：dos，mac，netware，os/2，unix，windows，win9x，os/400等</span><br><span class="line"></span><br><span class="line">name - 匹配操作系统的名字</span><br><span class="line"></span><br><span class="line">version - 匹配的操作系统版本号</span><br><span class="line"></span><br><span class="line">display - 检测到操作系统之后显示的信息</span><br><span class="line"></span><br><span class="line">2.&nbsp;&nbsp; jdk</span><br><span class="line"></span><br><span class="line">检查jdk版本，可以用区间表示。</span><br><span class="line"></span><br><span class="line">3.&nbsp;&nbsp; property</span><br><span class="line"></span><br><span class="line">检查属性值，本节点可以包含name和value两个子节点。</span><br><span class="line"></span><br><span class="line">4.&nbsp;&nbsp; file</span><br><span class="line"></span><br><span class="line">检查文件相关内容，包含两个子节点：exists和missing，用于分别检查文件存在和不存在两种情况。</span><br><span class="line"></span><br><span class="line">如果settings中的profile被激活，那么它的值将覆盖POM或者profiles.xml中的任何相等ID的profiles。</span><br><span class="line">一个简单的多环境profiles 配置</span><br><span class="line"></span><br><span class="line">```xml</span><br><span class="line"> &lt;profiles&gt;</span><br><span class="line">        &lt;profile&gt;</span><br><span class="line">            &lt;id&gt;local&lt;/id&gt;</span><br><span class="line">            &lt;activation&gt;</span><br><span class="line">                &lt;activeByDefault&gt;true&lt;/activeByDefault&gt;</span><br><span class="line">            &lt;/activation&gt;</span><br><span class="line">            &lt;properties&gt;</span><br><span class="line">                &lt;profile.name&gt;local&lt;/profile.name&gt;</span><br><span class="line">            &lt;/properties&gt;</span><br><span class="line">        &lt;/profile&gt;</span><br><span class="line">        &lt;profile&gt;</span><br><span class="line">            &lt;id&gt;dev&lt;/id&gt;</span><br><span class="line">            &lt;properties&gt;</span><br><span class="line">                &lt;profile.name&gt;dev&lt;/profile.name&gt;</span><br><span class="line">            &lt;/properties&gt;</span><br><span class="line">        &lt;/profile&gt;</span><br><span class="line">        &lt;profile&gt;</span><br><span class="line">            &lt;id&gt;test&lt;/id&gt;</span><br><span class="line">            &lt;properties&gt;</span><br><span class="line">                &lt;profile.name&gt;test&lt;/profile.name&gt;</span><br><span class="line">            &lt;/properties&gt;</span><br><span class="line">        &lt;/profile&gt;</span><br><span class="line">        &lt;profile&gt;</span><br><span class="line">            &lt;id&gt;prod&lt;/id&gt;</span><br><span class="line">            &lt;properties&gt;</span><br><span class="line">                &lt;profile.name&gt;prod&lt;/profile.name&gt;</span><br><span class="line">            &lt;/properties&gt;</span><br><span class="line">        &lt;/profile&gt;</span><br><span class="line">    &lt;/profiles&gt;</span><br></pre></td></tr></tbody></table></figure><p>如果想要某个profile默认处于激活状态，可以在<activeprofiles>中将该profile的id放进去。这样，不论环境设置如何，其对应的&nbsp;profile都会被激活。<strong>更多激活配置，可以参考官方的例子：<a href="http://maven.apache.org/guides/introduction/introduction-to-profiles.html">http://maven.apache.org/guides/introduction/introduction-to-profiles.html</a></strong></activeprofiles></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Maven </category>
          
      </categories>
      
      
        <tags>
            
            <tag> maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maven-仓库</title>
      <link href="/post/164885520/"/>
      <url>/post/164885520/</url>
      
        <content type="html"><![CDATA[<p>在 Maven 的术语中，仓库是一个位置（place）。Maven 仓库是项目中依赖的第三方库，这个库所在的位置叫做仓库。在 Maven 中，任何一个依赖、插件或者项目构建的输出，都可以称之为构件。Maven 仓库能帮助我们管理构件（主要是JAR），它就是放置所有JAR文件（WAR，ZIP，POM等等）的地方。Maven 仓库有三种类型：</p><ul><li>本地（local）</li><li>中央（central）</li><li>远程（remote）</li></ul><hr><h3 id="本地仓库">本地仓库<a class="" href="#本地仓库"></a></h3><p>Maven一个很突出的功能就是jar包管理，一旦工程需要依赖哪些jar包，只需要在Maven的<code>pom.xml</code>配置一下，该jar包就会自动引入工程目录。初次听来会觉得很神奇，下面我们来探究一下它的实现原理。</p><p>首先，这些jar包肯定不是没爹没娘的孩子，它们有来处，也有去处。集中存储这些jar包（还有插件等）的地方被称之为仓库（<code>Repository</code>）。不管这些jar包从哪里来的，必须存储在自己的电脑里之后，你的工程才能引用它们。类似于电脑里有个客栈，专门款待这些远道而来的客人，这个客栈就叫做本地仓库。</p><p>比如，工程中需要依赖<code>spring-core</code>这个jar包，在<code>pom.xml</code>中声明之后，maven会首先在本地仓库中找，如果找到了很好办，自动引入工程的依赖lib库即可。可是，万一找不到呢？实际上这种情况经常发生，尤其初次使用maven的时候，本地仓库肯定是空无一物的，这时候就要靠maven大展神通，去远程仓库去下载。</p><p>默认情况下，不管Linux还是 Windows，每个用户在自己的用户目录下都有一个路径名为 <code>.m2/respository/</code> 的仓库目录。Maven 本地仓库默认被创建在 用户目录下。要修改默认位置，在 Maven安装目录中的 <code>conf</code>文件夹下的 <code>settings.xml</code> 文件中定义另一个路径。</p><figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/SETTINGS/1.0.0"</span></span></span><br><span class="line"><span class="tag">   <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">   <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/SETTINGS/1.0.0 </span></span></span><br><span class="line"><span class="tag"><span class="string">   http://maven.apache.org/xsd/settings-1.0.0.xsd"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">localRepository</span>&gt;</span>C:/MyLocalRepository<span class="tag">&lt;/<span class="name">localRepository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h3 id="中央仓库">中央仓库<a class="" href="#中央仓库"></a></h3><p>Maven 中央仓库是由 Maven 社区提供的仓库，其中包含了大量常用的库。</p><p>中央仓库包含了绝大多数流行的开源Java构件，以及源码、作者信息、SCM、信息、许可证信息等。一般来说，简单的Java项目依赖的构件都可以在这里下载到。</p><p>中央仓库的关键概念：</p><ul><li>这个仓库由 Maven 社区管理。</li><li>不需要配置。</li><li>需要通过网络才能访问。</li></ul><p>要浏览中央仓库的内容，maven 社区提供了一个 URL：<a href="http://search.maven.org/#browse">http://search.maven.org/#browse</a>。使用这个仓库，开发人员可以搜索所有可以获取的代码库。</p><h3 id="远程仓库">远程仓库<a class="" href="#远程仓库"></a></h3><p>如果 Maven 在中央仓库中也找不到依赖的文件，它会停止构建过程并输出错误信息到控制台。为避免这种情况，Maven 提供了远程仓库的概念，它是开发人员自己定制仓库，包含了所需要的代码库或者其他工程中用到的 jar 文件。</p><p>一般来讲，公司都会通过自己的私有服务器在局域网内架设一个仓库代理。私服可以看作一种特殊的远程仓库，代理广域网上的远程仓库，供局域网内的Maven用户使用。当Maven需要下载构件的时候，先从私服请求，如果私服上不存在该构件，则从外部的远程仓库下载，缓存在私服上之后，再为Maven的下载请求提供服务。<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/images/post/2020/08/1240-20200803115915100.png" alt="Maven 远程仓库">Maven私服有很多好处：</p><ul><li><p>可以把公司的私有jar包，以及无法从外部仓库下载到的构件上传到私服上，供公司内部使用；</p></li><li><p>节省自己的外网带宽：减少重复请求造成的外网带宽消耗；</p></li><li><p>加速Maven构建：如果项目配置了很多外部远程仓库的时候，构建速度就会大大降低；</p></li><li><p>提高稳定性，增强控制：Internet不稳定的时候，maven构建也会变的不稳定，一些私服软件还提供了其他的功能</p></li></ul><p>当前主流的maven私服有Apache的Archiva、JFrog的Artifactory以及Sonatype的Nexus。</p><p>上面提到的中央仓库、中央仓库的镜像仓库、其他公共仓库、私服都属于远程仓库的范畴。</p><h3 id="Maven-依赖搜索顺序">Maven 依赖搜索顺序<a class="" href="#Maven-依赖搜索顺序"></a></h3><p>当我们执行 Maven 构建命令时，Maven 开始按照以下顺序查找依赖的库：</p><p>1.在本地仓库中搜索，如果找不到，执行步骤 2，如果找到了则执行其他操作。2.在中央仓库中搜索，如果找不到，并且有一个或多个远程仓库已经设置，则执行步骤 4，如果找到了则下载到本地仓库中已被将来引用。3.如果远程仓库没有被设置，Maven 将简单的停滞处理并抛出错误（无法找到依赖的文件）。4.在一个或多个远程仓库中搜索依赖的文件，如果找到则下载到本地仓库已被将来引用，否则 Maven 将停止处理并抛出错误（无法找到依赖的文件）。</p><h3 id="仓库的配置">仓库的配置<a class="" href="#仓库的配置"></a></h3><p>仓库配置要做两件事，一是告诉maven你的本地仓库在哪里，二是你的远程仓库在哪里。</p><p>顾名思义，<code>setting.xm</code>的第一个节点<code>&lt;localRepository&gt;</code>就是配置本地仓库的地方，不用赘言。</p><p>远程仓库的配置有些复杂，因为会涉及很多附属特性。下面以一切从实际出发，看看使用私服的情况下如何配置远程仓库。稍微像样的公司都会建立自己的私服，如果一个公司连自己的私服都没有（别管是因为买不起服务器还是技术上做不到），你可以考虑一下跳槽的问题了。</p><p>现在最流行的maven仓库管理器就是大名鼎鼎的Nexus（发音[ˈnɛksəs]，英文中代表“中心、魔枢”的意思），它极大地简化了自己内部仓库的维护和外部仓库的访问。利用Nexus可以只在一个地方就能够完全控制访问和部署在你所维护仓库中的每个Artifact。Nexus是一套“开箱即用”的系统不需要数据库，它使用文件系统加Lucene来组织数据。</p><p>至于Nexus怎么部署，怎么维护仓库，作为开发人员是不需要关心的，只需要把Nexus私服的局域网地址写入maven的本地配置文件即可。具体的配置方法如下：</p><p>1、设置镜像</p><figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirrors</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!--该镜像的唯一标识符。id用来区分不同的mirror元素。 --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- 镜像名，起注解作用，应做到见文知意。可以不配置  --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">name</span>&gt;</span>Human Readable Name <span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!--  所有仓库的构件都要从镜像下载  --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>*<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- 私服的局域网地址--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://192.168.0.1:8081/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirrors</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>节点<code>&lt;mirrors&gt;</code>下面可以配置多个镜像，<code>&lt;mirrorOf&gt;</code>用于指明是哪个仓库的镜像，上例中使用通配符 <code>*</code> 表明该私服是所有仓库的镜像，不管本地使用了多少种远程仓库，需要下载构件时都会从私服请求。</p><p>如果只想将私服设置成某一个远程仓库的镜像，使用<code>&lt;mirrorOf&gt;</code>指定该远程仓库的ID即可。</p><p>2、设置远程仓库远程仓库的设置是在<profile>节点下面：</profile></p><figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">   <span class="comment">&lt;!--仓库唯一标识 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span>&gt;</span>repoId <span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">   <span class="comment">&lt;!--远程仓库名称  --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>repoName<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">&lt;!--远程仓库URL，如果该仓库配置了镜像，这里的URL就没有意义了，因为任何下载请求都会交由镜像仓库处理，前提是镜像（也就是设置好的私服）需要确保该远程仓库里的任何构件都能通过它下载到  --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://……<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">   <span class="comment">&lt;!--如何处理远程仓库里发布版本的下载 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">&lt;!--true或者false表示该仓库是否为下载某种类型构件（发布版，快照版）开启。   --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>false<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">&lt;!-- 该元素指定更新发生的频率。Maven会比较本地POM和远程POM的时间戳。这里的选项是：--&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- always（一直），daily（默认，每日），interval：X（这里X是以分钟为单位的时间间隔），或者never（从不）。  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">updatePolicy</span>&gt;</span>always<span class="tag">&lt;/<span class="name">updatePolicy</span>&gt;</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">&lt;!--当Maven验证构件校验文件失败时该怎么做:--&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--ignore（忽略），fail（失败），或者warn（警告）。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">checksumPolicy</span>&gt;</span>warn<span class="tag">&lt;/<span class="name">checksumPolicy</span>&gt;</span></span><br><span class="line">         </span><br><span class="line">  <span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">   <span class="comment">&lt;!--如何处理远程仓库里快照版本的下载，与发布版的配置类似 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span>     </span><br><span class="line">    <span class="tag">&lt;<span class="name">enabled</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">updatePolicy</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">checksumPolicy</span>/&gt;</span>      </span><br><span class="line">  <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">      </span><br><span class="line"><span class="tag">&lt;/<span class="name">repository</span>&gt;</span>    </span><br><span class="line"><span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>可以配置多个远程仓库，用<id>加以区分。</id></p><p>除此之外，还有一个与<code>&lt;repositories&gt;</code>并列存在<code>&lt;pluginRepositories&gt;</code>节点，用来配置插件的远程仓库。</p><p>仓库主要存储两种构件。第一种构件被用作其它构件的依赖，最常见的就是各类jar包。这是中央仓库中存储的大部分构件类型。另外一种构件类型是插件，Maven插件是一种特殊类型的构件。由于这个原因，插件仓库独立于其它仓库。<code>&lt;pluginRepositories&gt;</code>节点与<code>&lt;repositories&gt;</code>节点除了根节点的名字不一样，子元素的结构与配置方法完全一样：</p><figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">pluginRepositories</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">pluginRepository</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">             <span class="tag">&lt;<span class="name">id</span> /&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">name</span> /&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">url</span> /&gt;</span></span><br><span class="line"> </span><br><span class="line">             <span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">enabled</span> /&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">updatePolicy</span> /&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">checksumPolicy</span> /&gt;</span></span><br><span class="line">             <span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line">                  </span><br><span class="line">             <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">enabled</span> /&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">updatePolicy</span> /&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">checksumPolicy</span> /&gt;</span></span><br><span class="line">             <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span>     </span><br><span class="line"> </span><br><span class="line">      <span class="tag">&lt;/<span class="name">pluginRepository</span>&gt;</span>             </span><br><span class="line"><span class="tag">&lt;/<span class="name">pluginRepositories</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>远程仓库有<code>releases</code>和<code>snapshots</code>两组配置，POM就可以在每个单独的仓库中，为每种类型的构件采取不同的策略。例如，有时候会只为开发目的开启对快照版本下载的支持，就需要把<code>&lt;releases&gt;</code>中的<code>&lt;enabled &gt;</code>设为<code>false</code>，而<code>&lt;snapshots&gt;</code>中的<code>&lt;enabled &gt;</code>设为<code>true</code>。</p><p>由于远程仓库的配置是挂在<code>&lt;profile&gt;</code>节点下面，如果配置有多个<code>&lt;profile&gt;</code>节点，那么就可能有多种远程仓库的设置方案，该方案是否生效是由它的父节点<code>&lt;profile&gt;</code>是否被激活决定的。</p><p>3、设置发布权限私服的作用除了可以给全公司的人提供maven构件的下载，还有一个非常重要的功能，就是开发者之间的资源共享。</p><p>一个大的项目往往是分模块进行开发的，各个模块之间存在依赖关系，比如一个交易系统，分为下单模块、支付模块、购物车模块等。现在开发下单模块的同学需要调用支付模块中的接口来完成支付功能，就需要将支付模块的某些jar包引入本地工程，才能调用它的接口；同时，开发购物车模块的同学需要调用下单模块的接口，来完成下单功能，他就需要依赖下单模块的某些jar包。这三个模块都在持续开发中，不可能将各自的源码传来传去支持对方的依赖。</p><p>解决的方式是这样，每个模块完成了某个阶段性的功能，都会将提供对外服务的接口打成jar包，传到公司的私服当中，谁要使用该模块的功能，只需要在pom.xml文件中声明一下，maven就会像下载其他jar包那样把它引入你的工程。</p><p>在开发过程中，在pom中声明的构件版本一般是快照版：</p><figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.yourCompany.trade<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>trade-pay<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.2-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>各个模块会不断的上传新的jar包，如果本地项目依赖的是快照版，那么maven一旦发现该jar包有新的发布，就会将它下载下来替代以前的旧版本。比如，支付模块在测试的时候发现有个bug，修复了一下，然后将快照版发布到私服。而你只需要专注于下单模块的开发，所依赖的支付模块的更新由maven处理，不需要关心。一旦你开发的模块修复了一个bug，或者添加了一个新功能等修改，只需要将发布一次快照版本到私服即可，谁需要依赖你的接口谁自然会去私服下载，你也不用关心。一般私服建立完毕之后不需要认证就可以访问，但是风险会很大，这时就需要使用<code>setting.xml</code>中的<code>servers</code>元素了。需要注意的是，配置私服的信息是在pom文件中，但是认证信息则是在<code>setting.xml</code>中，这是因为pom文件往往是被提交到代码仓库中供所有成员访问的，而<code>setting.xml</code>是存放在本地的，这样是安全的。</p><p>在<code>settings.xm</code>l中，配置具有发布发布版本和快照版本权限的用户：<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/images/post/2020/08/1240-20200803121850867.png" alt="server配置"></p><p>上面的id是server的id，不是用户登陆的id，该id与distributionManagement中repository元素的id相匹配。maven是根据pom中的repository和distributionMnagement元素来找到匹配的发布地址：<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/images/post/2020/08/1240-20200803121907372.png" alt="项目配置"></p><p>注意：pom中的id必须与setting.xml中配置好的id一致。</p><p>然后运行maven cleandeploy命令，将自己开发的构件部署在私服上供组织内其他用户使用（maven clean deploy和maven clean install的区别：deploy是将该构件部署在私服中，而install是将构件存入自己的本地仓库中）。</p><p>在这里有人可能会有一个疑问，所有的仓库设置不是已经在setting.xml中配置好了吗，为什么在pom的发布管理节点当中还要配置一个url？</p><p>Setting.xml中配置的是你从哪里下载构件，而这里配置的是你要将构件发布到哪里。有时候可能下载用的仓库与上传用的仓库是两个地址，但是绝大多数情况下，两者都是由私服充当，就是说两者是同一个地址。</p><blockquote><p>补充：Maven 仓库默认在国外， 国内使用难免很慢，我们可以更换为阿里云的仓库。第一步:修改 maven 根目录下的 conf 文件夹中的 setting.xml 文件，在 mirrors 节点上，添加内容如下：</p><figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line">&gt;<span class="tag">&lt;<span class="name">mirrors</span>&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span>&gt;</span>alimaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span>        </span><br><span class="line">&gt;<span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;/<span class="name">mirrors</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>第二步: pom.xml文件里添加：</p><figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line">&gt;<span class="tag">&lt;<span class="name">repositories</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">repository</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>alimaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;<span class="name">releases</span>&gt;</span>  </span><br><span class="line">          <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;/<span class="name">releases</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span>  </span><br><span class="line">          <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>false<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">repository</span>&gt;</span>  </span><br><span class="line">&gt;<span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure></blockquote><blockquote><p>Maven 的 Snapshot 版本与 Release 版本1、Snapshot 版本代表不稳定、尚处于开发中的版本。2、Release 版本则代表稳定的版本。3、什么情况下该用 SNAPSHOT?协同开发时，如果 A 依赖构件 B，由于 B 会更新，B 应该使用 SNAPSHOT 来标识自己。这种做法的必要性可以反证如下：</p><ul><li>a. 如果 B 不用 SNAPSHOT，而是每次更新后都使用一个稳定的版本，那版本号就会升得太快，每天一升甚至每个小时一升，这就是对版本号的滥用。</li><li>b.如果 B 不用 SNAPSHOT, 但一直使用一个单一的 Release 版本号，那当 B 更新后，A 可能并不会接受到更新。因为 A 所使用的 repository 一般不会频繁更新 release 版本的缓存（即本地 repository)，所以B以不换版本号的方式更新后，A在拿B时发现本地已有这个版本，就不会去远程Repository下载最新的 B</li></ul><p>4、 不用 Release 版本，在所有地方都用 SNAPSHOT 版本行不行？<br>不行。正式环境中不得使用 snapshot 版本的库。 比如说，今天你依赖某个 snapshot 版本的第三方库成功构建了自己的应用，明天再构建时可能就会失败，因为今晚第三方可能已经更新了它的 snapshot 库。你再次构建时，Maven 会去远程 repository 下载 snapshot 的最新版本，你构建时用的库就是新的 jar 文件了，这时正确性就很难保证了。</p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Maven </category>
          
      </categories>
      
      
        <tags>
            
            <tag> maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maven-依赖关系</title>
      <link href="/post/164885521/"/>
      <url>/post/164885521/</url>
      
        <content type="html"><![CDATA[<p>项目的依赖关系主要分为三种：<strong>依赖</strong>，<strong>继承</strong>，<strong>聚合</strong></p><h2 id="依赖关系">依赖关系<a class="" href="#依赖关系"></a></h2><p>依赖关系是最常用的一种，就是你的项目需要依赖其他项目，比如Apache-common包，Spring包等等。</p><figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">type</span> &gt;</span>jar&lt;/ type &gt;</span><br><span class="line">       <span class="tag">&lt;<span class="name">optional</span> &gt;</span>true&lt;/ optional &gt;</span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>任意一个外部依赖说明包含如下几个要素：<code>groupId</code>, <code>artifactId</code>, <code>version</code>, <code>scope</code>, <code>type</code>, <code>optional</code>。其中前3个是必须的。这里的version可以用区间表达式来表示，比如(2.0,)表示&gt;2.0，[2.0,3.0)表示2.0&lt;=ver&lt;3.0；多个条件之间用逗号分隔，比如[1,3],[5,7]。type 一般在pom引用依赖时候出现，其他时候不用。</p><p>maven认为，程序对外部的依赖会随着程序的所处阶段和应用场景而变化，所以maven中的依赖关系有作用域(scope)的限制。在maven中，scope包含如下的取值：</p><table><thead><tr><th>Scope选项</th><th>描述</th></tr></thead><tbody><tr><td>compile（编译范围）</td><td>compile是默认的范围；如果没有提供一个范围，那该依赖的范围就是编译范围。编译范围依赖在所有的classpath中可用，同时它们也会被打包。</td></tr><tr><td>provided（已提供范围）</td><td>provided依赖只有在当JDK或者一个容器已提供该依赖之后才使用。例如，如果你开发了一个web应用，你可能在编译classpath中需要可用 的Servlet API来编译一个servlet，但是你不会想要在打包好的WAR中包含这个Servlet API；这个Servlet API JAR由你的应用服务器或者servlet容器提供。已提供范围的依赖在编译classpath（不是运行时）可用。它们不是传递性的，也不会被打包。</td></tr><tr><td>runtime（运行时范围）</td><td>runtime依赖在运行和测试系统的时候需要，但在编译的时候不需要。比如，你可能在编译的时候只需要JDBC API JAR，而只有在运行的时候才需要JDBC驱动实现</td></tr><tr><td>test（测试范围）</td><td>test范围依赖在编译和运行时都不需要，它们只有在测试编译和测试运行阶段可用。</td></tr><tr><td>system（系统范围）</td><td>system范围依赖与provided类似，但是你必须显式的提供一个对于本地系统中JAR文件的路径。这么做是为了允许基于本地对象编译，而这些对象是系统类库的一部分。这样的构件应该是一直可用的，Maven也不会在仓库中去寻找它。 如果你将一个依赖范围设置成系统范围，你必须同时提供一个systemPath元素 。注意该范围是不推荐使用的（应该一直尽量去从公共或定制的Maven仓库中引用依赖）。</td></tr></tbody></table><p><code>dependency</code>中的<code>type</code>一般不用配置，默认是jar。当type为pom时，代表引用关系：此时，本项目会将<code>persistence-deps</code>的所有jar包导入依赖库。</p><p>可以创建一个打包方式为pom项目来将某些通用的依赖归在一起，供其他项目直接引用，不要忘了指定依赖类型为pom(<type>pom</type>)。</p><h2 id="继承关系">继承关系<a class="" href="#继承关系"></a></h2><p>继承就是避免重复，maven的继承也是这样，它还有一个好处就是让项目更加安全。项目之间存在上下级关系时就属于继承关系。</p><p>父项目的配置如下：</p><figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.clf.parent<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>my-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span> </span><br><span class="line">  </span><br><span class="line">  <span class="comment">&lt;!-- 该节点下的依赖会被子项目自动全部继承 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">type</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 该节点下的依赖关系只是为了统一版本号，不会被子项目自动继承，--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--除非子项目主动引用，好处是子项目可以不用写版本号 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-orm<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.2.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.2.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context-support<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.2.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-beans<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.2.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">       <span class="comment">&lt;!-- 这个元素和dependencyManagement相类似，它是用来进行插件管理的--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">pluginManagement</span>&gt;</span>  </span><br><span class="line">       ......</span><br><span class="line">       <span class="tag">&lt;/<span class="name">pluginManagement</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>注意，此时<code>&lt;packaging&gt;</code>必须为<code>pom</code>。</p><p>为了项目的正确运行，必须让所有的子项目使用依赖项的统一版本，必须确保应用的各个项目的依赖项和版本一致，才能保证测试的和发布是相同的结果。</p><p>Maven 使用dependencyManagement 元素来提供了一种管理依赖版本号的方式。通常会在一个组织或者项目的最顶层的父POM 中看到dependencyManagement 元素。使用pom.xml 中的dependencyManagement 元素能让所有在子项目中引用一个依赖而不用显式的列出版本号。Maven 会沿着父子层次向上走，直到找到一个拥有dependencyManagement元素的项目，然后它就会使用在这个dependencyManagement 元素中指定的版本号。</p><p>父项目在dependencies声明的依赖，子项目会从全部自动地继承。而父项目在dependencyManagement里只是声明依赖，并不实现引入，因此子项目需要显示的声明需要用的依赖。如果不在子项目中声明依赖，是不会从父项目中继承下来的；只有在子项目中写了该依赖项，并且没有指定具体版本，才会从父项目中继承该项，并且version和scope都读取自父pom另外如果子项目中指定了版本号，那么会使用子项目中指定的jar版本。</p><p>如果某个项目需要继承该父项目，基础配置应该这样：</p><figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.clf.parent.son<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>my-son<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span> </span><br><span class="line">  <span class="comment">&lt;!-- 声明将父项目的坐标 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.clf.parent<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>my-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line">  <span class="comment">&lt;!-- 父项目的pom.xml文件的相对路径。相对路径允许你选择一个不同的路径。 --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--默认值是../pom.xml。Maven首先在构建当前项目的地方寻找父项目的pom， --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--其次在文件系统的这个位置（relativePath位置）， --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--然后在本地仓库，最后在远程仓库寻找父项目的pom。 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">relativePath</span>&gt;</span>../parent-project/pom.xml<span class="tag">&lt;/<span class="name">relativePath</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">parent</span>&gt;</span> </span><br><span class="line">  </span><br><span class="line">  <span class="comment">&lt;!-- 声明父项目dependencyManagement的依赖，不用写版本号 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-beans<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>###聚合关系随着技术的飞速发展和各类用户对软件的要求越来越高，软件本身也变得越来越复杂，然后软件设计人员开始采用各种方式进行开发，于是就有了我们的分层架构、分模块开发，来提高代码的清晰和重用。针对于这一特性，maven也给予了相应的配置。</p><p>maven的多模块管理也是非常强大的。一般来说，maven要求同一个工程的所有模块都放置到同一个目录下，每一个子目录代表一个模块，比如</p><p>总项目/&nbsp;  &nbsp;|— &nbsp;pom.xml 总项目的pom配置文件&nbsp; &nbsp;   |— 子模块1/&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;    |—&nbsp;pom.xml 子模块1的pom文件&nbsp;   |—&nbsp; &nbsp;子模块2/&nbsp; &nbsp;    |—&nbsp; &nbsp; &nbsp; pom.xml子模块2的pom文件总项目的配置如下：</p><figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span> </span><br><span class="line">       <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span> </span><br><span class="line">       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.clf.parent<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>my-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line">       <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span> </span><br><span class="line">       </span><br><span class="line">       <span class="comment">&lt;!-- 打包类型必须为pom --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">       </span><br><span class="line">       <span class="comment">&lt;!-- 声明了该项目的直接子模块 --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- 这里配置的不是artifactId，而是这个模块的目录名称--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>module-1<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>module-2<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>module-3<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br><span class="line">       </span><br><span class="line">       <span class="comment">&lt;!-- 聚合也属于父子关系，总项目中的dependencies与dependencyManagement、pluginManagement用法与继承关系类似 --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        ......</span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">       <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">        ......</span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">       <span class="tag">&lt;<span class="name">pluginManagement</span>&gt;</span> </span><br><span class="line">       ......</span><br><span class="line">       <span class="tag">&lt;/<span class="name">pluginManagement</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>子模块的配置如下：</p><figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span> </span><br><span class="line">       <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span> </span><br><span class="line">       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.clf.parent.son<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>my-son<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line">       <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- 声明将父项目的坐标 --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.clf.parent<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">              <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>my-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line">              <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span> </span><br><span class="line">       <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h2 id="继承与聚合的关系">继承与聚合的关系<a class="" href="#继承与聚合的关系"></a></h2><p>首先，继承与聚合都属于父子关系，并且，聚合 POM与继承关系中的父POM的packaging都是pom。</p><p>不同的是，对于聚合模块来说，它知道有哪些被聚合的模块，但那些被聚合的模块不知道这个聚合模块的存在。对于继承关系的父 POM来说，它不知道有哪些子模块继承与它，但那些子模块都必须知道自己的父 POM是什么。</p><p>在实际项目中，一个 POM往往既是聚合POM，又是父 POM，它继承了某个项目，本身包含几个子模块，同时肯定会存在普通的依赖关系，就是说，依赖、继承、聚合这三种关系是并存的。</p><p>Maven可继承的POM 元素列表如下：</p><p>**groupId ：**项目组 ID ，项目坐标的核心元素；</p><p>**version ：**项目版本，项目坐标的核心元素；</p><p>**description ：**项目的描述信息；</p><p>**organization ：**项目的组织信息；</p><p>**inceptionYear ：**项目的创始年份；</p><p>**url ：**项目的 url 地址</p><p>**develoers ：**项目的开发者信息；</p><p>**contributors ：**项目的贡献者信息；</p><p>**distributionManagerment：**项目的部署信息；</p><p>**issueManagement ：**缺陷跟踪系统信息；</p><p>**ciManagement ：**项目的持续继承信息；</p><p>**scm ：**项目的版本控制信息；</p><p>**mailingListserv ：**项目的邮件列表信息；</p><p>**properties ：**自定义的 Maven 属性；</p><p>**dependencies ：**项目的依赖配置；</p><p>**dependencyManagement：**醒目的依赖管理配置；</p><p>**repositories ：**项目的仓库配置；</p><p>**build ：**包括项目的源码目录配置、输出目录配置、插件配置、插件管理配置等；</p><p>**reporting ：**包括项目的报告输出目录配置、报告插件配置等。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Maven </category>
          
      </categories>
      
      
        <tags>
            
            <tag> maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maven-初识</title>
      <link href="/post/164885522/"/>
      <url>/post/164885522/</url>
      
        <content type="html"><![CDATA[<h2 id="Maven简介">Maven简介<a class="" href="#Maven简介"></a></h2><p>Maven在美国口语中是<code>专家、内行</code> 的意思，是<code>Apache</code>下的一个纯 Java 开发的开源项目。基于项目对象模型<code>Project Object Model</code>（缩写：POM）概念，Maven利用一个中央信息片断能管理一个项目的构建、报告和文档等步骤。</p><blockquote><p>Maven是一个项目管理工具，它包含了一个项目对象模型 (POM：Project Object Model)，一组标准集合，一个项目生命周期(Project Lifecycle)，一个依赖管理系统(Dependency Management System)，和用来运行定义在生命周期阶段(phase)中插件(plugin)目标(goal)的逻辑。</p></blockquote><p>由于Maven是用Java开发的，因此Maven被更多的用于Java项目中，但也可以使用其它工具来构建项目。</p><h2 id="Maven的功能">Maven的功能<a class="" href="#Maven的功能"></a></h2><p>Maven 能够帮助开发者完成以下工作：</p><ul><li>构建</li><li>测试</li><li>文档生成</li><li>报告</li><li>依赖</li><li>SCMs</li><li>发布</li><li>分发</li><li>邮件列表</li></ul><h2 id="约定配置">约定配置<a class="" href="#约定配置"></a></h2><p>Maven 提倡使用一个共同的标准目录结构，Maven 使用约定优于配置的原则，大家尽可能的遵守这样的目录结构。如下所示：<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/images/post/2020/08/1240-20200803122749077.png" alt="maven目录结构">注：如果不是webApp项目将不会存在webapp目录，其余约定将在后文介绍。</p><h2 id="Maven-特点">Maven 特点<a class="" href="#Maven-特点"></a></h2><ul><li>项目设置遵循统一的规则。</li><li>任意工程中共享。</li><li>依赖管理包括自动更新。</li><li>一个庞大且不断增长的库。</li><li>可扩展，能够轻松编写 Java 或脚本语言的插件。</li><li>只需很少或不需要额外配置即可即时访问新功能。</li><li>基于模型的构建 − Maven能够将任意数量的项目构建到预定义的输出类型中，如 JAR，WAR 或基于项目元数据的分发，而不需要在大多数情况下执行任何脚本。</li><li>项目信息的一致性站点 − 使用与构建过程相同的元数据，Maven 能够生成一个网站或PDF，包括您要添加的任何文档，并添加到关于项目开发状态的标准报告中。</li><li>发布管理和发布发布 − Maven 将不需要额外的配置，就可以与源代码管理系统（如 Subversion 或 Git）集成，并可以基于某个标签管理项目的发布。它也可以将其发布到分发位置供其他项目使用。Maven能够发布单独的输出，如 JAR，包含其他依赖和文档的归档，或者作为源代码发布。</li><li>向后兼容性 − 您可以很轻松的从旧版本 Maven 的多个模块移植到 Maven 3 中。</li><li>子项目使用父项目依赖时，正常情况子项目应该继承父项目依赖，无需使用版本号，</li><li>并行构建 − 编译的速度能普遍提高20 - 50 %。</li><li>更好的错误报告 − Maven 改进了错误报告，它为您提供了 Maven wiki 页面的链接，您可以点击链接查看错误的完整描述。</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Maven </category>
          
      </categories>
      
      
        <tags>
            
            <tag> maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maven-命令</title>
      <link href="/post/164885523/"/>
      <url>/post/164885523/</url>
      
        <content type="html"><![CDATA[<p>前篇已经讲过，Maven本质上是一个插件框架，并不执行任何具体的构建任务，它把所有这些任务都交给插件来完成。</p><p>作为开发利器的maven，为我们提供了十分丰富的命令，了解maven的命令行操作并熟练运用常见的maven命令还是十分必要的，即使譬如IDEA等工具给我提供了图形界面化工具，但其底层还是依靠maven命令来驱动的。因此，知其然，知其所以然，方能百战不殆。</p><p><em>Maven的命令格式如下：</em></p><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">mvn [plugin-name]:[goal-name]</span><br></pre></td></tr></tbody></table></figure><p>该命令的意思是：执行<code>plugin-name</code>插件的<code>goal-name</code>目标。</p><p>用户可以通过两种方式调用Maven插件的目标：</p><ol><li>将插件目标与生命周期阶段<code>lifecycle phase</code>绑定，这样用户在命令行只是输入生命周期阶段而已，例如Maven默认将<code>maven-compiler-plugin</code>的<code>compile</code>目标与<code>compile</code>生命周期阶段绑定，因此命令<code>mvn compile</code>实际上是先定位到<code>compile</code>这一生命周期阶段，然后再根据绑定关系调用<code>maven-compiler-plugin</code>的<code>compile</code>目标。</li><li>直接在命令行指定要执行的插件目标，例如<code>mvnarchetype:generate </code>就表示调用<code>maven-archetype-plugin</code>的<code>generate</code>目标，这种带冒号的调用方式与生命周期无关。</li></ol><h3 id="常用命令">常用命令<a class="" href="#常用命令"></a></h3><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>mvn –version</td><td>显示版本信息</td></tr><tr><td>mvn clean</td><td>清理项目生产的临时文件,一般是模块下的target目录</td></tr><tr><td>mvn compile</td><td>编译源代码，一般编译模块下的src/main/java目录</td></tr><tr><td>mvn package</td><td>项目打包工具,会在模块下的target目录生成jar或war等文件</td></tr><tr><td>mvn test</td><td>测试命令,或执行src/test/java/下junit的测试用例.</td></tr><tr><td>mvn install</td><td>将打包的jar/war文件复制到你的本地仓库中,供其他模块使用</td></tr><tr><td>mvn deploy</td><td>将打包的文件发布到远程参考,提供其他人员进行下载依赖</td></tr><tr><td>mvn site</td><td>生成项目相关信息的网站</td></tr><tr><td>mvn eclipse:eclipse</td><td>将项目转化为Eclipse项目</td></tr><tr><td>mvn dependency:tree</td><td>打印出项目的整个依赖树</td></tr><tr><td>mvn archetype:generate</td><td>创建Maven的普通java项目</td></tr><tr><td>mvn tomcat:run</td><td>在tomcat容器中运行web应用</td></tr><tr><td>mvn jetty:run</td><td>调用 Jetty 插件的 Run 目标在 Jetty Servlet 容器中启动 web 应用</td></tr></tbody></table><blockquote><p>注意：运行maven命令的时候，首先需要定位到maven项目的目录，也就是项目的pom.xml文件所在的目录。否则，必以通过参数来指定项目的目录。</p><h3 id="命令参数">命令参数<a class="" href="#命令参数"></a></h3><p>上面列举的只是比较通用的命令，其实很多命令都可以携带参数以执行更精准的任务。Maven命令可携带的参数类型如下：</p><h6 id="1-D-传入属性参数">1.   -D 传入属性参数<a class="" href="#1-D-传入属性参数"></a></h6><p>比如命令：<code>mvn package -Dmaven.test.skip=true</code>以<code>-D</code>开头，将<code>maven.test.skip</code>的值设为<code>true</code>,就是告诉maven打包的时候跳过单元测试。同理，<code>mvn deploy-Dmaven.test.skip=true</code>代表部署项目并跳过单元测试。</p><h6 id="2-P-使用指定的Profile配置">2.   -P 使用指定的Profile配置<a class="" href="#2-P-使用指定的Profile配置"></a></h6><p>比如项目开发需要有多个环境，一般为开发，测试，预发，正式4个环境，在pom.xml中的配置如下：</p><figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line">&gt;<span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">id</span>&gt;</span>dev<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">env</span>&gt;</span>dev<span class="tag">&lt;/<span class="name">env</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">id</span>&gt;</span>qa<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">env</span>&gt;</span>qa<span class="tag">&lt;/<span class="name">env</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">id</span>&gt;</span>pre<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">env</span>&gt;</span>pre<span class="tag">&lt;/<span class="name">env</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">id</span>&gt;</span>prod<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">env</span>&gt;</span>prod<span class="tag">&lt;/<span class="name">env</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br><span class="line">&gt;......</span><br><span class="line">&gt;<span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;<span class="name">filters</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">filter</span>&gt;</span>config/${env}.properties<span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;/<span class="name">filters</span>&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>true<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line">&gt;......</span><br><span class="line">&gt;<span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p><code>profiles</code>定义了各个环境的变量<code>id</code>，<code>filters</code>中定义了变量配置文件的地址，其中地址中的环境变量就是上面<code>profile</code>中定义的值，<code>resources</code>中是定义哪些目录下的文件会被配置文件中定义的变量替换。通过maven可以实现按不同环境进行打包部署，命令为:</p><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">&gt;mvn package -P dev</span><br></pre></td></tr></tbody></table></figure><p>其中<code>dev</code>为环境的变量id,代表使用Id为<code>dev</code>的<code>profile</code>。</p><h6 id="3-e-显示maven运行出错的信息">3.  -e 显示maven运行出错的信息<a class="" href="#3-e-显示maven运行出错的信息"></a></h6><h6 id="4-o-离线执行命令-即不去远程仓库更新包">4.  -o 离线执行命令,即不去远程仓库更新包<a class="" href="#4-o-离线执行命令-即不去远程仓库更新包"></a></h6><h6 id="5-X-显示maven允许的debug信息">5.   -X 显示maven允许的debug信息<a class="" href="#5-X-显示maven允许的debug信息"></a></h6><h6 id="6-U-强制去远程更新snapshot的插件或依赖，默认每天只更新一次">6.   -U 强制去远程更新snapshot的插件或依赖，默认每天只更新一次<a class="" href="#6-U-强制去远程更新snapshot的插件或依赖，默认每天只更新一次"></a></h6></blockquote><h4 id="maven命令实例">maven命令实例<a class="" href="#maven命令实例"></a></h4><p>下面结合几个实例来看看maven命令的使用方法。</p><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">archetype:create &amp; archetype:generate</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line">```archetype:create```是maven 3.0.5之前创建项目的命令，例如创建一个普通的Java项目：</span><br><span class="line"></span><br><span class="line">```shell</span><br><span class="line">mvn archetype:create -DgroupId=packageName -DartifactId=projectName -Dversion=1.0.0-SNAPSHOT</span><br></pre></td></tr></tbody></table></figure><p>后面的三个参数用于指定项目的<code>groupId</code>、<code>artifactId</code>以及<code>version</code>。</p><p>创建Maven的Web项目：</p><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">mvn archetype:create -DgroupId=packageName -DartifactId=projectName -DarchetypeArtifactId=maven-archetype-webapp</span><br></pre></td></tr></tbody></table></figure><p><code>archetypeArtifactId</code>参数用于指定使用哪个maven原型，这里使用的是<code>maven-archetype-webapp</code>，maven会按照web应用的目录结构生成项目。</p><p>需要注意的是，在maven 3.0.5之后，archetype:create命令不在使用，取而代之的是archetype:generate命令。</p><blockquote><p>Eclipse Maven运行操作<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/images/2020/08/1240-20200803020407057.png" alt="eclipse"></p><p>IDEA Maven运行操作<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/images/2020/08/1240-20200803020426580.png" alt="IDEA">都要选择在运行的项目的pom文件目录</p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Maven </category>
          
      </categories>
      
      
        <tags>
            
            <tag> maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式 - 简单工厂模式</title>
      <link href="/post/164885719/"/>
      <url>/post/164885719/</url>
      
        <content type="html"><![CDATA[<p>简单工厂模式严格来说并不是一个设计模式，反而较像是一种编程习惯。</p><h2 id="定义">定义<a class="" href="#定义"></a></h2><p>简单工厂模式(<code>Simple Factory Pattern</code>)：又称为静态工厂方法(<code>Static Factory Method</code>)模式，它属于类创建型模式。在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。</p><h2 id="结构">结构<a class="" href="#结构"></a></h2><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/images/post/2020/08/1240-20200803145807841.png" alt="简单工厂"></p><p>简单工厂包含了一下角色：</p><ul><li><p><strong>Factory: 工厂角色</strong>负责根据不同的参数创建不同的实例。</p></li><li><p><strong>IProduct: 抽象产品角色</strong>所有产品实例的接口，负责描述所有产品实例的行为。</p></li><li><p><strong>Product(A B …): 具象产品角色</strong>所有产品的实例，实现了抽象产品定义的代码</p></li></ul><h2 id="场景示例">场景示例<a class="" href="#场景示例"></a></h2><p>简单工厂应用的场景比较对，那么就根据作者的理解，拿作者工作中遇到的场景需求举例：平台做一个机票代购业务，对接了两个供应商A、B，用户选择完机票后，平台拿着机票去供应商下单。下单时根据机票由那个供应商提供去相应的供应商去下单。</p><p>第一步就是定义一个下单接口。</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IVender</span> </span>{</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 供应商下单方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">order</span><span class="params">()</span></span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>然后分别实现A、B供应商的下单方法。</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VendorA</span> <span class="keyword">implements</span> <span class="title">IVender</span> </span>{</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">order</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="comment">// 业务逻辑处理</span></span><br><span class="line">        System.out.println(<span class="string">"A供应商下单成功,下单时间"</span> + <span class="keyword">new</span> Date());</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VendorB</span> <span class="keyword">implements</span> <span class="title">IVender</span> </span>{</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">order</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="comment">// 业务逻辑处理</span></span><br><span class="line">        System.out.println(<span class="string">"B供应商下单成功，下单时间："</span> + <span class="keyword">new</span> Date());</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>接着定义一个工厂类，根据传入的不同参数请求，分别创建不同的供应商实例并返回，若碰到无效的参数，则抛出异常。</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VendorFactory</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IVender <span class="title">createVendor</span><span class="params">(String type)</span> </span>{</span><br><span class="line">        <span class="keyword">switch</span> (type) {</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"A"</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> VendorA();</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"B"</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> VendorB();</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"供应商不存在"</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>最后，由我们客户端进行调用：</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        String type = <span class="string">"A"</span>;</span><br><span class="line">        IVender iVender = VendorFactory.createVendor(type);</span><br><span class="line">        iVender.order();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>如果我们都写在一个类中：</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client2</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TYPE_A = <span class="string">"A"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TYPE_B = <span class="string">"B"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        String type = <span class="string">"A"</span>;</span><br><span class="line">        <span class="keyword">if</span> (Objects.equals(TYPE_A, type)) {</span><br><span class="line">            <span class="comment">// A 供应商下单逻辑处理</span></span><br><span class="line">            System.out.println(<span class="string">"A供应商下单成功,下单时间"</span> + <span class="keyword">new</span> Date());</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (Objects.equals(TYPE_B, type)) {</span><br><span class="line">            <span class="comment">// B 供应商下单逻辑处理</span></span><br><span class="line">            System.out.println(<span class="string">"A供应商下单成功,下单时间"</span> + <span class="keyword">new</span> Date());</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"供应商不存在"</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>第二种写法，供应商下单逻辑较多的话会使客户端变得十分复杂，后期维护起来也将是一个灾难。如果新增加一个供应商，将会对这个类有这较大的改动，很明显的违反了<code>开闭原则</code>与<code>迪米特法则</code>。</p><h2 id="优点">优点<a class="" href="#优点"></a></h2><ul><li>工厂类含有必要的判断逻辑，可以决定在什么时候创建哪一个产品类的实例，客户端可以免除直接创建产品对象的责任，而仅仅“消费”产品；简单工厂模式通过这种做法实现了对责任的分割，它提供了专门的工厂类用于创建对象。</li><li>客户端无须知道所创建的具体产品类的类名，只需要知道具体产品类所对应的参数即可，对于一些复杂的类名，通过简单工厂模式可以减少使用者的记忆量。</li><li>通过引入配置文件，可以在不修改任何客户端代码的情况下更换和增加新的具体产品类，在一定程度上提高了系统的灵活性。</li></ul><h2 id="缺点">缺点<a class="" href="#缺点"></a></h2><ul><li>由于工厂类集中了所有产品创建逻辑，一旦不能正常工作，整个系统都要受到影响。</li><li>使用简单工厂模式将会增加系统中类的个数，在一定程序上增加了系统的复杂度和理解难度。</li><li>系统扩展困难，一旦添加新产品就不得不修改工厂逻辑，在产品类型较多时，有可能造成工厂逻辑过于复杂，不利于系统的扩展和维护。</li><li>简单工厂模式由于使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构。</li></ul><h2 id="使用场景">使用场景<a class="" href="#使用场景"></a></h2><p>在以下情况下可以使用简单工厂模式：</p><ul><li>工厂类负责创建的对象比较少：由于创建的对象较少，不会造成工厂方法中的业务逻辑太过复杂。</li><li>客户端只知道传入工厂类的参数，对于如何创建对象不关心：客户端既不需要关心创建细节，甚至连类名都不需要记住，只需要知道类型所对应的参数。</li></ul><h2 id="总结">总结<a class="" href="#总结"></a></h2><ul><li>创建型模式对类的实例化过程进行了抽象，能够将对象的创建与对象的使用过程分离。</li><li>简单工厂模式又称为静态工厂方法模式，它属于类创建型模式。在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。</li><li>简单工厂模式包含三个角色：工厂角色负责实现创建所有实例的内部逻辑；抽象产品角色是所创建的所有对象的父类，负责描述所有实例所共有的公共接口；具体产品角色是创建目标，所有创建的对象都充当这个角色的某个具体类的实例。</li><li>简单工厂模式的要点在于：当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而无须知道其创建细节。</li><li>简单工厂模式最大的优点在于实现对象的创建和对象的使用分离，将对象的创建交给专门的工厂类负责，但是其最大的缺点在于工厂类不够灵活，增加新的具体产品需要修改工厂类的判断逻辑代码，而且产品较多时，工厂方法代码将会非常复杂。</li><li>简单工厂模式适用情况包括：工厂类负责创建的对象比较少；客户端只知道传入工厂类的参数，对于如何创建对象不关心。</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式 - 单例模式</title>
      <link href="/post/164885661/"/>
      <url>/post/164885661/</url>
      
        <content type="html"><![CDATA[<p>在项目开发时有一些对象其实我们只需要一个，比如：线程池、缓存、日志对象等等。这类对象只能有一个实例，如果制造出多个实例，就会导致许多问题产生，例如：程序的行为异常，资源使用过量，或者是不一致的结果。</p><p>虽然程序员之间的约定以及全局变量也可以办得到，但是单例模式确实是经得起时间考验的更好的做法。单例模式和全局变量一样方便的给我们提供了一个全局的访问点，但是也解决了全局变量必须在程序一开始就要创建好对象的缺点。单例模式可以灵活的决定对象什么时候创建。</p><h3 id="结构定义">结构定义<a class="" href="#结构定义"></a></h3><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/images/post/2020/08/1240-20200803144305567.png" alt="单例模式"></p><p><strong>单例模式：</strong> <code>保证一个类仅有一个实例，并且提供一个访问它的全局访问点。</code></p><blockquote><p>通常我们可以让一个全局变量使得一个对象被访问，但它不能防止你实例化多个对象。一个最好的办法就是让类自身负责保存它的唯一实例。这个类可以保证没有其它实例可以被创建,并且它可以提供一个访问该实例的方法。[DP]</p></blockquote><h3 id="单例模式的写法（7种）">单例模式的写法（7种）<a class="" href="#单例模式的写法（7种）"></a></h3><p>单例模式的思路</p><ol><li>利用一个静态变量<code>INSTANCE</code>来记录类的唯一实例</li><li>把构造器声明为私有的，只有在类本身才能调用构造器</li><li>用<code>getInstance()</code>方法实例化对象，并返回这个类的实例</li></ol><blockquote><p>分析：利用静态变量来保存类的实例确保该实例为类的唯一实例，如果实例为空，则表示还没有创建实例，而如果不存在我们就利用私有的构造器产生一个该类实例并把它赋值到静态变量中，如果我们不需要这个实例，它就永远不会产生。这个就是<code>延迟实例化</code></p></blockquote><ul><li><strong>懒汉模式（线程不安全）</strong></li></ul><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>{</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (INSTANCE == <span class="keyword">null</span>) {</span><br><span class="line">            INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这段代码简单明了，而且使用了懒加载模式，但是却存在致命的问题。当有多个线程并行调用 <code>getInstance()</code> 的时候，就会创建多个实例。也就是说在多线程下不能正常工作。</p><ul><li><strong>懒汉模式（线程安全）</strong>解决懒汉模式线程安全问题，最简单的方法是将整个 <code>getInstance()</code> 方法设为同步<code>synchronized</code>。</li></ul><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>{</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (INSTANCE == <span class="keyword">null</span>) {</span><br><span class="line">            INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>虽然做到了线程安全，并且解决了多实例的问题，但是它并不高效。因为在任何时候只能有一个线程调用 <code>getInstance() </code>方法。但是同步操作只需要在第一次调用时才被需要，即第一次创建单例实例对象时。这就引出了双重检验锁。</p><ul><li><strong>双重校验锁</strong> *双重检验锁模式（double checked locking pattern），是一种使用同步块加锁的方法。程序员称其为双重检查锁，因为会有两次检查 <code>instance == null</code>，一次是在同步块外，一次是在同步块内。为什么在同步块内还要再检验一次？因为可能会有多个线程一起进入同步块外的 if，如果在同步块内不进行二次检验的话就会生成多个实例了。</li></ul><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>{</span><br><span class="line">       <span class="keyword">if</span> (INSTANCE == <span class="keyword">null</span>) {  <span class="comment">// 一重</span></span><br><span class="line">           <span class="keyword">synchronized</span> (Singleton.class) {</span><br><span class="line">               <span class="keyword">if</span> (INSTANCE == <span class="keyword">null</span>) { <span class="comment">// 二重</span></span><br><span class="line">                   INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">               }</span><br><span class="line">           }</span><br><span class="line">       }</span><br><span class="line">       <span class="keyword">return</span> INSTANCE;</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure><p>这段代码会有一个隐藏问题，主要是在<code>INSTANCE = new Singleton()</code>这句涉及到了JVM编译器的<strong>指令重排</strong>，这并非是一个原子操作，事实上在 JVM 中这句话大概做了下面 3 件事情:</p><ol><li>给 instance 分配内存</li><li>调用 Singleton 的构造函数来初始化成员变量</li><li>将instance对象指向分配的内存空间（执行完这步 instance 就为非 null 了）但是在 JVM 的即时编译器中存在指令重排序的优化。也就是说上面的第二步和第三步的顺序是不能保证的，最终的执行顺序可能是 1-2-3 也可能是 1-3-2。如果是后者，则在 3 执行完毕、2 未执行之前，被线程二抢占了，这时 instance 已经是非 null 了（但却没有初始化），所以线程二会直接返回 instance，然后使用，然后顺理成章地报错。我们只需要将 instance 变量声明成 volatile 就可以了。</li></ol><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>{</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 双重校验锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (INSTANCE == <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) {</span><br><span class="line">                <span class="keyword">if</span> (INSTANCE == <span class="keyword">null</span>) {</span><br><span class="line">                    INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>关于<code>volatile</code>修饰符用最简单的方式理解就是阻止了变量访问前后的指令重排，保证了指令执行顺序。</p><ul><li><strong>饿汉模式</strong></li></ul><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>{  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>{}  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>{  </span><br><span class="line">        <span class="keyword">return</span> instance;  </span><br><span class="line">    }  </span><br><span class="line">}  </span><br></pre></td></tr></tbody></table></figure><p>这种方法非常简单，因为单例的实例被声明成 <code>static</code> 和 <code>final</code> 变量了，在第一次加载类到内存中时就会初始化，所以创建实例本身是线程安全的。</p><p>这种方式基于<code>classloder</code>机制避免了多线程的同步问题，不过，<code>instance</code>在类装载时就实例化，虽然导致类装载的原因有很多种，在单例模式中大多数都是调用<code>getInstance</code>方法， 但是也不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化<code>instance</code>显然没有达到<code>lazy loading</code>的效果。</p><ul><li><strong>饿汉模式(变种)</strong></li></ul><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> {</span><br><span class="line">        instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><p>这种写法本质上和上一种写法没什么区别。</p><ul><li><strong>静态内部类</strong></li></ul><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>{</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>{</span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>{</span><br><span class="line">       <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure><p>注意：</p><ol><li>从外部无法访问静态内部类SingletonHolder，只有当调用Singleton.getInstance方法的时候，才能得到单例对象INSTANCE。</li><li>INSTANCE对象初始化的时机并不是在单例类Singleton被加载的时候，而是在调用getInstance方法，使得静态内部类SingletonHolder被加载的时候。因此这种实现方式是利用classloader的加载机制来实现懒加载，并保证构建单例的线程安全。</li><li>无法防止利用反射重复构建对象</li></ol><ul><li><strong>枚举高效写法</strong>在《Effective Java》最后推荐了这样一个写法，简直有点颠覆，不仅超级简单，而且保证了线程安全。这里引用一下，此方法无偿提供了序列化机制，绝对防止多次实例化，及时面对复杂的序列化或者反射攻击。单元素枚举类型已经成为实现Singleton的最佳方法。</li></ul><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Singleton</span> </span>{</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>{</span><br><span class="line">        System.out.println(<span class="string">"Hello World"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>对于一个标准的enum单例模式，最优秀的写法还是实现接口的形式:</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Singleton</span> <span class="keyword">implements</span> <span class="title">MySingleton</span> </span>{</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    INSTANCE {</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>{</span><br><span class="line">            System.out.println(<span class="string">"Hello world"</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MySingleton</span> </span>{</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * xx</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>使用枚举实现单例模式不仅防止了反射构建对象也保证了线程安全，但是同时它并不是懒加载，在枚举类加载的同时，其单例对象就已经被初始化。</p><h3 id="总结">总结<a class="" href="#总结"></a></h3><p>单例模式写法总结起来可以分为五种<code>懒汉</code>、<code>恶汉</code>、<code>双重校验锁</code>、<code>枚举</code>、<code>静态内部类</code>，上述所说都是线程安全的实现，第一种应该说是不正确的实现。对于这几种的比较</p><table><thead><tr><th>单例模式</th><th>是否线程安全</th><th>是否懒加载</th><th>是否防止反射构建</th></tr></thead><tbody><tr><td>双重校验锁</td><td>是</td><td>是</td><td>否</td></tr><tr><td>枚举</td><td>是</td><td>否</td><td>是</td></tr><tr><td>静态内部类</td><td>是</td><td>是</td><td>否</td></tr></tbody></table><blockquote><p>补充</p><ol><li>volatile关键字不但可以防止指令重排，也可以保证线程访问的变量值是主内存中的最新值。有关volatile的详细原理，我在以后的漫画中会专门讲解。</li><li>使用枚举实现的单例模式，不但可以防止利用反射强行构建单例对象，而且可以在枚举类对象被反序列化的时候，保证反序列的返回结果是同一对象。对于其他方式实现的单例模式，如果既想要做到可序列化，又想要反序列化为同一对象，则必须实现readResolve方法。</li><li>应该在任何情况下都应实现线程安全的写法。</li></ol></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式 - 工厂方法模式</title>
      <link href="/post/164885720/"/>
      <url>/post/164885720/</url>
      
        <content type="html"><![CDATA[<h2 id="定义">定义<a class="" href="#定义"></a></h2><ul><li>工厂方法模式是类的创建模式，又叫虚拟构造器（Virtual Constructor）模式，或者多态性工厂模式。</li><li>定义一个创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。</li></ul><h2 id="结构">结构<a class="" href="#结构"></a></h2><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/images/post/2020/08/1240-20200803145209257.png" alt="工厂方法"></p><p>工厂方法包含了一下角色</p><ul><li><strong>Product：抽象产品</strong></li><li><strong>ConcreteProduct：具象产品</strong></li><li><strong>Factory：抽象工厂</strong></li><li><strong>ConcreteFactory：具象工厂</strong></li></ul><h2 id="场景示例">场景示例<a class="" href="#场景示例"></a></h2><p>还是拿售卖机票举例，我们之前用简单工厂实现了不同供应商的下单逻辑，但是随着业务的不断扩大，我们对接的供应商越来越多，这样就会造成每次对接一个供应商都会在工厂类中添加分支，对工厂类进行修改，这就违反了<code>开闭原则</code>，所以现在我们用工厂方法来修改一下。<strong>Factory</strong>  代码</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Factory</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function">Product <span class="title">createProduct</span><span class="params">()</span></span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AFactory</span> <span class="keyword">implements</span> <span class="title">Factory</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">createProduct</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AProduct();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BFactory</span> <span class="keyword">implements</span> <span class="title">Factory</span> </span>{</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">createProduct</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BProduct();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CFactory</span> <span class="keyword">implements</span> <span class="title">Factory</span> </span>{</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">createProduct</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CProdut();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">... D</span><br><span class="line">... E</span><br></pre></td></tr></tbody></table></figure><p><strong>Product</strong>代码</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Product</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createOrder</span><span class="params">()</span></span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AProduct</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>{</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createOrder</span><span class="params">()</span> </span>{</span><br><span class="line">        System.out.println(<span class="string">"供应商A：下单操作"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BProduct</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>{</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createOrder</span><span class="params">()</span> </span>{</span><br><span class="line">        System.out.println(<span class="string">"供应商B：下单操作"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CProdut</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>{</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createOrder</span><span class="params">()</span> </span>{</span><br><span class="line">        System.out.println(<span class="string">"供应商B：下单操作"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">... D</span><br><span class="line">... E</span><br></pre></td></tr></tbody></table></figure><p><strong>Client</strong> 代码</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        Factory aFactory = <span class="keyword">new</span> AFactory();</span><br><span class="line">        Product aProduct = aFactory.createProduct();</span><br><span class="line">        aProduct.createOrder();</span><br><span class="line">        Factory bFactory = <span class="keyword">new</span> BFactory();</span><br><span class="line">        Product bProduct = bFactory.createProduct();</span><br><span class="line">        bProduct.createOrder();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>输出<code>供应商A：下单操作 供应商B：下单操作</code>以上就是一个简单的工厂方法的实现。即使在添加新的供应商，我们只要创建新的供应商工厂以及其实现就可以了，这样对我们的整个的工厂和产品体系都没有发生修改，而只是扩展了变化，这就完全符合了<code>开放-闭合</code>原则。如果我们的需求发生了变化，要同时支持单程、往返的下单，只要我们在每一个供应商作为一个简单工厂，创建出支持单程、往返的两种具象的产品就可以了。但是我们仔细观察就能发现，<strong>工厂方法模式实现时，客户端需要决定实例化哪一个工厂，选择判断的问题还是存在的，也就是说，工厂方法把简单工厂的内部逻辑判断移到了客户端代码来运行，你想要什么功能，本来是去修改工厂的，但是现在是去修改了客户端！</strong></p><blockquote><p>此例只是针对每个工厂只生成一个具象产品类，至于一个工厂生成多个具象产品类可将每个工厂改造成简单工厂，具体可参考<code>披萨店</code>。消除分支判断可以利用<code>反射</code>的方法。（将在抽象工厂章节统一列出）</p></blockquote><h2 id="优点">优点<a class="" href="#优点"></a></h2><ul><li><p>在工厂方法模式中，工厂方法用来创建客户端需要的产品，同时还向客户端隐藏了哪种具体产品类将被实例化这一细节，客户端只用关心产品对应的工厂，无需关心创建细节，甚至无需知道具体产品的类名。</p></li><li><p><code>面向接口编程</code>，基于工厂角色和产品角色的多态性设计是工厂方法模式的关键。它能够使工厂可以自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在具体工厂内部。工厂方法模式之所以又被称为多态工厂模式，是因为所有的具体工厂类都具有同一抽象父类。</p></li><li><p>遵循<code>开放-闭合</code>原则，在系统中新增加一个产品时，不用更改抽象工厂以及抽象产品，也不用对客户端以及具象工厂和产品做修改，而只要添加一个具体工厂和具体产品就可以了。</p></li></ul><h2 id="缺点">缺点<a class="" href="#缺点"></a></h2><ul><li><p>在添加新产品时，需要编写新的具体产品类，而且还要提供与之对应的具体工厂类，系统中类的个数将成对增加，在一定程度上增加了系统的复杂度，有更多的类需要编译和运行，会给系统带来一些额外的开销。</p></li><li><p>由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到DOM、反射等技术，增加了系统的实现难度。</p></li></ul><h2 id="应用场景">应用场景<a class="" href="#应用场景"></a></h2><ul><li><p>一个类不知道它所需要的对象的类：在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可，具体的产品对象由具体工厂类创建；客户端需要知道创建具体产品的工厂类。</p></li><li><p>一个类通过其子类来指定创建哪个对象：在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象将覆盖父类对象，从而使得系统更容易扩展。</p></li><li><p>将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时可以无须关心是哪一个工厂子类创建产品子类，需要时再动态指定，可将具体工厂类的类名存储在配置文件或数据库中。</p></li></ul><blockquote><p>扩展</p><ul><li>使用多个工厂方法，可在抽象工厂中定义多个工厂方法，从而使具体工厂实现不同的工厂方法，哲学工厂方法包含不同的逻辑，创建不同的产品（抽象工厂）</li><li>产品对象的重复使用：（1）工厂对象将已经创建过的产品保存到一个集合（如数组、List等）中，然后根据客户对产品的请求，对集合进行查询。如果有满足要求的产品对象，就直接将该产品返回客户端；如果集合中没有这样的产品对象，那么就创建一个新的满足要求的产品对象，然后将这个对象在增加到集合中，再返回给客户端。（2）Spring单例模式的使用</li><li>多态性的丧失和模式的退化：如果工厂仅仅返回一个具体产品对象，便违背了工厂方法的用意，发生退化，此时就不再是工厂方法模式了。一般来说，工厂对象应当有一个抽象的父类型，如果工厂等级结构中只有一个具体工厂类的话，抽象工厂就可以省略，也将发生了退化。当只有一个具体工厂，在具体工厂中可以创建所有的产品对象，并且工厂方法设计为静态方法时，工厂方法模式就退化成简单工厂模式。(本例就可以简化为简单工厂模式)</li></ul></blockquote><h2 id="总结">总结<a class="" href="#总结"></a></h2><ul><li><p>工厂方法模式又称为<code>工厂模式</code>，<code>虚拟构造器</code>模式。工厂方法中父类负责定义创建产品的统一接口，工厂子类负责生成具体的产品类。将产品的实例化操作延迟到子类进行，由子类决定实例化哪一个具体的产品类。</p></li><li><p>工厂方法模式包含四个角色：<strong>抽象工厂</strong>、<strong>具象工厂</strong>、<strong>抽象产品</strong>、<strong>具象产品</strong></p></li><li><p>工厂方法模式是简单工厂的进一步的抽象和推广，它们都是集中封装了对象的创建，使得更换对象时不需要做大的改动就可以实现，降低了客户端程序与产品对象的耦合。但是由于工厂方法模式使用了多态性，工厂方法模式保持了简单工厂模式的有点，而且克服了它的缺点。</p></li><li><p>工厂方法模式的主要优点是增加新的产品类时无须修改现有系统，并封装了产品对象的创建细节，系统具有良好的灵活性和可扩展性；其缺点在于增加新产品的同时需要增加新的工厂，导致系统类的个数成对增加，在一定程度上增加了系统的复杂性。</p></li><li><p>工厂方法模式适用情况包括：一个类不知道它所需要的对象的类；一个类通过其子类来指定创建哪个对象；将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时可以无须关心是哪一个工厂子类创建产品子类，需要时再动态指定。</p></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式 - 工厂三兄弟</title>
      <link href="/post/164885663/"/>
      <url>/post/164885663/</url>
      
        <content type="html"><![CDATA[<p>简单工厂模式、工厂方法模式、抽象工厂模式都属于创建型模式。这三个模式都是为了解决对象的创建而生。这三个工厂模式就像孪生兄弟一样，总是让人傻傻分不清楚。今天就依据个人理解对三个模式总结对比一下。</p><h2 id="定义">定义<a class="" href="#定义"></a></h2><table><thead><tr><th>模式</th><th>定义</th></tr></thead><tbody><tr><td><strong>简单工厂</strong></td><td>别名静态工厂方法(<code>Static Factory Method</code>)模式。在简单工厂模式中，可以根据参数的不同返回不同类的实例。</td></tr><tr><td><strong>工厂方法</strong></td><td>定义一个创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。</td></tr><tr><td><strong>抽象工厂</strong></td><td>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们的具体类。</td></tr></tbody></table><h2 id="结构">结构<a class="" href="#结构"></a></h2><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/images/post/2020/08/1240-20200803144920600.png" alt="简单工厂"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/images/post/2020/08/1240-20200803144943314.png" alt="工厂方法"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/images/post/2020/08/1240-20200803144952926.png" alt="抽象工厂"></p><h2 id="角色关系">角色关系<a class="" href="#角色关系"></a></h2><table><thead><tr><th>简单工厂</th><th>工厂方法</th><th>抽象工厂</th></tr></thead><tbody><tr><td>工厂角色<br>抽象产品角色</td><td>抽象产品 <br>    _ 具象产品<br>抽象工厂<br>   _ 具象工厂</td><td>抽象产品 <br>    _ 具象产品<br>抽象工厂<br>   _ 具象工厂</td></tr></tbody></table><h2 id="总结">总结<a class="" href="#总结"></a></h2><p>简单分析三种模式的结构图以及所拥有的结构关系，我们不难看出三种模式的不同点：</p><ul><li><strong>创建过程</strong></li></ul><table><thead><tr><th></th><th>简单工厂</th><th>工厂方法</th><th>抽象工厂</th></tr></thead><tbody><tr><td><strong>创建过程</strong></td><td>由工厂内部直接根据不同条件创建</td><td>定义一个抽象创建产品接口，将实例化过程延迟到子类</td><td>提供一个创建一系列或者相关依赖对象的接口，有子类实现实例化</td></tr><tr><td><strong>区别</strong></td><td>1.将客户端判断逻辑抽象到工厂内<br>2.<code>用来生产同一等级结构中的任意产品，无法新增产品</code></td><td>1.判断逻辑依旧在客户端<br>2.<code>用来生产同一等级结构中的固定产品，可任意增加新产品</code></td><td>1.判断逻辑依旧在客户端<br>2.<code>用来生产不同产品族的全部产品，不可任意增加新产品，可添加任意产品族</code></td></tr></tbody></table><ul><li><strong>工厂模式的退化</strong>当抽象工厂模式中每一个具体工厂类只创建一个产品对象，也就是只存在一个产品等级结构时，抽象工厂模式退化成工厂方法模式；当工厂方法模式中抽象工厂与具体工厂合并，提供一个统一的工厂来创建产品对象，并将创建对象的工厂方法设计为静态方法时，工厂方法模式退化成简单工厂模式。</li></ul><p>以上三种工厂 方法在等级结构和产品族这两个方向上的支持程度不同。所以要根据情况考虑应该使用哪种方法。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式 - 抽象工厂</title>
      <link href="/post/164885722/"/>
      <url>/post/164885722/</url>
      
        <content type="html"><![CDATA[<p>在讲解抽象工厂前我们首先需要了解两个概念：</p><ul><li><p><strong>产品等级结构：产品的等级结构即产品的继承结构</strong>。如果一个抽象类是电视机，其子类有海尔电视机、海信电视机、创维电视机，则抽象电视机与具体品牌的电视机之间构成了一个产品等级结构，抽象电视机是父类，而具体品牌的电视机是其子类。</p></li><li><p>**产品族：**在抽象工厂模式中，<strong>产品族是指由一个工厂生产的，位于不同产品等级结构中的一组产品</strong>，如海尔电器生产的海尔电视机、海尔冰箱，海尔电视机位于电视机产品等级结构中，海尔冰箱位于冰箱产品等级结构中。海尔电视机，海尔冰箱构成了一个产品族。<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/images/post/2020/08/1240-20200803145330379.png" alt="产品结构&amp;产品族"></p></li></ul><p>图中一共有四个产品族，分布于三个不同的产品等级结构中。只要指明一个产品所处的产品族以及它所属的等级结构，就可以唯一的确定这个产品。</p><p>引进抽象工厂模式</p><p>所谓的抽象工厂是指一个工厂等级结构可以创建出分属于不同产品等级结构的一个产品族中的所有对象。如果用图来描述的话，如下图：<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/images/post/2020/08/1240-20200803145338510.png" alt="抽象工厂"></p><h2 id="定义">定义<a class="" href="#定义"></a></h2><p><strong>抽象工厂模式</strong>（<strong>Abstract Factory</strong>），提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们的具体类。</p><h2 id="结构">结构<a class="" href="#结构"></a></h2><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/images/post/2020/08/1240-20200803145347138.png" alt="抽象工厂"></p><p>抽象工厂包含如下角色：</p><ul><li><strong>IFactory：抽象工厂</strong>抽象工厂定义了一个接口，所有的具体工厂都必须实现此接口，这个接口包含一组方法用来生产产品。</li><li><strong>ConCreteFactory：具体工厂</strong>具体工厂实现生成不同的具体产品家族，要创建一个产品，客户端主要使用其中一个工厂而不需要实例化任何产品对象。</li><li><strong>IProduct：抽象产品</strong>不同的抽象产品为不同的产品家族，每一个具体的工厂都能实现一整套的产品</li><li><strong>ConcreteProduct：具体产品</strong>对抽象产品的具体分类的实现</li></ul><h2 id="场景示例">场景示例<a class="" href="#场景示例"></a></h2><p>说起抽象工厂不得不让人想起位于各大城市中鱼龙混杂的电子城。只有你想不到的，没有他们生产不出来的。 500块的Iphone你买到过吗？你见到过装有安卓系统、小米摄像头的苹果手机吗？下面让我们一起来见识一下装有安卓手机系统的苹果手机是怎么在电子城生产出来的。手机卖家，也就是我们的手机工厂，使用主板、摄像头、手机外壳就能组装出一台手机：</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IFactory</span> </span>{</span><br><span class="line">    <span class="function">MainBoard <span class="title">createMainBoard</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">CameraLens <span class="title">createCameraLens</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Case <span class="title">createCase</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>然后无良卖家根据组装流程给组装了三种类型的手机</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 苹果手机</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppleFactory</span> <span class="keyword">implements</span> <span class="title">IFactory</span> </span>{</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MainBoard <span class="title">createMainBoard</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> IosMainBoard();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CameraLens <span class="title">createCameraLens</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> IosCameraLens();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Case <span class="title">createCase</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> IosCase();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 组装Android手机</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AndroidFactory</span> <span class="keyword">implements</span> <span class="title">IFactory</span> </span>{</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MainBoard <span class="title">createMainBoard</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AndroidMainBoard();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CameraLens <span class="title">createCameraLens</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AndroidCameraLens();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Case <span class="title">createCase</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AndroidCase();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 组装装有安卓操作系统、安卓摄像头的苹果手机</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AndroidAppleFactory</span> <span class="keyword">implements</span> <span class="title">IFactory</span> </span>{</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MainBoard <span class="title">createMainBoard</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AndroidMainBoard();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CameraLens <span class="title">createCameraLens</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AndroidCameraLens();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Case <span class="title">createCase</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> IosCase();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>不同的配件产品</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AndroidCameraLens</span> <span class="keyword">implements</span> <span class="title">CameraLens</span> </span>{</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getCameraLens</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"安卓摄像头"</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AndroidCase</span> <span class="keyword">implements</span> <span class="title">Case</span> </span>{</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getCase</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"安卓手机外壳"</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AndroidMainBoard</span> <span class="keyword">implements</span> <span class="title">MainBoard</span> </span>{</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMainBoard</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"安卓主板"</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IosCameraLens</span> <span class="keyword">implements</span> <span class="title">CameraLens</span> </span>{</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getCameraLens</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"苹果摄像头"</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IosCase</span> <span class="keyword">implements</span> <span class="title">Case</span> </span>{</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getCase</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"苹果手机外壳"</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IosMainBoard</span> <span class="keyword">implements</span> <span class="title">MainBoard</span> </span>{</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMainBoard</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"苹果手机主板"</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>然后顾客来买手机</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        IFactory factory = <span class="keyword">new</span> AppleFactory();</span><br><span class="line">        String mainBoard = factory.createMainBoard().getMainBoard();</span><br><span class="line">        String cameraLens = factory.createCameraLens().getCameraLens();</span><br><span class="line">        String aCase = factory.createCase().getCase();</span><br><span class="line">        System.out.println(String.format(<span class="string">"手机配件：%s、%s、%s，售价：12888"</span>, mainBoard, cameraLens, aCase));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>骚年，新出的Apple XRS <code>手机配件：装有苹果主板、苹果摄像头、苹果手机外壳，售价：12888</code>，要不要来一台？嫌贵啊，没关系，我这有新出的安卓机：</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        IFactory factory = <span class="keyword">new</span> AndroidFactory();</span><br><span class="line">        String mainBoard = factory.createMainBoard().getMainBoard();</span><br><span class="line">        String cameraLens = factory.createCameraLens().getCameraLens();</span><br><span class="line">        String aCase = factory.createCase().getCase();</span><br><span class="line">        System.out.println(String.format(<span class="string">"手机配件：%s、%s、%s，售价：4000"</span>, mainBoard, cameraLens, aCase));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>手机配件：装有安卓主板、安卓摄像头、安卓手机外壳，售价：4000</code>，超高性价比，只要4000，考不考虑入手？这样吧，骚年，你我相遇也是有缘，我这新弄了一台二手Apple，便宜出你，你看怎么样</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        IFactory factory = <span class="keyword">new</span> AndroidAppleFactory();</span><br><span class="line">        String mainBoard = factory.createMainBoard().getMainBoard();</span><br><span class="line">        String cameraLens = factory.createCameraLens().getCameraLens();</span><br><span class="line">        String aCase = factory.createCase().getCase();</span><br><span class="line">        System.out.println(String.format(<span class="string">"手机配件：%s、%s、%s，售价：4000"</span>, mainBoard, cameraLens, aCase));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>手机配件：安卓主板、安卓摄像头、苹果手机外壳，售价：500</code> 只要500，95成新，怎么样。</p><p><strong>勿占小便宜啊！！</strong></p><h2 id="优点">优点<a class="" href="#优点"></a></h2><ul><li><p>抽象工厂模式隔离了具体类的生成，使得客户并不需要知道什么被创建。由于这种隔离，更换一个具体工厂就变得相对容易。<strong>所有的具体工厂都实现了抽象工厂中定义的那些公共接口，因此只需改变具体工厂的实例，就可以在某种程度上改变整个软件系统的行为</strong>。另外，应用抽象工厂模式可以实现高内聚低耦合的设计目的，因此抽象工厂模式得到了广泛的应用。</p></li><li><p><strong>当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象</strong>。这对一些需要根据当前环境来决定其行为的软件系统来说，是一种非常实用的设计模式。</p></li><li><p>增加新的具体工厂和产品族很方便，无须修改已有系统，符合<code>开闭原则</code>。</p></li></ul><h2 id="缺点">缺点<a class="" href="#缺点"></a></h2><ul><li><p>在添加新的产品对象时，难以扩展抽象工厂来生产新种类的产品，这是因为在抽象工厂角色中规定了所有可能被创建的产品集合，要支持新种类的产品就意味着要对该接口进行扩展，而这将涉及到对抽象工厂角色及其所有子类的修改，显然会带来较大的不便。</p></li><li><p><strong>开闭原则的倾斜性</strong>（增加新的工厂和产品族容易，增加新的产品等级结构麻烦）。</p></li></ul><h2 id="应用场景">应用场景<a class="" href="#应用场景"></a></h2><ul><li><strong>当需要创建的对象是一系列相互关联或相互依赖的产品族时，便可以使用抽象工厂模式。</strong></li><li>系统中有多于一个的产品族，而每次只使用其中某一产品族。</li><li>属于同一个产品族的产品将在一起使用，这一约束必须在系统的设计中体现出来。</li><li>系统提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于具体实现。</li></ul><p>简单来讲，就是一个继承体系中，如果存在着多个等级结构（即存在着多个抽象类），并且分属各个等级结构中的实现类之间存在着一定的关联或者约束，就可以使用抽象工厂模式。假如各个等级结构中的实现类之间不存在关联或约束，则使用多个独立的工厂来对产品进行创建，则更合适一点。</p><blockquote><p><strong>“开闭原则”的倾斜性</strong></p><ul><li><p><strong>“开闭原则”要求系统对扩展开放，对修改封闭，通过扩展达到增强其功能的目的</strong>。对于涉及到多个产品族与多个产品等级结构的系统，其功能增强包括两方面：</p><ol><li><p>增加产品族：对于增加新的产品族，工厂方法模式很好的支持了“开闭原则”，对于新增加的产品族，只需要对应增加一个新的具体工厂即可，对已有代码无须做任何修改。</p></li><li><p>增加新的产品等级结构：对于增加新的产品等级结构，需要修改所有的工厂角色，包括抽象工厂类，在所有的工厂类中都需要增加生产新产品的方法，不能很好地支持“开闭原则”。</p></li></ol></li><li><p>抽象工厂模式的这种性质称为“开闭原则”的倾斜性，抽象工厂模式以一种倾斜的方式支持增加新的产品，它为新产品族的增加提供方便，但不能为新的产品等级结构的增加提供这样的方便。</p></li></ul><p><strong>工厂模式的退化</strong></p><ul><li>当抽象工厂模式中每一个具体工厂类只创建一个产品对象，也就是只存在一个产品等级结构时，抽象工厂模式退化成工厂方法模式；当工厂方法模式中抽象工厂与具体工厂合并，提供一个统一的工厂来创建产品对象，并将创建对象的工厂方法设计为静态方法时，工厂方法模式退化成简单工厂模式。</li></ul></blockquote><h2 id="总结">总结<a class="" href="#总结"></a></h2><ul><li><p>产品等级结构即产品的继承结构关系。产品族即由一个共产生产的，位于不同产品等级结构中的一组产品。</p></li><li><p>抽象工厂模式提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们的具体类。抽象工厂模式又称为Kit模式，属于对象创建型模式。</p></li><li><p>抽象工厂包含四个角色：抽象工厂、具体工厂、抽象产品、具体产品。</p></li><li><p>抽象工厂模式是所有形式的工厂模式中最为抽象和最具一般性的一种形态。抽象工厂模式与工厂方法模式最大的区别在于，工厂方法模式针对的是一个产品等级结构，而抽象工厂模式则需要面对多个产品等级结构。抽象工厂中利用工厂方法实现生产方法是很普遍的做法。</p></li><li><p>抽象工厂模式的主要优点是隔离了具体类的生成，使得客户并不需要知道什么被创建，而且每次可以通过具体工厂类创建一个产品族中的多个对象，增加或者替换产品族比较方便，增加新的具体工厂和产品族很方便；主要缺点在于增加新的产品等级结构很复杂，需要修改抽象工厂和所有的具体工厂类，对“开闭原则”的支持呈现倾斜性。</p></li><li><p>抽象工厂模式适用情况包括：一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节；系统中有多于一个的产品族，而每次只使用其中某一产品族；属于同一个产品族的产品将在一起使用；系统提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于具体实现。</p></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式 - 概述</title>
      <link href="/post/164885718/"/>
      <url>/post/164885718/</url>
      
        <content type="html"><![CDATA[<p>在软件工程中，设计模式（design pattern）是对软件设计中普遍存在的各种问题，所提出的解决方案。设计模式并不是固定的一套代码，而是针对某一特定问题的具体解决思路与方案。可以认为是一种最佳实践，因为他是无数软件开发人员经过长时间的实践总结出来的。在了解设计模式之前就我们首先要了解一下面向对象的六大原则。</p><h3 id="单一职权原则（Single-Responsibility-Principle-SRP）">单一职权原则（Single Responsibility Principle, SRP）<a class="" href="#单一职权原则（Single-Responsibility-Principle-SRP）"></a></h3><blockquote><p>定义：就一个类而言，应该仅有一个引起它变化的原因</p></blockquote><p>如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力。这种耦合会导致脆弱的设计，当变化发生时，设计会遭到意想不到的破坏。</p><p>软件设计真正要做的许多内容，就是发现职责并把那些职责相互分离，其实要去判断是否应该分离出来，也不难，那就是<strong>如果你能够想到多余一个的动机去改变一个类，那么这个类就是对于一个的职责</strong></p><p>在我们现实遇到的需求场景中，完全遵守单一职权原则也不是一件很好的事。比如我们在12306购票的下单的时候，需要对我们的身份信息做检查，根据单一职权原则我们单独编写了一个对身份信息验证。但是随着产品体验的优化，需要在添加一个重复订单的验证，如果根据单一职权原则我们还要写一个检查重复订单的类进行重复订单的校验。但是此时我们的代码结构已经定义好了，重新写一个类，然后修改调用方法就显得比较复杂，此时我们就可以对检查类进行简单的修改，编写一个检查方法，实现对身份检查和重复订单检查的调用。此时我们的单一职权原则可以应用到我们的方法上。虽然这样做对于类而言有悖于单一职权原则，但从下单前的校验角度思考它有遵循于单一职权原则。（<em>这样做的风险在于职责扩散的不确定性，可能以后还需要做更多的检查，所以记住，在职责扩散到我们无法控制的程度之前，立刻对代码进行重构。可根据不同的检查类型细分为不同的检查类</em>）</p><p>遵循单一职责原的优点有：</p><ul><li>可以降低类的复杂度，一个类只负责一项职责，其逻辑肯定要比负责多项职责简单的多；</li><li>提高类的可读性，提高系统的可维护性；</li><li>变更引起的风险降低，变更是必然的，如果单一职责原则遵守的好，当修改一个功能时，可以显著降低对其他功能的影响。</li></ul><p>需要说明的一点，单一职权原则并不是面向对象编程语言特有的原则，只要是模块化的程序设计，都适用单一职责原则。</p><h3 id="里氏替换原则（Liskov-Substitution-Principle，LSP）">里氏替换原则（Liskov Substitution Principle，LSP）<a class="" href="#里氏替换原则（Liskov-Substitution-Principle，LSP）"></a></h3><blockquote><p>定义：子类型必须能够替换掉他们的父类型。</p></blockquote><p>对于里氏替换原则这个名称不用太纠结，觉得苦涩难懂，其实是因为这项原则最早是在1988年，由麻省理工学院的一位姓里的女士（Barbara Liskov）提出来的，就是单纯的一个名字。</p><p>如果把里氏替换原则翻译成大白话就是<strong>一个软件实体如果使用的是一个父类的话，那么一定适用于其子类，而且它察觉不出父类对象和子类对象的区别，也就是说在软件里面把父类都替换成它的子类，程序的行为没有变化</strong></p><p>里氏替换原则主要对于继承而言，B继承A ，在B中添加新的方法的时候，尽量不要重写A的方法，也尽量不要重载父类A的方法。</p><p>继承作为面向对象三大特性之一，在给程序设计带来巨大便利的同时，也带来了弊端。比如使用继承会给程序带来侵入性，程序的可移植性降低，增加了对象间的耦合性，如果一个类被其他的类所继承，则当这个类需要修改时，必须考虑到所有的子类，并且父类修改后，所有涉及到子类的功能都有可能会产生故障。举例说一下集成的风险</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>{</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>{</span><br><span class="line"><span class="keyword">return</span> a-b;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>{</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>{</span><br><span class="line">A a = <span class="keyword">new</span> A();</span><br><span class="line">System.out.println(<span class="string">"100-50="</span>+a.func1(<span class="number">100</span>, <span class="number">50</span>));</span><br><span class="line">System.out.println(<span class="string">"100-80="</span>+a.func1(<span class="number">100</span>, <span class="number">80</span>));</span><br><span class="line">}</span><br><span class="line">} </span><br></pre></td></tr></tbody></table></figure><p>运行结果：</p><p>100-50=50</p><p>100-80=20</p><p>后来，我们需要增加一个新的功能：完成两数相加，然后再与100求和，由类B来负责。即类B需要完成两个功能：</p><ul><li>两数相减。</li><li>两数相加，然后再加100。由于类A已经实现了第一个功能，所以类B继承类A后，只需要再完成第二个功能就可以了，代码如下：</li></ul><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>{</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>{</span><br><span class="line"><span class="keyword">return</span> a+b;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">func2</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>{</span><br><span class="line"><span class="keyword">return</span> func1(a,b)+<span class="number">100</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>{</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>{</span><br><span class="line">B b = <span class="keyword">new</span> B();</span><br><span class="line">System.out.println(<span class="string">"100-50="</span>+b.func1(<span class="number">100</span>, <span class="number">50</span>));</span><br><span class="line">System.out.println(<span class="string">"100-80="</span>+b.func1(<span class="number">100</span>, <span class="number">80</span>));</span><br><span class="line">System.out.println(<span class="string">"100+20+100="</span>+b.func2(<span class="number">100</span>, <span class="number">20</span>));</span><br><span class="line">}</span><br><span class="line">} </span><br></pre></td></tr></tbody></table></figure><p>类B完成后，运行结果：</p><p>100-50=150</p><p>100-80=180</p><p>100+20+100=220</p><p>我们发现原本运行正常的相减功能发生了错误。原因就是类B在给方法起名时无意中重写了父类的方法，造成所有运行相减功能的代码全部调用了类B重写后的方法，造成原本运行正常的功能出现了错误。在本例中，引用基类A完成的功能，换成子类B之后，发生了异常。在实际编程中，我们常常会通过重写父类的方法来完成新的功能，这样写起来虽然简单，但是整个继承体系的可复用性会比较差，特别是运用多态比较频繁时，程序运行出错的几率非常大。如果非要重写父类的方法，比较通用的做法是：原来的父类和子类都继承一个更通俗的基类，原有的继承关系去掉，采用依赖、聚合，组合等关系代替。</p><p>里氏替换原则通俗的来讲就是：<strong>子类可以扩展父类的功能，但不能改变父类原有的功能</strong>。它包含以下4层含义：</p><ul><li>子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。</li><li>子类中可以增加自己特有的方法。</li><li>当子类的方法重载父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松。</li><li>当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。</li></ul><h3 id="依赖倒置原则（Dependence-Inversion-Principle）">依赖倒置原则（Dependence Inversion Principle）<a class="" href="#依赖倒置原则（Dependence-Inversion-Principle）"></a></h3><blockquote><p>定义：</p><ul><li>高层模块不应该依赖底层模块。两个都应该依赖抽象。</li><li>抽象不应该依赖细节。细节应该依赖抽象。</li></ul></blockquote><p>依赖倒置原则定义比较绕口，说白了就是针对接口编程，不要针对实现编程。</p><p>依赖倒置原则基于这样一个事实：相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建起来的架构比以细节为基础搭建起来的架构要稳定的多。在java中，抽象指的是接口或者抽象类，细节就是具体的实现类，使用接口或者抽象类的目的是制定好规范和契约，而不去涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成。</p><p>同样我们举个例子说明，双十一即将来临，商城搞满减活动。</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        Activity activity = <span class="keyword">new</span> Activity();</span><br><span class="line">        activity.sale(<span class="keyword">new</span> Manjian());</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Activity</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sale</span><span class="params">(Manjian manjian)</span> </span>{</span><br><span class="line">        manjian.activityMode();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manjian</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">activityMode</span><span class="params">()</span> </span>{</span><br><span class="line">        System.out.println(<span class="string">"活动方式：满300减100"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>运行输出<code>活动方式：满300减100</code>过了一天，产品又提出一个打折的需求，但是如果实现就必须需要修改我们的活动类，以此类推，每次不同的活动都要去修改。这显然不合理，<code>Activity</code> 和<code>Dicount</code>耦合性太高了，因此我们抽象一个优惠类</p><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">public interface Reduce {</span><br><span class="line">    void activityMode();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>而<code>Discount</code> 和 <code>ManJian</code>都实现<code>Reduce</code></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        Activity activity = <span class="keyword">new</span> Activity();</span><br><span class="line">        activity.sale(<span class="keyword">new</span> Manjian());</span><br><span class="line">        activity.sale(<span class="keyword">new</span> Discount());</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Activity</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sale</span><span class="params">(Reduce reduce)</span> </span>{</span><br><span class="line">        reduce.activityMode();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manjian</span> <span class="keyword">implements</span> <span class="title">Reduce</span></span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">activityMode</span><span class="params">()</span> </span>{</span><br><span class="line">        System.out.println(<span class="string">"活动方式：满300减100"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Discount</span> <span class="keyword">implements</span> <span class="title">Reduce</span></span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">activityMode</span><span class="params">()</span> </span>{</span><br><span class="line">        System.out.println(<span class="string">"活动方式：打八折"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>输出<code>活动方式：满300减100</code>和<code>活动方式：打八折</code>这样修改后无论怎么修改活动方式都不需要修改<code>Activity</code>类了</p><p>传递依赖关系有三种方式，以上的例子中使用的方法是接口传递，另外还有两种传递方式：构造方法传递和setter方法传递，相信用过Spring框架的，对依赖的传递方式一定不会陌生。</p><p>在实际编程中，我们一般需要做到如下3点：</p><ul><li>低层模块尽量都要有抽象类或接口，或者两者都有。</li><li>变量的声明类型尽量是抽象类或接口。</li><li>使用继承时遵循里氏替换原则。</li></ul><p>依赖倒置原则的核心就是要我们面向接口编程，理解了面向接口编程，也就理解了依赖倒置。</p><h3 id="接口隔离原则（Interface-Segregation-Principle）">接口隔离原则（Interface Segregation Principle）<a class="" href="#接口隔离原则（Interface-Segregation-Principle）"></a></h3><blockquote><p>定义：客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。接口隔离原则简单来说就是根据类的职责将接口进行更细粒度的拆分，使一个臃肿的接口分散成几个接口，由实现者根据自身需求去分别实现。</p></blockquote><p>举个🌰：我们在封装JDBC方法的时候会有<code>单表查询</code>、<code>添加查询</code>、<code>分页</code>等等。如果我们封装到一个接口里面，有些不需要这么多功能的类也要实现这些逻辑，就会造成代码的臃肿。这里拿通用<code>Mapper</code>举例</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SelectOneMapper</span>&lt;<span class="title">T</span>&gt; </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据实体中的属性进行查询，只能有一个返回值，有多个结果是抛出异常，查询条件使用等号</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> record</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SelectProvider(type = BaseSelectProvider.class, method = "dynamicSQL")</span></span><br><span class="line">    <span class="function">T <span class="title">selectOne</span><span class="params">(T record)</span></span>;</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SelectMapper</span>&lt;<span class="title">T</span>&gt; </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据实体中的属性值进行查询，查询条件使用等号</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> record</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SelectProvider(type = BaseSelectProvider.class, method = "dynamicSQL")</span></span><br><span class="line">    <span class="function">List&lt;T&gt; <span class="title">select</span><span class="params">(T record)</span></span>;</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SelectAllMapper</span>&lt;<span class="title">T</span>&gt; </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询全部结果</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SelectProvider(type = BaseSelectProvider.class, method = "dynamicSQL")</span></span><br><span class="line">    <span class="function">List&lt;T&gt; <span class="title">selectAll</span><span class="params">()</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>将每一种查询都封装成一个方法，然后写一个通用的接口</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Mapper</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span></span></span><br><span class="line"><span class="class">        <span class="title">BaseMapper</span>&lt;<span class="title">T</span>&gt;,</span></span><br><span class="line"><span class="class">        <span class="title">ExampleMapper</span>&lt;<span class="title">T</span>&gt;,</span></span><br><span class="line"><span class="class">        <span class="title">RowBoundsMapper</span>&lt;<span class="title">T</span>&gt;,</span></span><br><span class="line"><span class="class">        <span class="title">Marker</span> </span>{</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BaseMapper</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span></span></span><br><span class="line"><span class="class">        <span class="title">BaseSelectMapper</span>&lt;<span class="title">T</span>&gt;,</span></span><br><span class="line"><span class="class">        <span class="title">BaseInsertMapper</span>&lt;<span class="title">T</span>&gt;,</span></span><br><span class="line"><span class="class">        <span class="title">BaseUpdateMapper</span>&lt;<span class="title">T</span>&gt;,</span></span><br><span class="line"><span class="class">        <span class="title">BaseDeleteMapper</span>&lt;<span class="title">T</span>&gt; </span>{</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这样我们就可以根据不同的需要进行选择性继承相应功能的接口就可以实现符合我们需要的接口。</p><p>接口隔离原则的含义是：建立单一接口，不要建立庞大臃肿的接口，尽量细化接口，接口中的方法尽量少。也就是说，我们要为各个类建立专用的接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。本文例子中，将一个庞大的接口变更为3个专用的接口所采用的就是接口隔离原则。在程序设计中，依赖几个专用的接口要比依赖一个综合的接口更灵活。接口是设计时对外部设定的“契约”，通过分散定义多个接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性。</p><p>说到这里，很多人会觉的接口隔离原则跟之前的单一职责原则很相似，其实不然。其一，单一职责原则原注重的是职责；而接口隔离原则注重对接口依赖的隔离。其二，单一职责原则主要是约束类，其次才是接口和方法，它针对的是程序中的实现和细节；而接口隔离原则主要约束接口接口，主要针对抽象，针对程序整体框架的构建。</p><p>采用接口隔离原则对接口进行约束时，要注意以下几点：</p><ul><li>接口尽量小，但是要有限度。对接口进行细化可以提高程序设计灵活性是不挣的事实，但是如果过小，则会造成接口数量过多，使设计复杂化。所以一定要适度。</li><li>为依赖接口的类定制服务，只暴露给调用的类它需要的方法，它不需要的方法则隐藏起来。只有专注地为一个模块提供定制服务，才能建立最小的依赖关系。</li><li>提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。</li></ul><h3 id="迪米特法则（Law-Of-Demeter）">迪米特法则（Law Of Demeter）<a class="" href="#迪米特法则（Law-Of-Demeter）"></a></h3><blockquote><p>定义：如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用，如果其中一个类需要调用另一个类的某一个方法的话，可以通过第三者转发这个调用。</p></blockquote><p>迪米特法则也叫最少知识原则。强调的是一个对象应该对其他对象保持做少的了解，在类的结构设计上，每一个类都应当尽量降低成员的访问权限，也就是说，一个类包装好自己的<code>private</code>状态，不需要让别的类知道的字段或行为就不要公开。</p><p><strong>迪米特法则其根本思想，是强调了类之间的松耦合，类之间耦合越弱，越利于复用，一个处在弱耦合的类被修改，不会对有关系的类造成波及。</strong></p><p>迪米特法则的初衷是降低类之间的耦合，由于每个类都减少了不必要的依赖，因此的确可以降低耦合关系。但是凡事都有度，虽然可以避免与非直接的类通信，但是要通信，必然会通过一个“中介”来发生联系。过分的使用迪米特原则，会产生大量这样的中介和传递类，导致系统复杂度变大。所以在采用迪米特法则时要反复权衡，既做到结构清晰，又要高内聚低耦合。</p><h3 id="开闭原则">开闭原则<a class="" href="#开闭原则"></a></h3><blockquote><p>定义：软件实体（类、模块、函数等等）应该可以扩展，但是不可修改。</p></blockquote><p>开闭原则有两个特征1.对扩展是开放的（Open for extension）2.对更改是封闭的（Closed for modification）</p><p>我们在做任何系统的时候，都不可能一开始指定需求就不在发生变化，但是每次需求的变化都会引起对原有代码的修改，很有可能会给旧的代码引入错误，也可能会使我们不得不对整个功能进行重构，并且还要测试一遍原有的代码。</p><p>绝对的对修改关闭是不现实的，这就要求设计人员必须对于他设计的代码应该应对那种变化封闭做出选择。他必须先猜测出来最有可能变化的种类，然后构造抽象来隔离那些变化。但是我们是很难进行预先的猜测，这样要求我们<strong>等到变化发生时立即采取行动，当发生变化时，我们就创建抽象来隔离以后发生的同类变化</strong></p><p>开闭原则是面向对象设计的核心所在，遵循这个原则可以带来面向对象技术所声称的巨大好处，也就是可维护、可扩展、可复用、灵活性好。</p><p>其实，我们遵循设计模式前面5大原则，以及使用23种设计模式的目的就是遵循开闭原则。也就是说，只要我们对前面5项原则遵守的好了，设计出的软件自然是符合开闭原则的，这个开闭原则更像是前面五项原则遵守程度的“平均得分”，前面5项原则遵守的好，平均分自然就高，说明软件设计开闭原则遵守的好；如果前面5项原则遵守的不好，则说明开闭原则遵守的不好。</p><p>再回想一下前面说的5项原则，恰恰是告诉我们用抽象构建框架，用实现扩展细节的注意事项而已：单一职责原则告诉我们实现类要职责单一；里氏替换原则告诉我们不要破坏继承体系；依赖倒置原则告诉我们要面向接口编程；接口隔离原则告诉我们在设计接口的时候要精简单一；迪米特法则告诉我们要降低耦合。而开闭原则是总纲，他告诉我们要对扩展开放，对修改关闭。</p><p>最后说明一下如何去遵守这六个原则。对这六个原则的遵守并不是是和否的问题，而是多和少的问题，也就是说，我们一般不会说有没有遵守，而是说遵守程度的多少。任何事都是过犹不及，设计模式的六个设计原则也是一样，制定这六个原则的目的并不是要我们刻板的遵守他们，而需要根据实际情况灵活运用。对他们的遵守程度只要在一个合理的范围内，就算是良好的设计。我们用一幅图来说明一下。<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/images/post/2020/08/1240-20200803145558926.png" alt="图片来源网络"></p><p>图中的每一条维度各代表一项原则，我们依据对这项原则的遵守程度在维度上画一个点，则如果对这项原则遵守的合理的话，这个点应该落在红色的同心圆内部；如果遵守的差，点将会在小圆内部；如果过度遵守，点将会落在大圆外部。一个良好的设计体现在图中，应该是六个顶点都在同心圆中的六边形。</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/images/post/2020/08/1240-20200803145657902.png" alt="图片来源网络"></p><p>在上图中，设计1、设计2属于良好的设计，他们对六项原则的遵守程度都在合理的范围内；设计3、设计4设计虽然有些不足，但也基本可以接受；设计5则严重不足，对各项原则都没有很好的遵守；而设计6则遵守过渡了，设计5和设计6都是迫切需要重构的设计。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UML 类图</title>
      <link href="/post/164885660/"/>
      <url>/post/164885660/</url>
      
        <content type="html"><![CDATA[<blockquote><p>UML，统一建模语言「<code>Unified Modeling Language</code>」，是非专利的第三代<a href="https://zh.wikipedia.org/w/index.php?title=%E5%AF%B9%E8%B1%A1%E5%BB%BA%E6%A8%A1%E8%AF%AD%E8%A8%80&amp;action=edit&amp;redlink=1" title="对象建模语言（页面不存在）">建模</a>和<a href="https://zh.wikipedia.org/wiki/%E8%A7%84%E7%BA%A6%E8%AF%AD%E8%A8%80" title="规约语言">规约语言</a>。UML是一种开放的方法，用于说明、可视化、构建和编写一个正在开发的、面向对象的、软件密集系统的制品的开放方法。UML展现了一系列最佳工程实践，这些最佳实践在对大规模，复杂系统进行建模方面，特别是在<a href="https://zh.wikipedia.org/wiki/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84" title="软件架构">软件架构</a>层次已经被验证有效。【<a href="https://zh.wikipedia.org/wiki/%E7%BB%9F%E4%B8%80%E5%BB%BA%E6%A8%A1%E8%AF%AD%E8%A8%258">维基百科</a>】</p></blockquote><p>最近再看设计模式以及一些文章时会发现有很多uml类图，都是选择性的大体看一下，基本上都是一知半解，为了更深层次的理解，便想主动学习一下UML类图的相关知识。</p><p>整体结构图如下图所示：<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/images/post/2020/08/1240-20200803142431784.png" alt="UML类图"></p><h2 id="类">类<a class="" href="#类"></a></h2><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/images/post/2020/08/1240-20200803142445195.png" alt="类">如上所示，<code>动物</code>矩形框代表着一个类「<code>Class</code>」。类图分为三层。第一层显示类的名称，如果是抽象类，就用斜体显示。第二层是类的特性，通常就是字段和属性。第三层是类的操作，通常是方法和行为。注意前面的符号，<code>+</code>表示 <code>public</code>，<code>-</code>表示<code>private</code>，<code>#</code>号表示<code>protect</code>。</p><h2 id="接口">接口<a class="" href="#接口"></a></h2><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/images/post/2020/08/1240-20200803142459648.png" alt="接口图">上图表示一个接口图，它与类图的区别主要是顶端有<code>&lt;&lt;interface&gt;&gt;</code>显示，第一行是接口的名称，第二行是方法。</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/images/post/2020/08/1240-20200803144436062.png" alt="接口-棒棒糖表示法">接口还有另一种表示方法，俗称「<code>棒棒糖表示法</code>」，比如图中的唐老鸭类就是实现了<code>讲人话</code>的接口。</p><h2 id="继承（generalization）关系">继承（generalization）关系<a class="" href="#继承（generalization）关系"></a></h2><p>标准称之为：泛化「<code>generalization</code>」关系<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/images/post/2020/08/1240-20200803142510743.png" alt="继承关系">动物和鸟、鸟和大雁、鸭和唐老鸭都是属于继承关系，继承关系用<code>空心三角形+实线</code>来表示。</p><h2 id="实现（realize）关系">实现（realize）关系<a class="" href="#实现（realize）关系"></a></h2><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/images/post/2020/08/1240-20200803144117938.png" alt="实现关系"></p><p>大雁实现了飞翔接口，实现接口用<code>空心三角形+虚线</code>来表示。</p><h2 id="关联（association）关系">关联（association）关系<a class="" href="#关联（association）关系"></a></h2><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/images/post/2020/08/1240-20200803142522727.png" alt="关联关系">企鹅是特别的鸟，会游泳但不会飞。更重要的是，它与气候有很大的关系，企鹅需要<code>知道</code>气候的变化，需要<code>了解</code>气候规律，来进行长途跋涉的迁移活动。当一个类<code>知道</code>另一个类时，可以用<code>关联（association）</code>，关联关系用<code>实线箭头</code>来表示。</p><h2 id="聚合（Aggregtion）关系">聚合（Aggregtion）关系<a class="" href="#聚合（Aggregtion）关系"></a></h2><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/images/post/2020/08/1240-20200803142530886.png" alt="聚合关系"></p><p><strong>聚合表示一种弱<code>拥有关系</code>，体现的是A对象可以包含B对象，但B对象不是A对象的一部分</strong>聚合关系用<code>空心的菱形+实线箭头</code>来表示</p><h2 id="合成（Composition）关系">合成（Composition）关系<a class="" href="#合成（Composition）关系"></a></h2><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/images/post/2020/08/1240-20200803142539802.png" alt="合成关系"></p><p><strong>合成（<code>Composition</code>或者「组合」）是一种强的<code>拥有</code>关系，体现了严格的部分和整体的关系，部分和整体的生命周期一样</strong>如上图，鸟和翅膀就是合成（组合）关系，因为它们是整体和部分的关系，并且翅膀和鸟的生命周期是相同的。同时在合成关系连线的两端还有一个数字<code>1</code>和数字<code>2</code>，这被称为基数。表明这一端的类可以有几个实例，很显然一个鸟应该有两只翅膀。如果一个类可能有无数个实例，则就用<code>n</code>来表示，关联关系、聚合关系都是可以有基数的。</p><p>合成关系用<code>实心的菱形+实线箭头</code>来表示。</p><h2 id="依赖关系">依赖关系<a class="" href="#依赖关系"></a></h2><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/images/post/2020/08/1240-20200803142549713.png" alt="依赖关系">上图所示，动物如果要有生命力，需要氧气、水、食物等。也就是说，动物依赖于氧气和水。他们之间是<strong>依赖关系</strong>（<code>Dependency</code>）。依赖关系用<code>虚线箭头</code>来表示。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> uml </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组</title>
      <link href="/post/164885511/"/>
      <url>/post/164885511/</url>
      
        <content type="html"><![CDATA[<p>数组是编程语言中最常见的一种数据结构,可以用于储存多个数据,通常可通过数组元素的索引来访问数组元素,包括数组元素赋值和取出数组元素的值.</p><h2 id="初识数组">初识数组<a class="" href="#初识数组"></a></h2><ul><li>数组也是一种类型,属于引用数据类型.</li><li>数组元素的类型是唯一的,一个数组里只能存储一种类型的数据.</li><li>数组的长度是固定的,即一个数组一单初始化完成,数组在内存中所占的空间将被固定下来,长度不在发生改变.即使把某个数组的元素清空,其所占的空间依然被保留.</li></ul><h2 id="数组的初始化">数组的初始化<a class="" href="#数组的初始化"></a></h2><h3 id="定义数组变量">定义数组变量<a class="" href="#定义数组变量"></a></h3><p>Java支持两种语法格式定义数组:</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">type[] arr;</span><br><span class="line">type arr[];</span><br></pre></td></tr></tbody></table></figure><p>对于这两种定义而言,通常使用第一种格式来定义数组,因为第一种有更好的语义.第二种容易和变量名混淆</p><h3 id="初始化">初始化<a class="" href="#初始化"></a></h3><p>Java 数组只有初始化之后才能使用,所谓的初始化,就是为数组的元素分配内存空间.并为每个数组元素赋初始值.</p><h4 id="静态初始化">静态初始化<a class="" href="#静态初始化"></a></h4><p>由程序员显示的指定每个数组原始的初始值.由系统决定数组的长度.静态初始化的语法格式为:</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">type[] arr = <span class="keyword">new</span> type[]{item1, item2, item3,...};</span><br></pre></td></tr></tbody></table></figure><p><code>type</code> 为数组元素的数据类型, 数组元素类型必须为 <code>type</code> 类型,或者其子类的实例.除此之外,静态初始化还有如下简化的语法格式:</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">type[] arr = {item1, item2, item3 ...};</span><br></pre></td></tr></tbody></table></figure><h4 id="动态初始化">动态初始化<a class="" href="#动态初始化"></a></h4><p>动态初始化只指定数组的长度,由系统为每个元素指定初始值,动态初始化的语法格式如下:</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">type[] arr = <span class="keyword">new</span> type[length];</span><br></pre></td></tr></tbody></table></figure><p>上面的语法中,需要指定一个 int 类型的 length 参数,这个参数指定了数组的长度.执行动态初始化时,程序员只指定数组的长度,数组元素的初始值由系统按照如下自动分配</p><ul><li>数组元素类型是基本类型中的整数类型(byte, short, int, long),则数组元素的值是 0.</li><li>数组元素类型是基本类型中的浮点类型(float, double),则数组元素的值是 0.0.</li><li>数组元素类型是基本类型中的字符类型(char),则数组元素的值是’\u0000’.</li><li>数组元素的类型是基本类型中的布尔类型(boolean),则数组元素的值是 false.</li><li>数组元素的类型是引用类型(类,接口,数组),则数组元素的值是 null;</li></ul><h2 id="数组的访问">数组的访问<a class="" href="#数组的访问"></a></h2><p>数组最常用的方法就是访问数组元素,包括对数组元素进行赋值和取出数组元素.</p><h3 id="数组元素读取、赋值">数组元素读取、赋值<a class="" href="#数组元素读取、赋值"></a></h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = {<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>};</span><br><span class="line"><span class="comment">// 数组取值 通过 arr[index] 访问 </span></span><br><span class="line"><span class="keyword">int</span> a = arr[<span class="number">0</span>];</span><br><span class="line"><span class="comment">// arr 为{1,3,3}</span></span><br><span class="line">arr[<span class="number">1</span>] = <span class="number">3</span></span><br></pre></td></tr></tbody></table></figure><p>如果访问数组元素时指定的索引值小于0,或者大于等于数组的长度,编译程序时不会出现任何错误,但运行时出现异常<code>java.lang.ArrayIndexOutOfBoundsException:N</code>(数组越界异常), <code>N</code> 就是试图访问的数组索引.</p><h3 id="数组的遍历">数组的遍历<a class="" href="#数组的遍历"></a></h3><h4 id="for-循环"><code>for</code> 循环<a class="" href="#for-循环"></a></h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</span><br><span class="line"><span class="comment">// 输出 5 个 0</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++){</span><br><span class="line">    System.out.println(arr[i])</span><br><span class="line">}</span><br><span class="line">arr[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">arr[<span class="number">2</span> = <span class="number">2</span>;</span><br><span class="line"><span class="comment">// 输出 0 1 2 0 0</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++){</span><br><span class="line">    System.out.println(arr[i])</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>上面的代码第一次循环输出 5 个 0,因为 arr 数组执行的是默认初始化,数组元素是 int 类型,系统为 int 类型的数组元素初始化赋值为 0.</p><h4 id="foreach循环"><code>foreach</code>循环<a class="" href="#foreach循环"></a></h4><p>Java5 之后,Java 提供了一种更简单的循环:<code>foreach循环</code>,这种循环遍历数组和集合更加方便.</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (type item : array|collection){</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>使用<code>foreach</code>循环需要注意:</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>};</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> item: arr){</span><br><span class="line">    System.out.println(item);</span><br><span class="line">    item = <span class="number">0</span>;</span><br><span class="line">    System.out.println(item);</span><br><span class="line">}</span><br><span class="line">System.out.println(arr[<span class="number">0</span>]);</span><br></pre></td></tr></tbody></table></figure><p>上例程序将输出</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></tbody></table></figure><p>由输出结果可以看出来,在 <code>foreach</code>循环中对数组元素进行赋值,结果导致不能正确的遍历数组元素.同时在循环中为改变的数组元素的值并没有真正改变数组元素,因为在 <code>foreach</code>中循环变量相当于一个临时变量,系统会把数组元素一次赋值给这个临时变量,而这个临时变量并不是数组元素,它只是保存了数组元素的值.因此要注意:<code>如果希望改变数组元素的值,则不能使用这种 foreach 循环</code>.</p><h2 id="深入了解数组">深入了解数组<a class="" href="#深入了解数组"></a></h2><h3 id="JDK-中的-Array">JDK 中的 <code>Array</code><a class="" href="#JDK-中的-Array"></a></h3><p>查看 Java源码中的<code>Array</code>类可以发现它是个 <code>final class</code>, 其中方法如下:<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/images/post/2020/08/951706-20200326003506393-472307678.png" alt="Arrays"></p><p><code>Array</code>类中基本都是 <code>getXX</code> 和 <code>setXX</code> 方法,并且全部都为 <code>native</code> 方法.使用 <code>native</code>关键字说明这个方法是原生函数，也就是这个方法是用<code>C/C++</code>语言实现的，并且被编译成了DLL，由java去调用,因此我们可以将数组理解为是由计算机本地方法去实现的类,并不属于 Java.</p><h3 id="数组的内存分布">数组的内存分布<a class="" href="#数组的内存分布"></a></h3><p>数组是一种引用数据类型,数组的引用变量时存储在栈内存中的,而数组元素是在堆内存中,并且是连续存放的.这是为了能快速存取数组元素，因为只需要移动index（内部计算物理地址：<code>数组起始地址+index * 元素size大小</code>）就可以访问，而这是很快的 O(1)。</p><p>在Java 内存模型中,数组对象被存储在堆(heap)内存中;如果引用该数组对象的变量是一个局部变量,那么它被存储在栈(stack)内存中.如下图所示:<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/images/post/2020/08/951706-20200326003552496-1279006593.png" alt="数组的内存分布"></p><p>如果需要访问上图堆内存中的数组元素,在程序中只能通过 p[index]的形式实现.也就是说,数组引用变量时访问堆内存中数组元素的根本方式.现有如下代码:</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 定义并静态初始化数组</span></span><br><span class="line"><span class="keyword">int</span>[] a = {<span class="number">5</span>, <span class="number">7</span>, <span class="number">20</span>};</span><br><span class="line"><span class="comment">// 定义数组,使用动态初始化</span></span><br><span class="line"><span class="keyword">int</span>[] b = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>];</span><br><span class="line">System.out.println(<span class="string">"b 数组的长度为: "</span> + b.length);</span><br><span class="line"><span class="comment">// 循环输出 a 数组的元素</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, len = a.length; i &lt; len; i++ ){</span><br><span class="line">    System.out.println(a[i]);</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 循环输出 b 数组的元素</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, len = b.length; i &lt; len; i++ ){</span><br><span class="line">    System.out.println(b[i]);</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 将 a 的值赋给 b,即将 b 的引用指向 a 引用指向的数组</span></span><br><span class="line">b = a;</span><br><span class="line"><span class="comment">// 再次输出 b 数组的长度</span></span><br><span class="line">System.out.println(<span class="string">"b 数组的长度为: "</span> + b.length);</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>运行上例代码,首先会输出 b 的长度为 4,然后输出 a,b 的各项元素,接着输出 b 的长度为 3.看起来数组的长度是可变的,其实这是一个假象.上例代码内存分析:</p><ol><li><p>初始化 a,b 数组,在内存中产生了 4 块区域,栈中的引用变量 a,b 以及堆中的实际数组对象. 其中 a 引用的数组对象长度为 3, b 引用的数组长度为 4.<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/images/post/2020/08/951706-20200326003632495-1700626784.png" alt="数组的内存分布"></p></li><li><p>程序执行<code>b = a</code> 操作.系统会将 a 的值赋给 b,即将 a 引用的数组对象的内存地址赋给 b,此时 b 的值为 a 引用的数组对象的内存地址.<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/images/post/2020/08/951706-20200326003650253-1864720497.png" alt="数组的内存分布"></p></li></ol><p>从上可以看出,程序执行 <code>b = a</code> 之后,b 之前引用的数组对象长度并没有发生任何改变,而 b 的值变成了 a 引用的数组对象的地址,此时 b 数组的长度即为 a 数组的长度 3.</p><blockquote><p>需要注意的是数组元素的内存空间是连续的，是指</p><ol><li>如果数组元素是原始类型，那么数组元素存放的就是原始类型的值，他们是连续存放的</li><li>如果数组元素是对象，那么数组元素就是存放引用了，数组元素是连续存放的，而引用的对象可能在另外的地方，与数组元素可能相隔很远，即不连续。</li></ol></blockquote><h3 id="多维数组">多维数组<a class="" href="#多维数组"></a></h3><p>Java 提供了支持多维数组的语法,但是从数组底层的运行机制上来看,并不存在多维数组.多维数组的定语语法为</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">type[][] arr = <span class="keyword">new</span> type[length1][length2]</span><br></pre></td></tr></tbody></table></figure><p><code>length2</code>可动态创建.二维数组本质就是一位数组中的每个元素都是一个一维数组. 如上<code>length2</code>给出了值,则初始化了一维数组中的每个元素都是一个长度为<code>length2</code>的一维数组.其内存模型为:<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/images/post/2020/08/951706-20200326003710848-1203499712.png" alt="二维数组内存分布"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>原码、补码、反码</title>
      <link href="/post/164885509/"/>
      <url>/post/164885509/</url>
      
        <content type="html"><![CDATA[<h2 id="机器数">机器数<a class="" href="#机器数"></a></h2><p>所有数字在计算机底层都是以二进制形式存在的.它的表现形式叫做机器数,这个数有正负之分,最高位为符号位.0 表示正数, 1 表示负数.</p><blockquote><p>例如正数 5 在计算机用以一个 8 位(计算机最小储存单位)表示 <code>0000 0101</code>, 而 -5 则用 <code>1000 0101</code>表示.</p></blockquote><h2 id="真值">真值<a class="" href="#真值"></a></h2><p>计算机中的机器数对应的真实的值就是真数,对最高位(符号位)后面的二进制数转换成十进制,并根据最高位判断正负.</p><blockquote><p>例如上面的数 <code>0000 0101</code> 转换成十进制真值为 5<code>1000 0101</code> 去除第一位符号位 <code>1</code> 后面的二进制转换为十进制为 5 加上第一位符号位 <code>-</code> 所以值为 <code>-5</code></p></blockquote><h2 id="原码">原码<a class="" href="#原码"></a></h2><p>原码就是符号位加上真值的绝对值,即用第一位表示符号, 其余位表示值. 比如如果是8位二进制:</p><p><code>+1 = 0000 0001</code><code>-1 = 1000 0001</code>第一位是符号位,所以 8 位二进制数的取值范围为<code>[1111 1111 , 0111 1111]</code>即 <code>[-127 , 127]</code></p><h2 id="反码">反码<a class="" href="#反码"></a></h2><ul><li>正数的反码是其本身.</li><li>负数的反码是在其原码的基础上,符号位不变,其余各位取反.</li></ul><table><thead><tr><th></th><th>原码</th><th>反码</th></tr></thead><tbody><tr><td><code>+1</code></td><td><code>0000 0001</code></td><td><code>0000 0001</code></td></tr><tr><td><code>-1</code></td><td><code>1000 0001</code></td><td><code>1111 1110</code></td></tr></tbody></table><h2 id="补码">补码<a class="" href="#补码"></a></h2><ul><li>正数的补码是其本身</li><li>负数的补码是在其反码的基础上加 1</li></ul><table><thead><tr><th></th><th>原码</th><th>反码</th><th>补码</th></tr></thead><tbody><tr><td><code>+1</code></td><td><code>0000 0001</code></td><td><code>0000 0001</code></td><td><code>0000 0001</code></td></tr><tr><td><code>-1</code></td><td><code>1000 0001</code></td><td><code>1111 1110</code></td><td><code>1111 1111</code></td></tr></tbody></table><h2 id="为什么使用原码、-反码、-补码">为什么使用原码、 反码、 补码<a class="" href="#为什么使用原码、-反码、-补码"></a></h2><p>原码第一位是符号位,在计算过程中我们会自动根据符号位对真值区域的内容加减.但是对于计算机,加减乘除是最基础的运算.需要设计的尽量简单.计算机辨别符号位显然会让计算机的基础电路设计变的十分复杂.于是人们想出了将符号位也参与运算的方法. 我们知道, 根据运算法则减去一个正数等于加上一个负数, 即: <code>1-1 = 1 + (-1) = 0 </code>, 所以机器可以只有加法而没有减法, 这样计算机运算的设计就更简单了.如果将符号位参与计算:</p><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">原码</span><br><span class="line">1 - 1 = 1 + (-1) = 0000 0001 + 1000 0001 = 1000 0010 = -2</span><br></pre></td></tr></tbody></table></figure><p>如果用原码表示, 让符号位也参与计算, 显然对于减法来说, 结果是不正确的.这也就是为何计算机内部不使用原码表示一个数.为了解决上述问题出现了反码:</p><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">1 -1 = 1 + (-1) = 0000 0001(原) + 1000 0001(原) = 0000 0001(反) + 1111 1110(反) = 1111 1111(反) = 1000 0000(原) = -0</span><br></pre></td></tr></tbody></table></figure><p>用反码计算发现真值部分计算是正确的,而唯一的问题其实就出现在 <code>-0</code> 上,虽然人们理解上+0和-0是一样的, 但是0带符号是没有任何意义的. 而且会有<code>0000 0000</code>和<code>1000 0000</code>两个编码表示0.</p><p>于是补码的出现, 解决了0的符号以及两个编码的问题:</p><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">1 -1 = 1 + (-1) = 0000 0001(原) + 1000 0001(原) = 0000 0001(反) + 1111 1110(反) = 0000 0001(补) + 1111 1111(补) = (1)0000 0000(补) = 0000 0000(原) = 0</span><br></pre></td></tr></tbody></table></figure><p>这样0用<code>0000 0000</code>表示, 而以前出现问题的-0则不存在了.而且可以用<code>1000 0000</code>表示<code>-128</code>.</p><p><code>-1-127</code>的结果应该是<code>-128</code>, 在用补码运算的结果中, <code>1000 0000(补)</code> 就是<code>-128</code>. 但是注意因为实际上是使用以前的<code>-0</code>的补码来表示<code>-128</code>, 所以<code>-128</code>并没有原码和反码表示.对<code>-128</code>的补码表示<code>1000 0000</code>补算出来的原码是<code>0000 0000</code>原, 这是不正确的)</p><p>使用补码, 不仅仅修复了0的符号以及存在两个编码的问题, 而且还能够多表示一个最低数. 这就是为什么8位二进制, 使用原码或反码表示的范围为<code>[-127, +127]</code>, 而使用补码表示的范围为<code>[-128, 127]</code>.</p><p>因为机器使用补码, 所以对于编程中常用到的32位int类型, 可以表示范围是: <code>[-2^31, 2^31-1]</code> 因为第一位表示的是符号位.而使用补码表示时又可以多保存一个最小值.</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 计算机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础 - 数据类型和运算符</title>
      <link href="/post/164885510/"/>
      <url>/post/164885510/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Java 语言支持的类型分为两类：<code>基本数据类型</code>（Primitive Type）和<code>引用类型</code>（Reference Type）。</p></blockquote><h2 id="基本数据类型">基本数据类型<a class="" href="#基本数据类型"></a></h2><h3 id="数值类型">数值类型<a class="" href="#数值类型"></a></h3><h4 id="整数类型">整数类型<a class="" href="#整数类型"></a></h4><h5 id="byte">byte<a class="" href="#byte"></a></h5><p>一个 <code>byte</code> 类型在内存中占 8 位（1字节）范围<code>-128(-2^7) ~ 127(2^7 -1)</code></p><h5 id="short">short<a class="" href="#short"></a></h5><p>一个 <code>short</code> 类型在内存中占 16 位（2字节）范围<code>-32768(-2^15) ~ 32767(2^15-1)</code></p><h5 id="int">int<a class="" href="#int"></a></h5><p>一个 <code>int</code> 类型在内存占 32 位（4字节）范围<code>-2147483648(-2^31) ~ 2147483647(2^31-1)</code></p><h5 id="long">long<a class="" href="#long"></a></h5><p>一个 <code>long</code> 类型在内存中占 64 位（8 字节）范围<code>-2^63 ~ 2^63-1</code></p><blockquote><p>如果直接将一个较小的整数值（在 <code>byte</code> 或者 <code>short</code> 类型的范围内）赋给一个 <code>byte</code> 或者 <code>short</code> 的变量,系统会自动把这个整数值当成 <code>byte</code> 或者 <code>short</code> 类型来处理.如果使用一个巨大的整数值（超出 int 类型的范围）时，Java 不会自动把这个整数值当成 long 类型来处理。如果希望系统把一个整数值当成 long 类型来处理，应在这个整数值后增加 <code>l</code> 或者 <code>L</code> 做后缀。</p></blockquote><h4 id="浮点类型">浮点类型<a class="" href="#浮点类型"></a></h4><p>Java 的浮点类型有固定的表数范围和字段长度，字段长度和表数范围与机器无关，Java 的浮点类型遵循 IEEE 标准，采用二进制的科学计数法来表示。</p><h5 id="float">float<a class="" href="#float"></a></h5><p>一个 float 类型在内存中占 4 字节，32 位，第 1 位是符号位，接下来的 8 位表示指数，在接下来的 23 位表示位数。</p><h5 id="double">double<a class="" href="#double"></a></h5><p>一个 double 类型在内存中占 8 字节，64 位，第 1 位表示符号位，接下来的 11 位表示指数，在接下来的 52 位表示尾数。</p><blockquote><p>因为 Java 浮点数是用二进制的科学计数法来表示浮点数，因此可能不能精确表示一个浮点数。例如把 <code>5.12345f</code>赋值给一个 <code>float</code> 类型的变量，接着输出这个变量时看到这个变量的值已经发生了改变。 如果需要一个精确的浮点数，可以使用 <code>BigDecimal</code> 类。浮点类型默认的是 <code>double</code> 如果希望 <code>Java</code> 把一个浮点类型值当成 <code>float</code> 来处理，应当在这个浮点类型值后面紧跟一个 <code>f</code> 或者 <code>F</code>。Java 还提供了三个特殊的浮点数值：正无穷大，负无穷大和非数，用于表示溢出或者出错。正浮点数除以 0（Java会自动把和浮点数进行运算的整数 0 当成浮点数 0.0 处理）得到正无穷大（Double/Float 类中的 POSITIVE_INFINITY）.使用一个负浮点数除以 0 得到负无穷大（Double/Float 类中的 NEGATIVE_INFINITY）表示。0.0/0.0 将得到一个非数 NaN.所有的正无穷大以及负无穷大都相等，所有的非数都不相等。100_000_000_000数值中的<code>_</code>方便阅读。无实际含义。</p></blockquote><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/images/post/2020/08/951706-20200323215446735-1513344345.png" alt="Java的基本数据类型"></p><h3 id="字符型">字符型<a class="" href="#字符型"></a></h3><h4 id="char">char<a class="" href="#char"></a></h4><p>字符型有三种表示形式</p><ul><li>直接通过单个字符来指定字符型值，例如<code>'A'</code>、<code>'9'</code> 和 <code>'0'</code> 等.</li><li>通过转移字符标识特殊字符型值，例如<code>'\n'</code>、<code>'\t'</code></li><li>直接使用 <code>Unicode</code> 值来表示字符型值，格式是<code>'\uXXXX'</code>，其中 <code>XXXX</code> 代表 一个十六进制的整数。</li></ul><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/images/post/2020/08/951706-20200323215720373-1797207154.png" alt="Java 语言中常用的转移字符"></p><p>字符类型也可以使用十六进制编码方式来表示，范围是<code>'\u0000'~'\uFFFF'</code>，一共可以表示 <code>65535</code> 个字符，其中前 256 个（<code>'\u0000'~'\u00FF'</code>）字符和 ASCII 码中的字符完全重合。计算机底层保存字符时，实际上保存的是该字符对应的编号，因此 <code>char</code> 类型的值可以直接作为整形使用，它相当于一个 16 位的无符号整数，表数范围是 <code>0~65535</code>.如果把 0~65535 范围内的一个 <code>int</code> 整数赋给 <code>char</code> 类型变量，系统自动会把这个 <code>int</code> 整数当成 <code>char</code> 类型来处理</p><h3 id="布尔类型">布尔类型<a class="" href="#布尔类型"></a></h3><h4 id="boolean">boolean<a class="" href="#boolean"></a></h4><p>用于表示逻辑上的<code>真</code>或<code>假</code>, <code>boolean</code>类型的数值只能是 <code>true</code> 或者 <code>false</code>, 不能用 <code>0</code> 或者<code>非0</code> 来表示，其他基本数据类型也不能转换成 <code>boolean</code> 类型。</p><blockquote><p>Java 规范没有强制指定 boolean 类型的变量所占用的内存空间。由于大部分计算机在内存分配时允许的最小内存单元是字节（8 位），因此 bit 大部分时候实际占用 8 位。Java虚拟机规范一书提到 :</p><ul><li>在Java虚拟机中没有任何供 boolean值专用的字节码指令,Java语言表达式所操作的boolean值,在编译之后都使用Java虚拟机中的int数据类型来代替。</li><li>Java虚拟机直接支持 boolean类型的数组,虚拟机的 navarra指令参见第6章的newarray小节可以创建这种数组。boolean类型数组的访问与修改共用byte类型数组的baload和 bastore指令。因为在虚拟机规范中说了，boolean值在编译之后都使用Java虚拟机中的int数据类型来代替，而int是4个字节，那么boolean值就是4个字节。</li><li>boolean类型数组的访问与修改共用byte类型数组的baload和 bastore指令，因为两者共用，只有两者字节一样才能通用呀，所以byte数组中一个byte是1个字节，那么boolean数组中boolean是1个字节。</li></ul><p>总结：boolean在数组情况下为1个字节，单个boolean为4个字节。</p></blockquote><h3 id="基本数据类型的转换">基本数据类型的转换<a class="" href="#基本数据类型的转换"></a></h3><p>Java 所有的数值类型可以相互转换,如果系统支持把某种基本类型的值直接赋给另一种基本类型的变量,则这种方式被称为自动类型转换.当把一个表述范围小的数值或者变量直接赋给另一个表数范围大的变量时,系统可以进行自动类型转换.否则就需要强制转换.</p><h4 id="自动类型转换">自动类型转换<a class="" href="#自动类型转换"></a></h4><p>表数范围小的数值赋给表数范围的变量.Java 支持自动类型转换图:<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/images/post/2020/08/951706-20200323223122563-815869275.png" alt="Java自动类型转换图"></p><p>除了基本类型的自动转换外,把任何基本类型的值和字符串进行连接运算时,基本类型的值将自动转为字符串类型(ps:将基本类型转化为字符串类型时,可以把基本类型的值与空字符串相加).</p><h4 id="强制类型转换">强制类型转换<a class="" href="#强制类型转换"></a></h4><p>如果想把上图箭头右边的数据类型转换为左边的类型,则必须进行强制类型转换.强转的格式为<code>(TargetType)value</code>强制类型转换的运算符是圆括号.需要注意强制类型转换会造成数据溢出,从而导致数据丢失.</p><h4 id="表达式类型的自动提升">表达式类型的自动提升<a class="" href="#表达式类型的自动提升"></a></h4><p>当一个算术表达式中包含多个基本类型的值时, 整个算术表达式的数据类型将发生自动提升.Java 自动提升规则:</p><ul><li>所有的 byte 类型,short 类型和 char 类型将被提升到 int 类型.</li><li>整个算术表达式的数据类型自动提升到与表达式中最高等级操作同样的类型.操作数的等级如上如所示,箭头右边的等级高于箭头左边类型的等级.</li></ul><h2 id="引用数据类型">引用数据类型<a class="" href="#引用数据类型"></a></h2><h3 id="类">类<a class="" href="#类"></a></h3><h3 id="接口">接口<a class="" href="#接口"></a></h3><h3 id="数组">数组<a class="" href="#数组"></a></h3><h2 id="运算符">运算符<a class="" href="#运算符"></a></h2><h3 id="算术运算符">算术运算符<a class="" href="#算术运算符"></a></h3><ul><li><code>+</code>: 加法运算符（还可以作为字符串的连接运算符）</li><li><code>-</code>: 减法运算符</li><li><code>*</code>: 乘法运算符</li><li><code>/</code>: 除法运算符如果除法运算的两个操作数都是整数类型，则计算结果也是整数，就是将自然除法的结果截取取整。如果除法运算两个操作数都是整数类型，则除数不可以是 0，否则将引发除以 0 异常。如果一个或两个操作数是浮点数，则计算结果也是浮点数，这个结果就是自然除法的结果，而且此时允许除数是 0 或者 0.0，得到的结果是正无穷大挥着负无穷大。</li><li><code>%</code>: 求余运算符</li><li><code>++</code>: 自加。<ol><li>自加是单目运算符，只能操作一个数。</li><li>自加运算符只能操作单个数值型（整形、浮点型）变量，不能操作常量或表达式。</li><li>如果 ++ 放在左边，则先把操作数加 1，然后才把操作数放入表达式中运算。如果 ++ 放在右边，则先把操作数放入表达式中运算，然后才把操作数加 1</li></ol></li><li><code>--</code>: 自减。单目运算符。与<code>++</code> 类似，只是将操作数 -1</li></ul><h3 id="位运算符">位运算符<a class="" href="#位运算符"></a></h3><ul><li><code>&amp;</code>: 按位与。当两位同时为 1 时才返回 1.</li><li><code>|</code>: 按位或。只要有一位为 1 即可返回 1。</li><li><code>~</code>: 按位非。单目运算符，将操作数的每个位（包括符号位）全部取反。</li><li><code>^</code>: 按位异或。当两位相同时返回0，不同时返回 1。</li><li><code>&lt;&lt;</code>: 左移运算符。</li><li><code>&gt;&gt;</code>: 右移运算符.</li><li><code>&gt;&gt;&gt;</code>: 无符号右移运算符.</li></ul><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/images/post/2020/08/951706-20200323215944211-1187141680.png" alt="位运算符运算法则"></p><h3 id="逻辑运算符">逻辑运算符<a class="" href="#逻辑运算符"></a></h3><ul><li><code>&amp;&amp;</code>: 与,前后两个操作数必须都是 <code>true</code> 才返回 <code>true</code>,否则饭后 <code>false</code>.</li><li><code>&amp;</code>: 不短路与,与 <code>&amp;&amp;</code>作用相同,但不会短路.</li><li><code>||</code>:或,只要两个操作数一个为<code>true</code>,则返回 <code>true</code>,否则返回 <code>false</code></li><li><code>|</code>: 不短路或, 作用与 <code>||</code>相同,但不会短路.</li><li><code>!</code>: 非. 取反</li><li><code>^</code>: 异或. 当两个操作数不同时返回 <code>true</code>,相同时返回 <code>false</code></li></ul><h3 id="三目运算符">三目运算符<a class="" href="#三目运算符"></a></h3><ul><li><code>?:</code> 三目运算符只有一个,语法格式为<code>(expression) ? if-true-statement : if-false-statement</code></li></ul><blockquote><p>注意：自加和自减只能用于惭怍变量，不能用于操作数值直接量、常量或表达式。</p></blockquote><h3 id="赋值运算符">赋值运算符<a class="" href="#赋值运算符"></a></h3><ul><li><code>=</code></li></ul><h4 id="扩展后的赋值运算符">扩展后的赋值运算符<a class="" href="#扩展后的赋值运算符"></a></h4><ul><li><code>+=</code>: 对于 <code>x+=y</code>,即对应于 <code>x = x + y</code></li><li><code>-=</code>: 对于 <code>x-=y</code>,即对应于 <code>x = x - y</code></li><li><code>*=</code>: 对于 <code>x*=y</code>,即对应于 <code>x = x * y</code></li><li><code>/=</code>: 对于 <code>x/=y</code>,即对应于 <code>x = x / y</code></li><li><code>%=</code>: 对于 <code>x%=y</code>,即对应于 <code>x = x % y</code></li><li><code>|=</code>: 对于 <code>x|=y</code>,即对应于 <code>x = x | y</code></li><li><code>^=</code>: 对于 <code>x^=y</code>,即对应于 <code>x = x ^ y</code></li><li><code>&lt;&lt;=</code>: 对于 <code>x&lt;&lt;=y</code>,即对应于 <code>x = x &lt;&lt; y</code></li><li><code>&gt;&gt;=</code>: 对于 <code>x&gt;&gt;=y</code>,即对应于 <code>x = x &gt;&gt; y</code></li><li><code>&gt;&gt;&gt;=</code>: 对于 <code>x&gt;&gt;&gt;=y</code>,即对应于 <code>x = x &gt;&gt;&gt; y</code></li></ul><h3 id="比较运算符">比较运算符<a class="" href="#比较运算符"></a></h3><ul><li><code>&gt;</code>: 大于,只支持左右两边操作数是数值类型.</li><li><code>&gt;=</code>: 大于等于,只支持左右两边操作数是数值类型.</li><li><code>&lt;</code>: 小于,只支持左右两边操作数是数值类型.</li><li><code>&lt;=</code>: 小于等于,只支持左右两边操作数是数值类型.</li><li><code>==</code>: 等于,如果比较的两个操作数都是数值类型,即使两个操作数的类型不同,只要他们值相等,也返回<code>true</code>. 如果两个操作数都是引用类型,那么比较的是两个操作数的引用地址.</li><li><code>!=</code>: 不等于.数据类型比较,无关类型,只进行值比较.引用类型比较对象的引用地址.</li></ul><h3 id="运算符的优先级">运算符的优先级<a class="" href="#运算符的优先级"></a></h3><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/images/post/2020/08/951706-20200323215918804-1820470180.png" alt="运算符的优先级"></p><ul><li>不要把一个表达式写的过于复杂,如果一个表达式复杂,则应该拆成几步来执行</li><li>不要过多的依赖运算符的优先级来控制表达式的执行顺序,尽量用 <code>()</code> 来控制</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>

<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>陈建源的博客 - Hello World</title><meta name="keywords" content="Spring  MyBatis  Springboot chenjianyuan 陈建源 Java 数据库 MySQL SpringMVC 算法 数据结构"><meta name="author" content="陈建源"><meta name="copyright" content="陈建源"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="过着平凡的生活，享受着简单的人生"><meta property="og:type" content="website"><meta property="og:title" content="陈建源的博客"><meta property="og:url" content="https://www.techstack.tech/"><meta property="og:site_name" content="陈建源的博客"><meta property="og:description" content="过着平凡的生活，享受着简单的人生"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://www.techstack.tech/img/avatar.png"><meta property="article:author" content="陈建源"><meta property="article:tag" content="Spring  MyBatis  Springboot chenjianyuan 陈建源 Java 数据库 MySQL SpringMVC 算法 数据结构"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://www.techstack.tech/img/avatar.png"><link rel="shortcut icon" href="/img/avatar.png"><link rel="canonical" href="https://www.techstack.tech/"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":300},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: 陈建源","link":"链接: ","source":"来源: 陈建源的博客","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: true,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"陈建源的博客",isPost:!1,isHome:!0,isHighlightShrink:!1,isToc:!1,postUpdate:"2022-04-21 16:52:16"}</script><noscript><style type="text/css">#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    })(window)</script><meta name="generator" content="Hexo 5.1.1"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.png" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">55</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/m/"><div class="headline">分类</div><div class="length-num">11</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa-solid fa-book"></i><span> 必修课</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/m/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%95%99%E7%A8%8B/"><span>数据结构和算法</span></a></li><li><a class="site-page child" href="/m/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%95%99%E7%A8%8B/"><span>计算机操作系统</span></a></li><li><a class="site-page child" href="/m/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%95%99%E7%A8%8B/"><span>计算机网络</span></a></li><li><a class="site-page child" href="/m/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%95%99%E7%A8%8B/"><span>计算机组成原理</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa-brands fa-java"></i><span> Java</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/m/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"><span>基础知识</span></a></li><li><a class="site-page child" href="/m/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"><span>集合框架</span></a></li><li><a class="site-page child" href="/m/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"><span>并发编程</span></a></li><li><a class="site-page child" href="/m/JVM/"><span>JVM</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa-solid fa-database"></i><span> 数据库</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/m/MySQL/"><span>MySQL</span></a></li><li><a class="site-page child" href="/m/Redis/"><span>Redis</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa-solid fa-code"></i><span> 源码框架</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/m/OpenFeign/"><span>OpenFeign</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa-solid fa-marker"></i><span> 设计与理论</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/m/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><i class="fa-fw fas fa-layer-group"></i><span> 设计模式</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa-solid fa-c"></i><span> 辅助语言</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/m/C%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E6%89%8B%E5%86%8C/"><span>C语言入门手册</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa-solid fa-jet-fighter-up"></i><span> 开发工具</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/m/Maven/"><span>Maven</span></a></li></ul></div></div></div></div><div class="page" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">陈建源的博客</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa-solid fa-book"></i><span> 必修课</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/m/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%95%99%E7%A8%8B/"><span>数据结构和算法</span></a></li><li><a class="site-page child" href="/m/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%95%99%E7%A8%8B/"><span>计算机操作系统</span></a></li><li><a class="site-page child" href="/m/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%95%99%E7%A8%8B/"><span>计算机网络</span></a></li><li><a class="site-page child" href="/m/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%95%99%E7%A8%8B/"><span>计算机组成原理</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa-brands fa-java"></i><span> Java</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/m/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"><span>基础知识</span></a></li><li><a class="site-page child" href="/m/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"><span>集合框架</span></a></li><li><a class="site-page child" href="/m/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"><span>并发编程</span></a></li><li><a class="site-page child" href="/m/JVM/"><span>JVM</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa-solid fa-database"></i><span> 数据库</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/m/MySQL/"><span>MySQL</span></a></li><li><a class="site-page child" href="/m/Redis/"><span>Redis</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa-solid fa-code"></i><span> 源码框架</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/m/OpenFeign/"><span>OpenFeign</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa-solid fa-marker"></i><span> 设计与理论</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/m/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><i class="fa-fw fas fa-layer-group"></i><span> 设计模式</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa-solid fa-c"></i><span> 辅助语言</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/m/C%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E6%89%8B%E5%86%8C/"><span>C语言入门手册</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa-solid fa-jet-fighter-up"></i><span> 开发工具</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/m/Maven/"><span>Maven</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div class="recent-posts" id="recent-posts"><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/post/165052629/" title="深入理解Volatile">深入理解Volatile</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2022-04-21T07:31:28.000Z" title="发表于 2022-04-21 15:31:28">2022-04-21</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/m/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">并发编程</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/Java/">Java</a><span class="article-meta__link">•</span><a class="article-meta__tags" href="/tags/%E5%B9%B6%E5%8F%91/">并发</a></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-comments"></i><a href="/post/165052629/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count" data-xid="/post/165052629/" itemprop="commentCount"></span></a><span class="article-meta-label"> 条评论</span></span></div><div class="content">在并发理论基础：Java 内存模型JMM一文中讲到 JMM 模型是 Java 抽象出来的一个概念，用来屏蔽不同硬件和操作系统对于内存访问的差异，让 Java 程序能在不同平台上达到一致的运行效果。规范了 JVM 与计算机内存如何系统工作，规定了一个线程如何和何时可以看到其他线程修改后的共享变量的值，以及如何将共享变量的值写入主存。JMM 围绕原子性，可见性和有序性展开的，其实现的核心主要包括volatile,synchronized和final关键字以及几项happen-before原则。本文就volatile如何在 JMM 中的作用以及实现原理展开讨论。 volatile的特性 JMM是围绕原子性、可见性、有序性展开的。volatile 是 JMM 实现的一个核心之一，讨论volatile 在 JMM 中的作用也需要围绕原子性、可见性、有序性这三个方面来展开。 可见性 根据JSR-133 FAQ中的说明，volatile字段是用于在线程之间传递状态的特殊字段。每次读取volatile时，都会看到任意一个线程对该volatile的最后一次写入。 实际上，程序员将volatile字段指定 ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/post/165052618/" title="并发理论接触：内存屏障">并发理论接触：内存屏障</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2022-04-21T07:29:30.000Z" title="发表于 2022-04-21 15:29:30">2022-04-21</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/m/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">并发编程</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/Java/">Java</a><span class="article-meta__link">•</span><a class="article-meta__tags" href="/tags/%E5%B9%B6%E5%8F%91/">并发</a></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-comments"></i><a href="/post/165052618/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count" data-xid="/post/165052618/" itemprop="commentCount"></span></a><span class="article-meta-label"> 条评论</span></span></div><div class="content">为了提高 CPU 的运行效率，现代计算机做了两个方面的优化。一是引入的缓存，二是增加了 CPU 乱序执行指令集。 引入缓存后，就出现了缓存一致性问题。为了解决缓存一致性问题，引入了 MESI 缓存一致性协议。同时为了优化 M -&gt; I 状态的 CPU 等待时间，加入了 StoreBuffer 和 InvalidQueue，从而使 MESI 变成了弱一致性协议，只能实现最终一致。 CPU 乱序执行指令集在单线程情况下按照 as-if-serial 原则不会出现问题，但是在多线程下，对于一些共享变量就会出现一些问题，从而造成了指令重排现象。 这两种情况在并发情况下都会造成对共享变量的读写不一致问题，也就是指令重排的现象。但是从整体看，两种优化方案都是积极有利的，对并发情况下对于共享变量的操作，硬件系统提供了一种内存屏障的机制来禁止 MESI 的优化以及 CPU 乱序执行。 内存屏障 处理器乱序规则 上面我们说了处理器会发生指令重排,现在来简单的看看常见处理器允许的重排规则,换言之就是处理器可以对那些指令进行顺序调整: 处理器 Load-Load Load-Store Store ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/post/164995635/" title="并发理论基础：Java 内存模型JMM">并发理论基础：Java 内存模型JMM</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2022-04-14T17:12:29.000Z" title="发表于 2022-04-15 01:12:29">2022-04-15</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/m/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">并发编程</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/Java/">Java</a><span class="article-meta__link">•</span><a class="article-meta__tags" href="/tags/%E5%B9%B6%E5%8F%91/">并发</a></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-comments"></i><a href="/post/164995635/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count" data-xid="/post/164995635/" itemprop="commentCount"></span></a><span class="article-meta-label"> 条评论</span></span></div><div class="content">在并发理论基础：缓存可见性、MESI一文中分析了缓存可见性导致的并发问题。为了解决缓存可见性问题所以有了缓存一致性协议 MESI，但是MESI的同步等待机制会影响性能，所以用了 storeBuffer 来优化，但是优化过后还是会在一些场景存在可见性问题。这个时候又不能单方面的放弃优化，所以就提供一套内存屏障些指令来让我们的开发人员可以根据自己的场景来决定什么是需要禁用CPU缓存优化来避免可见性问题。 在并发理论基础：指令重排序问题一文中分析了指令重排序现象引发的并发问题。虽然 CPU 层面通过as-if-serial原则来保证指令集重排乱序执行的结果在单线程场景下结果的正确性。但是as-if-serial原则在多线程场景是行不通的，因为CPU没办法通过指令来辨别多线程中的指令逻辑依赖，所以这个时候CPU和编译器它们也提供了屏障指令来让我们的开发人员可以根据自己的场景来决定什么是需禁止重排序来避免重排序可能导致的并发问题。 以上我们说的都是计算机硬件方面的实现,但是 JVM 是运行在操作系统层面的，不同的硬件架构的缓存体系不一样，指令重排序的策略不一样，所提供的内存屏障指令也就有差异。而 ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/post/164942290/" title="并发理论基础：指令重排序问题">并发理论基础：指令重排序问题</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2022-04-08T13:01:28.000Z" title="发表于 2022-04-08 21:01:28">2022-04-08</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/m/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">并发编程</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/Java/">Java</a><span class="article-meta__link">•</span><a class="article-meta__tags" href="/tags/%E5%B9%B6%E5%8F%91/">并发</a></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-comments"></i><a href="/post/164942290/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count" data-xid="/post/164942290/" itemprop="commentCount"></span></a><span class="article-meta-label"> 条评论</span></span></div><div class="content">什么是指令的重排序 我们平时所讲的指令重排很容易被当成动词去理解，其实正确的理解是当成名词，即指令重排现象。简单来说就是： 在程序中写的代码，在执行时并不一定按照写的顺序。 现象展示 public class PossibleReordering {static int x = 0, y = 0;static int a = 0, b = 0;public static void main(String[] args) throws InterruptedException { Thread one = new Thread(new Runnable() { public void run() { a = 1; x = b; } }); Thread other = new Thread(new Runnable() { public void run() { b = 1; y = a; } }); one ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/post/164926797/" title="并发理论基础：缓存可见性、MESI">并发理论基础：缓存可见性、MESI</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2022-04-06T17:59:31.000Z" title="发表于 2022-04-07 01:59:31">2022-04-07</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/m/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">并发编程</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/Java/">Java</a><span class="article-meta__link">•</span><a class="article-meta__tags" href="/tags/%E5%B9%B6%E5%8F%91/">并发</a></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-comments"></i><a href="/post/164926797/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count" data-xid="/post/164926797/" itemprop="commentCount"></span></a><span class="article-meta-label"> 条评论</span></span></div><div class="content">从“并发理论基础：并发问题产生的三大根源” 文中我们简单的介绍了造成共享变量可见性问题的根源是CPU缓存的问题，那么这里我们再详细的把这个话题展开讨论下，最终计算机领域是如何解决缓存缓存可见性问题的。 CPU缓存导致的可见性问题 我们现在都知道了CPU加缓存都是为了提升CPU的利用率， 但是也衍生了一个问题，多核CPU的情况下，每个CPU都有着自己独立的缓存，它们各自之间是不可见的，这就会导致对应CPU读取的数据都是自己缓存的，无法看到别人对共享数据的修改，从而导致并发BUG。 缓存一致性问题的思考 导致缓存一致性问题的核心主要是两个问题： 问题一： 在一个CPU修改了内存数据的时候，其它CPU是不知道的，所以导致一个CPU改了，另外一个CPU看不见，从而使用了旧的数据，导致了程序不正确的结果。 问题二： 在多个CPU同时读取和修改CPU的时候，如何保证这几个CPU操作的顺序性，一旦不能保证整个修改操作的顺序，那么就可能导致先写后读的两个请求，结果反映到内存就成了先读后写的结果，从而没有读取到最新的数据，又或者两个写数据的请求顺序被调换了，那么就可能会造成脏写。 基于总线的一致性解决 ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/post/164913260/" title="并发理论基础：原子性问题">并发理论基础：原子性问题</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2022-04-05T03:25:31.000Z" title="发表于 2022-04-05 11:25:31">2022-04-05</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/m/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">并发编程</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/Java/">Java</a><span class="article-meta__link">•</span><a class="article-meta__tags" href="/tags/%E5%B9%B6%E5%8F%91/">并发</a></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-comments"></i><a href="/post/164913260/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count" data-xid="/post/164913260/" itemprop="commentCount"></span></a><span class="article-meta-label"> 条评论</span></span></div><div class="content">我们再回顾一下，原子性问题的根源是CPU切换线程执行指令所导致的，当前一个对共享变量的操作没有完成之前，CPU又切换到另外一个线程来操作对应的共享变量，那么最终产生的结果就可能出现问题。 比如如果现在有两个线程都在执行number=number+1，他们最终的结果可能还是为1,因为PU执行流程可能会如下： 如解决原子性问题 从上面的案例看，原子性问题的丢失完全是因为CPU切换线程执行指令导致的，那么是否意味着只要禁止CPU切换线程执行指令就可以呢，结果是行不通的，禁止CPU切换指令在单核CPU的确可以解决这个问题，但是多核CPU的场景下，CPU可以同时调度多个线程执行指令，那么该问题还是存在的。 所以我们必须另找出路，回过头来思考，我们会发现一个共性，就是不管是线程切换还是多核CPU同时执行指令，其实根本原因就是，对于共享变量在修改操作，在一个线程没有完成之前，另外一个线程是可以同时介入操作,所以才会导致一个线程的结果可能被另外一个线程覆盖。如果从这个角度来考虑的话，那么是不是只要达成一个线程在操作共享变量的过程中，另外一个线程是不能介入操作，只有等前面一个线程执行完之后，后面的线程 ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/post/164912916/" title="并发理论基础：并发与并行">并发理论基础：并发与并行</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2022-04-05T03:25:31.000Z" title="发表于 2022-04-05 11:25:31">2022-04-05</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/m/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">并发编程</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/Java/">Java</a><span class="article-meta__link">•</span><a class="article-meta__tags" href="/tags/%E5%B9%B6%E5%8F%91/">并发</a></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-comments"></i><a href="/post/164912916/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count" data-xid="/post/164912916/" itemprop="commentCount"></span></a><span class="article-meta-label"> 条评论</span></span></div><div class="content">并发问题应该算是最让程序员头疼的问题了，无论工作还是面试过程中一谈到并发问题就显得非常高深。随着互联网的普及造成的巨大的用户量，并发问题又无法避免。在我们学习并发编程之前首先要明白什么是编发，了解并发的概念是我们后续学习的基础。 谈到并发的概念不得不提的就是并行概念。并发和并行最开始都是操作系统中的概念，表示的是CPU执行多个任务的方式。关于并发与并行的区别： 解释一：并行是指两个或者多个事件在同一时刻发生；而并发是指两个或多个事件在同一时间间隔发生。 解释二：并行是在不同实体上的多个事件，并发是在同一实体上的多个事件**。** 解释三：在一台处理器上“同时”处理多个任务，在多台处理器上同时处理多个任务。如hadoop分布式集群 所以并发编程的目标是充分的利用处理器的每一个核，以达到最高的处理性能。 所谓"同时"进行 我们现在使用的操作系统，是可以"同时"做很多件事儿的。比如我们可以一边看电影，一边聊QQ；一边听歌，一边打游戏。但是，这所谓的"同时"，在操作系统底层可能并不是真正的意义上的"同时"。 实际上，对于单CPU的计算机来说，在CPU中，同一时间是只能干一件事儿的。为了看起 ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/post/164912852/" title="并发理论基础：并发问题产生的三大根源">并发理论基础：并发问题产生的三大根源</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2022-04-05T03:15:11.000Z" title="发表于 2022-04-05 11:15:11">2022-04-05</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/m/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">并发编程</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/Java/">Java</a><span class="article-meta__link">•</span><a class="article-meta__tags" href="/tags/%E5%B9%B6%E5%8F%91/">并发</a></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-comments"></i><a href="/post/164912852/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count" data-xid="/post/164912852/" itemprop="commentCount"></span></a><span class="article-meta-label"> 条评论</span></span></div><div class="content">在我们去解决并发问题之前首先要理解什么是并发问题，造成并发问题的根源什么，所有并发处理的工具只是针对这些根源问题的其中一种解决方案。所以我们在学习并发解决方案或者编写并发程序时，我们首先要深入理解并发问题的根源是什么。 或许我们都知道并发问题的三大源头： 原子性 可见性 有序性 但是这三大源头到底是什么意思，怎么产生的呢？ 起因：如何最大化的利用CPU CPU运算速度和IO速度的不平衡一直是计算机优化的一个课题，我们都知道CPU运算速度要以百倍千倍程度快于IO的速度，而在进行任务的执行的时候往往都会需要进行数据的IO，正因为这种速度上的差异，所以当CPU和IO一起协作的时候就产生问题了，CPU执行速度非常快，一个任务执行时候大部分时间都是在等待IO工作完成，在等待IO的过程中CPU是无法进行其它工作的，所以这样就使得CPU的资源根本无法合理的运用起来。 CPU就相当于我们计算机的大脑，如何把CPU资源合理的利用起来就直接关系到我们计算机的效率和性能，所以为了这个课题计算机分别从缓存、任务切换、指令排序优化这几个方向进行了优化 。 一、进程和线程的产生 在最原始的系统里计算机内存中 ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/post/164885530/" title="说一说我理解的Java">说一说我理解的Java</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2022-04-01T22:21:13.000Z" title="发表于 2022-04-02 06:21:13">2022-04-02</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/m/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">基础知识</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/Java/">Java</a></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-comments"></i><a href="/post/164885530/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count" data-xid="/post/164885530/" itemprop="commentCount"></span></a><span class="article-meta-label"> 条评论</span></span></div><div class="content">大四校招时第一次接触 Java，了解到 Java 或者说编程也是全靠培训机构，对 Java 的第一印象就是 速成 、高薪, 就业一年就能月薪一万。所以当时就在金钱的诱惑下来到了北京学习 Java 。 所以刚开始学习的时候，有好多问题在困扰我： Java 是什么？为什么叫 Java？Java 能干什么？为什么 main 方法要这么写？ 后面随着学习和学习和看书，大部分都是从Java的发展史开始讲，总之就是那些什么Java历史悠久，Java很优秀，Java越来越牛，用的人越来越多，什么编程语言排行榜常年第一，大致都是这些，然后再扯些其他的，接着就上起了Hello World！就这样，Java生涯的第一个程序开始了，意思是“你好，世界！” 不过这些问题始终困扰着我，我也始终不知道这些答案。不过我学会了百度： 百度百科是这样介绍 Java 的： Java是一门面向对象的编程语言，不仅吸收了C++语言的各种优点，还摒弃了C++里难以理解的多继承、指针等概念，因此Java语言具有功能强大和简单易用两个特征。Java语言作为静态面向对象编程语言的代表，极好地实现了面向对象理论，允许程序员以优 ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/post/164885535/" title="Redis入门-Redis概念和基础">Redis入门-Redis概念和基础</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2022-04-01T13:42:39.000Z" title="发表于 2022-04-01 21:42:39">2022-04-01</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/m/Redis/">Redis</a></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-comments"></i><a href="/post/164885535/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count" data-xid="/post/164885535/" itemprop="commentCount"></span></a><span class="article-meta-label"> 条评论</span></span></div><div class="content">Redis是一种支持key-value等多种数据结构的存储系统。可用于缓存，事件发布或订阅，高速队列等场景。支持网络，提供字符串，哈希，列表，队列，集合结构直接存取，基于内存，可持久化。 什么是Redis Redis是一款内存高速缓存数据库。Redis全称为：Remote Dictionary Server（远程数据服务），使用C语言编写，Redis是一个key-value存储系统（键值存储系统），支持丰富的数据类型，如：String、list、set、zset、hash。 Redis是一种支持key-value等多种数据结构的存储系统。可用于缓存，事件发布或订阅，高速队列等场景。支持网络，提供字符串，哈希，列表，队列，集合结构直接存取，基于内存，可持久化。 官方资料 Redis官网:http://redis.io/ Redis官方文档:http://redis.io/documentation Redis教程:http://www.w3cschool.cn/redis/redis-intro.html Redis下载:http://redis.io/download 为什么要使用 ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/post/164885534/" title="MySQL数据类型">MySQL数据类型</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2022-04-01T13:36:40.000Z" title="发表于 2022-04-01 21:36:40">2022-04-01</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/m/MySQL/">MySQL</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/MySQL/">MySQL</a><span class="article-meta__link">•</span><a class="article-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-comments"></i><a href="/post/164885534/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count" data-xid="/post/164885534/" itemprop="commentCount"></span></a><span class="article-meta-label"> 条评论</span></span></div><div class="content">字段类型 整型 TINYINT, SMALLINT, MEDIUMINT, INT, BIGINT 分别使用 8, 16, 24, 32, 64 位存储空间，一般情况下越小的列越好。 INT(11) 中的数字只是规定了交互工具显示字符的个数，对于存储和计算来说是没有意义的。 浮点数 FLOAT 和 DOUBLE 为浮点类型，DECIMAL 为高精度小数类型。CPU 原生支持浮点运算，但是不支持 DECIMAl 类型的计算，因此 DECIMAL 的计算比浮点类型需要更高的代价。 FLOAT、DOUBLE 和 DECIMAL 都可以指定列宽，例如 DECIMAL(18, 9) 表示总共 18 位，取 9 位存储小数部分，剩下 9 位存储整数部分。 字符串 主要有 CHAR 和 VARCHAR 两种类型，一种是定长的，一种是变长的。 VARCHAR 这种变长类型能够节省空间，因为只需要存储必要的内容。但是在执行 UPDATE 时可能会使行变得比原来长，当超出一个页所能容纳的大小时，就要执行额外的操作。MyISAM 会将行拆成不同的片段存储，而 InnoDB 则需要分裂页来使行放进页内。 VA ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/post/164885512/" title="集合框架总览">集合框架总览</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2022-04-01T12:45:16.000Z" title="发表于 2022-04-01 20:45:16">2022-04-01</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/m/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/">集合框架</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/Java-%E9%9B%86%E5%90%88/">Java 集合</a></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-comments"></i><a href="/post/164885512/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count" data-xid="/post/164885512/" itemprop="commentCount"></span></a><span class="article-meta-label"> 条评论</span></span></div><div class="content">知识体系结构 介绍 容器，就是可以容纳其他Java对象的对象。*Java Collections Framework(JCF)*为Java开发者提供了通用的容器，其始于JDK 1.2，优点是: 降低编程难度 提高程序性能 提高API间的互操作性 降低学习难度 降低设计和实现相关API的难度 增加程序的重用性 Java容器里只能放对象，对于基本类型(int, long, float, double等)，需要将其包装成对象类型后(Integer, Long, Float, Double等)才能放到容器里。很多时候拆包装和解包装能够自动完成。这虽然会导致额外的性能和空间开销，但简化了设计和编程。 Collection 容器主要包括 Collection 和 Map 两种，Collection 存储着对象的集合，而 Map 存储着键值对(两个对象)的映射表。 Set TreeSet 基于红黑树实现，支持有序性操作，例如根据一个范围查找元素的操作。但是查找效率不如 HashSet，HashSet 查找的时间复杂度为 O(1)，TreeSet 则为 O(logN)。 HashSet 基于 ...</div></div></div><nav id="pagination"><div class="pagination"><span class="page-number current">1</span><a class="page-number" href="/page/2/#content-inner">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/#content-inner">5</a><a class="extend next" rel="next" href="/page/2/#content-inner"><i class="fas fa-chevron-right fa-fw"></i></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.png" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">陈建源</div><div class="author-info__description">过着平凡的生活，享受着简单的人生</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">55</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a></div><div class="card-info-data-item is-center"><a href="/m/"><div class="headline">分类</div><div class="length-num">11</div></a></div></div><a class="button--animated" id="card-info-btn" href="https://github.com/yuanjianchen"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/yuanjianchen" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:jianyuan.c@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="tencent://message/?uin=1752133445&amp;Site=&amp;Menu=yes" target="_blank" title="QQ"><i class="fab fa-qq"></i></a><a class="social-icon" href="/img/wechat.jpg" target="_blank" title="WeChat"><i class="fab fa-weixin"></i></a></div></div><div class="sticky_layout"><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/165052629/" title="深入理解Volatile">深入理解Volatile</a><time datetime="2022-04-21T07:31:28.000Z" title="发表于 2022-04-21 15:31:28">2022-04-21</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/165052618/" title="并发理论接触：内存屏障">并发理论接触：内存屏障</a><time datetime="2022-04-21T07:29:30.000Z" title="发表于 2022-04-21 15:29:30">2022-04-21</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/164995635/" title="并发理论基础：Java 内存模型JMM">并发理论基础：Java 内存模型JMM</a><time datetime="2022-04-14T17:12:29.000Z" title="发表于 2022-04-15 01:12:29">2022-04-15</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/164942290/" title="并发理论基础：指令重排序问题">并发理论基础：指令重排序问题</a><time datetime="2022-04-08T13:01:28.000Z" title="发表于 2022-04-08 21:01:28">2022-04-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/164926797/" title="并发理论基础：缓存可见性、MESI">并发理论基础：缓存可见性、MESI</a><time datetime="2022-04-06T17:59:31.000Z" title="发表于 2022-04-07 01:59:31">2022-04-07</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/164913260/" title="并发理论基础：原子性问题">并发理论基础：原子性问题</a><time datetime="2022-04-05T03:25:31.000Z" title="发表于 2022-04-05 11:25:31">2022-04-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/164912916/" title="并发理论基础：并发与并行">并发理论基础：并发与并行</a><time datetime="2022-04-05T03:25:31.000Z" title="发表于 2022-04-05 11:25:31">2022-04-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/164912852/" title="并发理论基础：并发问题产生的三大根源">并发理论基础：并发问题产生的三大根源</a><time datetime="2022-04-05T03:15:11.000Z" title="发表于 2022-04-05 11:15:11">2022-04-05</time></div></div></div></div><div class="card-widget card-tags"><div class="item-headline"><i class="fas fa-tags"></i><span>标签</span></div><div class="card-tag-cloud"><a href="/tags/maven/" style="font-size:1.36em;color:#b3a05d">maven</a><a href="/tags/idea/" style="font-size:1.19em;color:#6b624e">idea</a><a href="/tags/Java/" style="font-size:1.45em;color:#192b1a">Java</a><a href="/tags/Springboot/" style="font-size:1.15em;color:#0a2444">Springboot</a><a href="/tags/feign/" style="font-size:1.15em;color:#2db732">feign</a><a href="/tags/uml/" style="font-size:1.15em;color:#ac582c">uml</a><a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size:1.28em;color:#8793a7">设计模式</a><a href="/tags/C%E8%AF%AD%E8%A8%80/" style="font-size:1.41em;color:#886d01">C语言</a><a href="/tags/JVM/" style="font-size:1.24em;color:#47c283">JVM</a><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/" style="font-size:1.15em;color:#309342">计算机</a><a href="/tags/%E5%B9%B6%E5%8F%91/" style="font-size:1.32em;color:#3d8494">并发</a><a href="/tags/Java-%E9%9B%86%E5%90%88/" style="font-size:1.15em;color:#b87403">Java 集合</a><a href="/tags/MySQL/" style="font-size:1.15em;color:#aba26a">MySQL</a><a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size:1.15em;color:#31ac38">数据库</a><a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size:1.15em;color:#7c3c9c">数据结构</a></div></div><div class="card-widget card-archives"><div class="item-headline"><i class="fas fa-archive"></i><span>归档</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2022/04/"><span class="card-archive-list-date">四月 2022</span><span class="card-archive-list-count">12</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2021/12/"><span class="card-archive-list-date">十二月 2021</span><span class="card-archive-list-count">16</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2020/09/"><span class="card-archive-list-date">九月 2020</span><span class="card-archive-list-count">1</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2020/08/"><span class="card-archive-list-date">八月 2020</span><span class="card-archive-list-count">26</span></a></li></ul></div><div class="card-widget card-webinfo"><div class="item-headline"><i class="fas fa-chart-line"></i><span>网站资讯</span></div><div class="webinfo"><div class="webinfo-item"><div class="item-name">文章数目 :</div><div class="item-count">55</div></div><div class="webinfo-item"><div class="item-name">已运行时间 :</div><div class="item-count" id="runtimeshow" data-publishdate="2020-07-29T16:00:00.000Z"></div></div><div class="webinfo-item"><div class="item-name">本站总字数 :</div><div class="item-count">137.4k</div></div><div class="webinfo-item"><div class="item-name">本站访客数 :</div><div class="item-count" id="busuanzi_value_site_uv"></div></div><div class="webinfo-item"><div class="item-name">本站总访问量 :</div><div class="item-count" id="busuanzi_value_site_pv"></div></div><div class="webinfo-item"><div class="item-name">最后更新时间 :</div><div class="item-count" id="last-push-date" data-lastpushdate="2022-04-21T08:52:15.600Z"></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By 陈建源</div><div class="framework-info"><span>框架 </span><a href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text"><span><a href="http://www.beian.miit.gov.cn"><img class="icp-icon" src="/img/icp.png"><span>备案号：京ICP备17031811号-1</span></a> | 本网站由<a href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral" target="_blank"><img src="/img/又拍云_logo6.png" class="youpai-logo"></a>提供CDN加速/云储存服务</span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div></div><hr><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>(() => {
  function loadValine () {
    function initValine () {
      let initData = {
        el: '#vcomment',
        appId: 'M1Fb2kAISrjFNkvAaWci9NrJ-gzGzoHsz',
        appKey: 'q4sEVnF9Minjscuva66D0auY',
      }
      
      const valine = new Valine(initData)
    }

    if (typeof Valine === 'function') initValine() 
    else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
  }

  window.pjax ? loadValine() : window.addEventListener('load', loadValine)
})()</script></div><script defer id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>
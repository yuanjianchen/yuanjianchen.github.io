<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>从源码角度理解类加载器 | 陈建源的博客</title><meta name="keywords" content="jvm,类加载,类加载器,ClassLoader,AppClassLoader"><meta name="author" content="陈建源"><meta name="copyright" content="陈建源"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="类加载器分为 BootstrapClassLoader,ExtClassLoader,AppClassLoader以及自定义类加载器,通过双亲委派模型进行工作,保证了类加载的正确运行."><meta property="og:type" content="article"><meta property="og:title" content="从源码角度理解类加载器"><meta property="og:url" content="https://www.techstack.tech/post/164885504/"><meta property="og:site_name" content="陈建源的博客"><meta property="og:description" content="类加载器分为 BootstrapClassLoader,ExtClassLoader,AppClassLoader以及自定义类加载器,通过双亲委派模型进行工作,保证了类加载的正确运行."><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/images/2020/08/20/image-20200820173314832.png"><meta property="article:published_time" content="2020-08-21T12:55:17.000Z"><meta property="article:modified_time" content="2022-04-21T08:08:26.727Z"><meta property="article:author" content="陈建源"><meta property="article:tag" content="Java"><meta property="article:tag" content="JVM"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/images/2020/08/20/image-20200820173314832.png"><link rel="shortcut icon" href="/img/avatar.png"><link rel="canonical" href="https://www.techstack.tech/post/164885504/"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":300},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: 陈建源","link":"链接: ","source":"来源: 陈建源的博客","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: true,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"从源码角度理解类加载器",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2022-04-21 16:08:26"}</script><noscript><style type="text/css">#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    })(window)</script><meta name="generator" content="Hexo 5.1.1"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.png" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">55</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/m/"><div class="headline">分类</div><div class="length-num">11</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa-solid fa-book"></i><span> 必修课</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/m/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%95%99%E7%A8%8B/"><span>数据结构和算法</span></a></li><li><a class="site-page child" href="/m/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%95%99%E7%A8%8B/"><span>计算机操作系统</span></a></li><li><a class="site-page child" href="/m/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%95%99%E7%A8%8B/"><span>计算机网络</span></a></li><li><a class="site-page child" href="/m/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%95%99%E7%A8%8B/"><span>计算机组成原理</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa-brands fa-java"></i><span> Java</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/m/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"><span>基础知识</span></a></li><li><a class="site-page child" href="/m/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"><span>集合框架</span></a></li><li><a class="site-page child" href="/m/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"><span>并发编程</span></a></li><li><a class="site-page child" href="/m/JVM/"><span>JVM</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa-solid fa-database"></i><span> 数据库</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/m/MySQL/"><span>MySQL</span></a></li><li><a class="site-page child" href="/m/Redis/"><span>Redis</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa-solid fa-code"></i><span> 源码框架</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/m/OpenFeign/"><span>OpenFeign</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa-solid fa-marker"></i><span> 设计与理论</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/m/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><i class="fa-fw fas fa-layer-group"></i><span> 设计模式</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa-solid fa-c"></i><span> 辅助语言</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/m/C%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E6%89%8B%E5%86%8C/"><span>C语言入门手册</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa-solid fa-jet-fighter-up"></i><span> 开发工具</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/m/Maven/"><span>Maven</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">陈建源的博客</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa-solid fa-book"></i><span> 必修课</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/m/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%95%99%E7%A8%8B/"><span>数据结构和算法</span></a></li><li><a class="site-page child" href="/m/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%95%99%E7%A8%8B/"><span>计算机操作系统</span></a></li><li><a class="site-page child" href="/m/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%95%99%E7%A8%8B/"><span>计算机网络</span></a></li><li><a class="site-page child" href="/m/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%95%99%E7%A8%8B/"><span>计算机组成原理</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa-brands fa-java"></i><span> Java</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/m/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"><span>基础知识</span></a></li><li><a class="site-page child" href="/m/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"><span>集合框架</span></a></li><li><a class="site-page child" href="/m/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"><span>并发编程</span></a></li><li><a class="site-page child" href="/m/JVM/"><span>JVM</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa-solid fa-database"></i><span> 数据库</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/m/MySQL/"><span>MySQL</span></a></li><li><a class="site-page child" href="/m/Redis/"><span>Redis</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa-solid fa-code"></i><span> 源码框架</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/m/OpenFeign/"><span>OpenFeign</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa-solid fa-marker"></i><span> 设计与理论</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/m/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><i class="fa-fw fas fa-layer-group"></i><span> 设计模式</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa-solid fa-c"></i><span> 辅助语言</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/m/C%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E6%89%8B%E5%86%8C/"><span>C语言入门手册</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa-solid fa-jet-fighter-up"></i><span> 开发工具</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/m/Maven/"><span>Maven</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">从源码角度理解类加载器</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-08-21T12:55:17.000Z" title="发表于 2020-08-21 20:55:17">2020-08-21</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-04-21T08:08:26.727Z" title="更新于 2022-04-21 16:08:26">2022-04-21</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/m/JVM/">JVM</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>23分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title="从源码角度理解类加载器"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div><article class="post-content" id="article-container"><p>虚拟机类加载机制就是把 Class 文件加载到内存，并对数据进行校验、解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型。一个类有虚拟机加载到内存中的流程包含了多个阶段，其中实现加载阶段中的通过一个类的全限定名来获取描述此类的二进制字节流的动作便是有类加载器来完成的。</p><p>一般来说、类的加载流程都有虚拟自主完成，开发人员不必关系其实现细节。但是如过如果遇到了需要与类加载器进行交互的情况，而对类加载器的机制又不是很了解的话，就很容易花大量的时间去调试 <code>ClassNotFoundException</code> 和 <code>NoClassDefFoundError</code> 等异常。同时随着类加载器在类层次划分、OSGi、热部署、代码加密等领域大放异彩，对于开发人员还是很有必要去掌握其中的原理的。</p><h2 id="类加载运行的基本流程">类加载运行的基本流程<a href="#类加载运行的基本流程"></a></h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> tech.stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> jianyuan.chen</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/8/20 15:51</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        System.out.println(<span class="string">"Hello world"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>对于一个 Java 程序的运行过程从整体上说可以分为两个步骤：</p><ol><li>使用javac 命令将<code>HelloWorld.java</code>源文件编译成<code>HelloWorld.class</code>文件。</li><li>java 命令运行<code>HelloWorld.class</code>文件。</li></ol><p>在运行 <code>java</code> 命令时，具体发生了什么，可以通过下图总结一下：</p><p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/images/2020/08/20/image-20200820173314832.png" alt="类加载流程"></p><h2 id="类加载器分类与结构">类加载器分类与结构<a href="#类加载器分类与结构"></a></h2><p>从上图能看出 Java 程序的入口为<code>sun.misc.Launcher</code>类，查看一下<code>Launcher</code>类的方法</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Launcher</span> </span>{	</span><br><span class="line">  	<span class="keyword">private</span> <span class="keyword">static</span> Launcher launcher = <span class="keyword">new</span> Launcher();</span><br><span class="line">		<span class="keyword">private</span> ClassLoader loader;</span><br><span class="line">		...</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Launcher <span class="title">getLauncher</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> launcher;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Launcher</span><span class="params">()</span> </span>{</span><br><span class="line">        Launcher.ExtClassLoader var1;</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            var1 = Launcher.ExtClassLoader.getExtClassLoader();</span><br><span class="line">        } <span class="keyword">catch</span> (IOException var10) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(<span class="string">"Could not create extension class loader"</span>, var10);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">this</span>.loader = Launcher.AppClassLoader.getAppClassLoader(var1);</span><br><span class="line">        } <span class="keyword">catch</span> (IOException var9) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(<span class="string">"Could not create application class loader"</span>, var9);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        Thread.currentThread().setContextClassLoader(<span class="keyword">this</span>.loader);</span><br><span class="line">        ....</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> ClassLoader <span class="title">getClassLoader</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.loader;</span><br><span class="line">    }</span><br><span class="line">  ...</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtClassLoader</span> <span class="keyword">extends</span> <span class="title">URLClassLoader</span> </span>{</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Launcher.ExtClassLoader instance;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> Launcher.<span class="function">ExtClassLoader <span class="title">getExtClassLoader</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>{</span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="keyword">null</span>) {</span><br><span class="line">                Class var0 = Launcher.ExtClassLoader.class;</span><br><span class="line">                <span class="keyword">synchronized</span>(Launcher.ExtClassLoader.class) {</span><br><span class="line">                    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) {</span><br><span class="line">                        instance = createExtClassLoader();</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        }</span><br><span class="line">      ...</span><br><span class="line">		}        </span><br><span class="line">		...</span><br><span class="line">		<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AppClassLoader</span> <span class="keyword">extends</span> <span class="title">URLClassLoader</span> </span>{</span><br><span class="line">        <span class="keyword">final</span> URLClassPath ucp = SharedSecrets.getJavaNetAccess().getURLClassPath(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ClassLoader <span class="title">getAppClassLoader</span><span class="params">(<span class="keyword">final</span> ClassLoader var0)</span> <span class="keyword">throws</span> IOException </span>{</span><br><span class="line">            <span class="keyword">final</span> String var1 = System.getProperty(<span class="string">"java.class.path"</span>);</span><br><span class="line">            <span class="keyword">final</span> File[] var2 = var1 == <span class="keyword">null</span> ? <span class="keyword">new</span> File[<span class="number">0</span>] : Launcher.getClassPath(var1);</span><br><span class="line">            <span class="keyword">return</span> (ClassLoader)AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Launcher.AppClassLoader&gt;() {</span><br><span class="line">                <span class="keyword">public</span> Launcher.<span class="function">AppClassLoader <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">                    URL[] var1x = var1 == <span class="keyword">null</span> ? <span class="keyword">new</span> URL[<span class="number">0</span>] : Launcher.pathToURLs(var2);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> Launcher.AppClassLoader(var1x, var0);</span><br><span class="line">                }</span><br><span class="line">            });</span><br><span class="line">        }</span><br><span class="line">      ...</span><br><span class="line">		} </span><br><span class="line">  ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>从 Launcher 入口可以看出在类加载过程中使用到<code>ExtClassLoader</code> 和 <code>AppClassLoader</code>两个系统类加载器，加上启动 Launcher 类使用的<code>BootStrapClassLoader</code>一共有三个系统类加载器。</p><blockquote><p>思维扩展：</p><p>Launcher.getLauncher()使用了饿汉单例模式创建。</p><p>ExtClassLoader.getExtClassLoader() 使用了懒汉双重校验单例模式。</p></blockquote><h3 id="BootStrapClassLoader">BootStrapClassLoader<a href="#BootStrapClassLoader"></a></h3><p>引导类加载器，通过 C++ 代码实现，不属于 Java 程序，负责加载支撑 JVM 运行的位于 <code>JAVA_HOME/lib</code>目录中或者被<code>-Xbootclasspath</code>参数所指定的路径中的类库，比如：rt.jar、charset.jar 等。引导类加载器的加载路径可以通过<code>System.getProperty("sun.boot.class.path");</code>。</p><h3 id="ExtClassLoader">ExtClassLoader<a href="#ExtClassLoader"></a></h3><p>扩展类加载器负责加载 <code>JAVA_HOME/ext</code>目录中或者被<code>java.ext.dir</code>系统变脸所指定的路径中的所有类库，扩展类加载器可以被直接使用。扩展类加载器的加载路径可以通过<code>System.getProperty("java.ext.dirs");</code>获取。</p><h3 id="AppClassLoader">AppClassLoader<a href="#AppClassLoader"></a></h3><p>应用程序类加载器，由于这个类加载器是 ClassLoader 中的 getSystemClassLoader() 方法的返回值。所以一般也称它为系统类加载器。它负责加载用户类路径(ClassPath)上指定的类库，这个类加载器也是可以被开发者直接使用的，如果应用程序中没有定义过自己的类加载器一般情况下这个就是程序中的默认类加载器。应用程序类加载器的加载路径可以通过<code>System.getProperty("java.class.path")</code>获取。</p><p>ExtClassLoad 和 AppClassLoader 都属于 Launcher 的静态内部类，同时也都是 ClassLoader 的子类。Launcher 在实例化的过程中，创建了 ExtClassLoader 和 AppClassLoader。<code>getClassLoader()</code>返回的是一个 AppClassLoader 的实例。通过Idea查看整个 ClassLoader 的体系结构如下，虚拟机启动只使用了 ExtClassLoader 和 AppClassLoader。</p><p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/images/2020/08/20/AppClassLoader.png" alt="AppClassLoader"></p><p>通过上文所述，运行一下代码：</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderPathTest</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        Arrays.stream(System.getProperty(<span class="string">"sun.boot.class.path"</span>).split(<span class="string">":"</span>)).forEach(System.out::println);</span><br><span class="line">        System.out.println(<span class="string">"------------------"</span>);</span><br><span class="line">        Arrays.stream(System.getProperty(<span class="string">"java.ext.dirs"</span>).split(<span class="string">":"</span>)).forEach(System.out::println);</span><br><span class="line">        System.out.println(<span class="string">"------------------"</span>);</span><br><span class="line">        Arrays.stream(System.getProperty(<span class="string">"java.class.path"</span>).split(<span class="string">":"</span>)).forEach(System.out::println);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_231</span>.jdk/Contents/Home/jre/lib/resources.jar</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_231</span>.jdk/Contents/Home/jre/lib/rt.jar</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_231</span>.jdk/Contents/Home/jre/lib/sunrsasign.jar</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_231</span>.jdk/Contents/Home/jre/lib/jsse.jar</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_231</span>.jdk/Contents/Home/jre/lib/jce.jar</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_231</span>.jdk/Contents/Home/jre/lib/charsets.jar</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_231</span>.jdk/Contents/Home/jre/lib/jfr.jar</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_231</span>.jdk/Contents/Home/jre/classes</span><br><span class="line">------------------</span><br><span class="line">/Users/chenjianyuan/Library/Java/Extensions</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_231</span>.jdk/Contents/Home/jre/lib/ext</span><br><span class="line">/Library/Java/Extensions</span><br><span class="line">/Network/Library/Java/Extensions</span><br><span class="line">/System/Library/Java/Extensions</span><br><span class="line">/usr/lib/java</span><br><span class="line">------------------</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_231</span>.jdk/Contents/Home/jre/lib/charsets.jar</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_231</span>.jdk/Contents/Home/jre/lib/deploy.jar</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_231</span>.jdk/Contents/Home/jre/lib/ext/cldrdata.jar</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_231</span>.jdk/Contents/Home/jre/lib/ext/dnsns.jar</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_231</span>.jdk/Contents/Home/jre/lib/ext/jaccess.jar</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_231</span>.jdk/Contents/Home/jre/lib/ext/jfxrt.jar</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_231</span>.jdk/Contents/Home/jre/lib/ext/localedata.jar</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_231</span>.jdk/Contents/Home/jre/lib/ext/nashorn.jar</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_231</span>.jdk/Contents/Home/jre/lib/ext/sunec.jar</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_231</span>.jdk/Contents/Home/jre/lib/ext/sunjce_provider.jar</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_231</span>.jdk/Contents/Home/jre/lib/ext/sunpkcs11.jar</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_231</span>.jdk/Contents/Home/jre/lib/ext/zipfs.jar</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_231</span>.jdk/Contents/Home/jre/lib/javaws.jar</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_231</span>.jdk/Contents/Home/jre/lib/jce.jar</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_231</span>.jdk/Contents/Home/jre/lib/jfr.jar</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_231</span>.jdk/Contents/Home/jre/lib/jfxswt.jar</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_231</span>.jdk/Contents/Home/jre/lib/jsse.jar</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_231</span>.jdk/Contents/Home/jre/lib/management-agent.jar</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_231</span>.jdk/Contents/Home/jre/lib/plugin.jar</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_231</span>.jdk/Contents/Home/jre/lib/resources.jar</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_231</span>.jdk/Contents/Home/jre/lib/rt.jar</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_231</span>.jdk/Contents/Home/lib/ant-javafx.jar</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_231</span>.jdk/Contents/Home/lib/dt.jar</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_231</span>.jdk/Contents/Home/lib/javafx-mx.jar</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_231</span>.jdk/Contents/Home/lib/jconsole.jar</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_231</span>.jdk/Contents/Home/lib/packager.jar</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_231</span>.jdk/Contents/Home/lib/sa-jdi.jar</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_231</span>.jdk/Contents/Home/lib/tools.jar</span><br><span class="line">/Users/chenjianyuan/IdeaProjects/course/target/classes</span><br><span class="line">/Applications/IntelliJ IDEA.app/Contents/lib/idea_rt.jar</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>观察上面输出内容发现一些本应该在 BootstrapClassLoader 和 ExtClassLoader 类加载器中加载的 jar 包也存在了 AppClassLoader 类加载器加载的路径下。这会不会造成类的重复加载呢，答案是不会的，这就涉及到了类加载器的双亲委派加载模型。</p><h3 id="JVM类加载机制">JVM类加载机制<a href="#JVM类加载机制"></a></h3><ul><li><p><strong>全盘负责</strong>：当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入</p></li><li><p><strong>父类委托</strong>：先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类</p></li><li><p><strong>缓存机制</strong>：缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。这就是为什么修改了Class后，必须重启JVM，程序的修改才会生效</p></li></ul><h2 id="双亲委派模型（Parents-Delegation-Model）">双亲委派模型（Parents Delegation Model）<a href="#双亲委派模型（Parents-Delegation-Model）"></a></h2><h3 id="何为双亲委派">何为双亲委派<a href="#何为双亲委派"></a></h3><p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/images/post/2020/08/image-20200820221249345.png" alt="双亲委派模型"></p><p>上图所示类加载器之间的层次关系就成为类加载器的双亲委派模型。</p><h3 id="类加载器之间结构和关系">类加载器之间结构和关系<a href="#类加载器之间结构和关系"></a></h3><p>在深入理解双亲委派模型之前先运行一段代码：</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderTest</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();</span><br><span class="line">        System.out.println(<span class="string">"system classLoader is "</span> + systemClassLoader);</span><br><span class="line">        ClassLoader systemClassLoaderParent = systemClassLoader.getParent();</span><br><span class="line">        System.out.println(<span class="string">"system classLoader parent is "</span> + systemClassLoaderParent);</span><br><span class="line">        ClassLoader systemClassLoaderParentParent = systemClassLoaderParent.getParent();</span><br><span class="line">        System.out.println(<span class="string">"system classLoader parent's parent is "</span> + systemClassLoaderParentParent);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">==============</span><br><span class="line">system classLoader is sun.misc.Launcher$AppClassLoader@18b4aac2</span><br><span class="line">system classLoader parent is sun.misc.Launcher$ExtClassLoader@61bbe9ba</span><br><span class="line">system classLoader parent<span class="string">'s parent is null</span></span><br></pre></td></tr></tbody></table></figure><p>从上面的代码可以看出类加载之间的关系，AppClassLoader 为系统类加载器，上层加载器为 ExtClassLoader, ExtClassLoader 上层类加载器为 null 即为 BootstrapClassLoader，此处也说明如果我们想让自定义加载的上层类加载器为 BootstrapClassLoader 类加载器的话，可以直接将其 parent 属性置为 <code>null</code>。</p><p>值得注意的是此处的 parent 不能理解为父类加载器，类加载器之间的关系不是通过继承来实现的，而都是使用组合关系来复用上层类加载器的代码。可以通过 AppClassLoader、ExtClassLoader 的 UML 类图查看一下之间的关系。</p><p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/images/post/2020/08/AppClassLoader.png" alt="ClassLoader"></p><p>AppClassLoader 和 ExtClassLoader 都继承了 URLClassLoader 最终继承了 ClassLoader 同时又依赖 ClassLoader即 AppClassLoader 依赖 ExtClassLoader。</p><h3 id="双亲委派模型工作过程">双亲委派模型工作过程<a href="#双亲委派模型工作过程"></a></h3><p>自定义类加载器在收到一个类加载请求是，它不会自己首先去加载这个类，而是委托给上层类加载器也就是应用程序类加载器去加载，同样在应用程序类加载器收到类加载的请求时也不会去首先加载这个类，而是委托上层即 ExtClassLoader 类加载器去加载，这样一直到委托到顶层 BootstrapClassLoader，在 BootstrapClassLoader 接收到类加载请求后，会在自己的搜索范围内搜索这个类，如果搜索不到则返回至下层类加载器，让下层类加载器去自己的搜索范围内去搜索此类，直至最底层类加载器。如果所有的加载器都没有搜索到此类则会抛出 <code>ClassNotFoundException</code>。</p><h3 id="双亲委派模型源码解析">双亲委派模型源码解析<a href="#双亲委派模型源码解析"></a></h3><p>在了解双亲委派模型运行机制之前要先熟悉 ClassLoader 类加载器的结构，其核心代码如下面所示：</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoader</span> </span>{</span><br><span class="line">  	<span class="comment">// 上层类加载器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ClassLoader parent;</span><br><span class="line">  	</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ClassLoader</span><span class="params">(Void unused, ClassLoader parent)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.parent = parent;</span><br><span class="line">        ...</span><br><span class="line">    }</span><br><span class="line">  	<span class="comment">// 构造方法 初始化上层类加载器</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">ClassLoader</span><span class="params">(ClassLoader parent)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>(checkCreateClassLoader(), parent);</span><br><span class="line">    }</span><br><span class="line">  	<span class="comment">// 默认上层类加载器为系统类加载器</span></span><br><span class="line">  	<span class="function"><span class="keyword">protected</span> <span class="title">ClassLoader</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>(checkCreateClassLoader(), getSystemClassLoader());</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 加载类方法 核心</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">        <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">synchronized</span> (getClassLoadingLock(name)) {</span><br><span class="line">            <span class="comment">// step1. 首先检查类是否已经被加载过</span></span><br><span class="line">            Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) {</span><br><span class="line">                <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    <span class="comment">// 被加载类如未被加载过，并且其上层类加载器不为空，委托上层类加载器进行加载。</span></span><br><span class="line">                    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) {</span><br><span class="line">                        c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                    } <span class="keyword">else</span> {</span><br><span class="line">                      <span class="comment">// 被加载类没有被加载过，并且此加载此类的类加载器没有上层类加载器，由 BootstapClassLoader 进行加载</span></span><br><span class="line">                        c = findBootstrapClassOrNull(name);</span><br><span class="line">                    }</span><br><span class="line">                } <span class="keyword">catch</span> (ClassNotFoundException e) { <span class="comment">// 此处的 ClassNotFoundException 为下面 findClass() 方法抛出，此处 catch 的为上层类加载器抛出的异常</span></span><br><span class="line">                    <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                    <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">                }</span><br><span class="line">						  <span class="comment">// 从最底层类加载器一直委托到 BootStrapClassLoader 如果 BootStrapClassLoader 类加载器没有加载此类为空，</span></span><br><span class="line">                <span class="comment">// 由 BootStrapClassLoader 类加载器下层寻找，找不到此类抛出 ClassNotFoundException 并由 </span></span><br><span class="line">                <span class="comment">// BootStrapClassLoader 下层的下层捕获异常，一直到最底层找不到则程序抛出 ClassNotFoundException</span></span><br><span class="line">                <span class="keyword">if</span> (c == <span class="keyword">null</span>) {</span><br><span class="line">                    <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                    <span class="comment">// to find the class.</span></span><br><span class="line">                    <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                    <span class="comment">// 根据类的全限定名在当前类加载器搜索范围内查询需要被加载的类，如果找不到则</span></span><br><span class="line">         					<span class="comment">// 抛出 ClassNotFoundException</span></span><br><span class="line">                    c = findClass(name);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                    sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (resolve) {</span><br><span class="line">                resolveClass(c);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</span><br><span class="line">    }</span><br><span class="line">  </span><br><span class="line">   <span class="keyword">protected</span> <span class="keyword">final</span> Class&lt;?&gt; findLoadedClass(String name) {</span><br><span class="line">        <span class="keyword">if</span> (!checkName(name))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> findLoadedClass0(name);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">final</span> Class&lt;?&gt; findLoadedClass0(String name);</span><br><span class="line">  </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>ClassLoader 类加载器整体结构如上所示，其加载类的核心方法为 loadClass 和 findClass，findClass 由其子类 URLClassLoader 重载实现。并由 URLClassLoader 子类 AppClassLoader 和 ExtClassLoader 继承获得实现。</p><p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/images/post/2020/08/Launcher.png" alt="Launcher"></p><p>结合源码对 <code>Hello World</code> 程序运行进行分析：</p><ol><li><p>BootStrapClassLoader 在启动加载Launcher,并通过 getLauncher 获取 Launcher ①</p></li><li><p>Launcher 在 new 时会调用 ExtClassLoader.getExtClassLoader（②）创建 ExtClassLoader（③），查看 ExtClassLoader 创建方法</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ExtClassLoader</span><span class="params">(File[] var1)</span> <span class="keyword">throws</span> IOException </span>{</span><br><span class="line">        <span class="keyword">super</span>(getExtURLs(var1), (ClassLoader)<span class="keyword">null</span>, Launcher.factory);</span><br><span class="line">        SharedSecrets.getJavaNetAccess().getURLClassPath(<span class="keyword">this</span>).initLookupCache(<span class="keyword">this</span>);</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><p>可以看出 ExtClassLoader 初始化其 parent 属性为 null，根据 ClassLoader的 loadClass 方法即可知 ExtClassLoadClass 类加载器会委托 BootstrapClassLoader 类加载器进行类加载。在 ExtClassLoader 类加载器创建创完成后，会创建 AppClassLoader, 并且把已经创建的 ExtClassLoader 类加载赋值给 AppClassLoader 类加载器的 parent 属性（④）。最后由 AppClassLoader 创建实例并返回（⑤）赋值给 Luancher 类的 loader 属性(④)。</p></li><li><p>由 loader(AppClassLoader) 调用 loaderClass 方法加载<code>tech.stack.HelloWorld</code>。</p><ol><li>从 LoadedClass 缓存中查询 <code>tech.stack.HelloWorld</code> 类，此处为 Native 方法由虚拟机底层实现。</li><li>此处为<code>tech.stack.HelloWorld</code>首次加载，并不会在 loadedClass 缓存中查到 Class<helloworld>对象</helloworld></li><li>判断 AppClassLoader 的 parent 是否为空，此处AppClassLoader.parent 为 extClassLoader加载器。</li><li>委托由 extClassLoader 类加载器加载 <code>tech.stack.HelloWorld</code> 类。</li><li>extClassLoader 同样进行 3.1、3.2步骤。</li><li>判断 extClassLoader 的 parent 对象是否为空，由 2 步骤可知 extClassLoader.parent 为 null。</li><li>委托由 BootstrapClassLoader 尝试加载<code>tech.stack.HelloWorld</code>，由于 BootstrapClassLoader 扫面范围内不存在<code>tech.stack.HelloWorld</code>类，因此返回 null。</li><li>Class<helloworld>对象为 null，则由 extClassLoader 通过在 URLClassLoader 类加载器继承到的 findClass 方法在 extClassLoader 搜索范围内查询<code>tech.stack.HelloWorld</code>类。</helloworld></li><li>在 extClassLoader 搜索范围内找不到<code>tech.stack.HelloWorld</code>类，抛出 <code>ClassNotFoundException</code>。</li><li><code>ClasseException</code>由 appClassLoader 捕获处理，然后在 AppClassLoader 搜索范围内查询<code>tech.stack.HelloWorld</code>类。</li><li>在 appClassLoader 搜索范围内可以找到<code>tech.stack.HelloWorld</code>类，将 Class<helloworld>对象返回，并判断是否需要解析。</helloworld></li><li>返回 Class<helloworld>对象。</helloworld></li></ol></li></ol><p>以上就是<code>tech.stack.HelloWorld</code> 通过双亲委派模型加载的整个流程。</p><blockquote><p>思维扩展：</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (getClassLoadingLock(name)){</span><br><span class="line">  ...</span><br><span class="line">} </span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getClassLoadingLock</span><span class="params">(String className)</span> </span>{</span><br><span class="line">        Object lock = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">if</span> (parallelLockMap != <span class="keyword">null</span>) {</span><br><span class="line">            Object newLock = <span class="keyword">new</span> Object();</span><br><span class="line">            lock = parallelLockMap.putIfAbsent(className, newLock);</span><br><span class="line">            <span class="keyword">if</span> (lock == <span class="keyword">null</span>) {</span><br><span class="line">                lock = newLock;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> lock;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>synchronized 保证了类加载器在加载类的过程中是线程安全的。保证了类加载过程中初始化阶段只会发生一次。同时在也是单例模式内部静态类这种写法能保证线程安全的基础。</p></blockquote><p>实现双亲委派的代码都集中在 loadClass() 方法之中，总结来说 loadClass 的逻辑就是：先检查类是否已经被加载过，若没有加载则调用上层加载器的 loadClass() 方法，若上层类加载器为空则默认使用启动类加载器。如果上层类加载器加载失败，抛出 ClassNotFoundException异常后，在调用自己的 findClass() 方法进行加载。</p><h3 id="为什么设计双亲委派机制">为什么设计双亲委派机制<a href="#为什么设计双亲委派机制"></a></h3><ul><li>沙箱安全机制：可以防止核心 API 库被随意篡改。例如自己写的 java.lang.String.class 类就不会被加载。</li><li>避免类的重复加载：当上层类加载器已经加载了该类时，就没有必要在由下层类加载器加载一遍，保证了类的唯一性。</li></ul><p>在程序中编写如下代码：</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        System.out.println(<span class="string">"custom String Class"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">======</span><br><span class="line">错误: 在类 java.lang.String 中找不到 main 方法, 请将 main 方法定义为:</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">否则 JavaFX 应用程序类必须扩展javafx.application.Application</span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></tbody></table></figure><p>在项目中新建模块<code>loader-test</code> 并且创建<code>tech.stack.HelloWorld</code>之后将模块打包放入<code>JAVA_HOME/ext</code>目录下面，运行下面代码：</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        System.out.println(HelloWorld.class.getClassLoader());</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>上面代码输出<code>sun.misc.Launcher$ExtClassLoader@266474c2</code>说明 HelloWorld类是有 ExtClassLoader 类加载器进行加载的而不是有 AppClassLoader 进行加载。如果继续放到<code>JAVA_HOME/lib</code>目录下面，再次运行上面的代码，得到输出：<code>sun.misc.Launcher$ExtClassLoader@5e481248</code>，结果并没有改变，这其实和前面讲的双亲委派机制并不矛盾。虚拟机出于安全等因素考虑，不会加载&lt;JAVA_HOME&gt;/lib目录下存在的陌生类。换句话说，虚拟机只加载&lt;JAVA_HOME&gt;/lib目录下它可以识别的类。因此，开发者通过将要加载的非JDK自身的类放置到此目录下期待启动类加载器加载是不可能的。但是如果在运行时添加jvm 参数<code>-Xbootclasspath/a:/Users/chenjianyuan/IdeaProjects/course/loader-test/target/loader-test.jar</code> 输出的结果则为 <code>null</code> ，就变成了 BootstrapClassLoader 类加载器加载。</p><h2 id="Java-程序动态扩展方式">Java 程序动态扩展方式<a href="#Java-程序动态扩展方式"></a></h2><p>类加载方式有三种：</p><ul><li>命令行启动应用时候由JVM初始化加载</li><li>通过Class.forName()方法动态加载</li><li>通过ClassLoader.loadClass()方法动态加载</li></ul><p>Java的连接模型允许用户运行时扩展引用程序，既可以通过当前虚拟机中预定义的加载器加载编译时已知的类或者接口，又允许用户自行定义类装载器，在运行时动态扩展用户的程序。通过用户自定义的类装载器，你的程序可以加载在编译时并不知道或者尚未存在的类或者接口，并动态连接它们并进行有选择的解析。运行时动态扩展java应用程序有如下两个途径：</p><h4 id="反射-调用java-lang-Class-forName-…-加载类">反射 (调用java.lang.Class.forName(…)加载类)<a href="#反射-调用java-lang-Class-forName-…-加载类"></a></h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; forName(String className)</span><br><span class="line">               <span class="keyword">throws</span> ClassNotFoundException {</span><br><span class="line">       Class&lt;?&gt; caller = Reflection.getCallerClass();</span><br><span class="line">       <span class="keyword">return</span> forName0(className, <span class="keyword">true</span>, ClassLoader.getClassLoader(caller), caller);</span><br><span class="line">   }</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; forName(String name, <span class="keyword">boolean</span> initialize,</span><br><span class="line">                                  ClassLoader loader)</span><br><span class="line">       <span class="keyword">throws</span> ClassNotFoundException{</span><br><span class="line">       </span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure><p>这里的initialize参数是很重要的，它表示在加载同时是否完成初始化的工作（说明：单参数版本的forName方法默认是完成初始化的）。有些场景下需要将initialize设置为true来强制加载同时完成初始化，我们在程序中自己调用方法时一般都会直接初始化，典型的就是加载数据库驱动问题。因为JDBC驱动程序只有被注册后才能被应用程序使用，这就要求驱动程序类必须被初始化，而不单单被加载。</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 加载并实例化JDBC驱动类</span></span><br><span class="line">Class.forName(driver);</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// JDBC驱动类的实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Driver</span> <span class="keyword">extends</span> <span class="title">NonRegisteringDriver</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">sql</span>.<span class="title">Driver</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Driver</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>{</span><br><span class="line">    }</span><br><span class="line">	<span class="comment">// 将initialize设置为true来强制加载同时完成初始化，实现驱动注册</span></span><br><span class="line">    <span class="keyword">static</span> {</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            DriverManager.registerDriver(<span class="keyword">new</span> Driver());</span><br><span class="line">        } <span class="keyword">catch</span> (SQLException var1) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Can\'t register driver!"</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}	</span><br></pre></td></tr></tbody></table></figure><h4 id="用户自定义类加载器">用户自定义类加载器<a href="#用户自定义类加载器"></a></h4><p>通过前面的分析，我们可以看出，除了和本地实现密切相关的启动类加载器之外，包括扩展类加载器和系统类加载器在内的所有其他类加载器我们都可以当做自定义类加载器来对待，唯一区别是是否被虚拟机默认使用。</p><h3 id="实现自定义类加载器">实现自定义类加载器<a href="#实现自定义类加载器"></a></h3><p>自定义类加载器只需要继承 java.lang.ClassLoader 类，该类有两个核心方法，一个是 loadClass()，实现了双亲委派机制，还有一个就是 findClass()，默认实现的是空方法，所以实现自定义类加载器主要是重写 fidClass 方法。</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String classPath;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClassLoader</span><span class="params">(String classPath)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.classPath = classPath;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException {</span><br><span class="line">        String fileName = name.replace(<span class="string">"."</span>, <span class="string">"/"</span>);</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            FileInputStream fin = <span class="keyword">new</span> FileInputStream(classPath + <span class="string">"/"</span> + fileName + <span class="string">".class"</span>);</span><br><span class="line">            <span class="keyword">int</span> available = fin.available();</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[available];</span><br><span class="line">            fin.read(bytes);</span><br><span class="line">            fin.close();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.defineClass(name, bytes, <span class="number">0</span>, bytes.length);</span><br><span class="line">        } <span class="keyword">catch</span> (Exception ignore) {</span><br><span class="line">            <span class="comment">// throw the end</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">//  将 tech.stack.HelloWorld.class copy 到 /Users/chenjianyuan/Documents 目录下面</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        MyClassLoader classLoader = <span class="keyword">new</span> MyClassLoader(<span class="string">"/Users/chenjianyuan/Documents"</span>);</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            Class&lt;?&gt; aClass = classLoader.loadClass(<span class="string">"tech.stack.HelloWorld"</span>);</span><br><span class="line">            System.out.println(aClass);</span><br><span class="line">            System.out.println(aClass.getClassLoader());</span><br><span class="line">        } <span class="keyword">catch</span> (ClassNotFoundException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// class tech.stack.HelloWorld</span></span><br><span class="line"><span class="comment">// tech.stack.classload.MyClassLoader@7b3300e5</span></span><br></pre></td></tr></tbody></table></figure><p>只要重写 findClass 方法，能获取到可以被虚拟机加载的.class 文件流就可以。因此可以自定义文件流的来源，譬如文件类加载器、网络类加载器、数据库类加载器等等。关于 defineClass() 就是类加载过程中其他验证、准备、解析、初始化等阶段。</p><h3 id="打破双亲委派模型">打破双亲委派模型<a href="#打破双亲委派模型"></a></h3><h4 id="实现自定义加载器打破双亲委派模型">实现自定义加载器打破双亲委派模型<a href="#实现自定义加载器打破双亲委派模型"></a></h4><p>上文分析出 ClassLoader 类加载器的 loadClass() 方法是实现双亲委派模型的关键，因此要实现自定义加载器打破双亲委派模型，重写 loadClass() 方法则为关键的步骤,还是上面的代码，不同的是在项目中添加<code>tech.stack.HelloWorld</code>类型，如下所示：</p><p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/images/post/2020/08/image-20200821193934585.png" alt="HelloWorld"></p><p>再次运行查看输出日志：</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">tech</span>.<span class="title">stack</span>.<span class="title">HelloWorld</span></span></span><br><span class="line"><span class="class"><span class="title">sun</span>.<span class="title">misc</span>.<span class="title">Launcher</span>$<span class="title">AppClassLoader</span>@18<span class="title">b4aac2</span></span></span><br></pre></td></tr></tbody></table></figure><p>发现由于双亲委派模型，tech.stack.HelloWorld 是由 AppClassLoader 类加载器进行加载的。修改一下MyClassLoader 代码来打破双亲委派模型：</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String classPath;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClassLoader</span><span class="params">(String classPath)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.classPath = classPath;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve) <span class="keyword">throws</span> ClassNotFoundException {</span><br><span class="line">        <span class="keyword">synchronized</span> (getClassLoadingLock(name)) {</span><br><span class="line">            <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">            Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) {</span><br><span class="line">                <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">                <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                <span class="comment">// to find the class.</span></span><br><span class="line">                <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">              <span class="comment">// 此处需要进行判断  非自定义的类比如一些核心的类库（Object）还是需要让上层类加载器去加载</span></span><br><span class="line">                <span class="keyword">if</span> (!name.startsWith(<span class="string">"tech.stack"</span>)) { </span><br><span class="line">                    c = <span class="keyword">this</span>.getParent().loadClass(name);</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    c = findClass(name);</span><br><span class="line">                }</span><br><span class="line">                <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (resolve) {</span><br><span class="line">                resolveClass(c);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException {</span><br><span class="line">        String fileName = name.replace(<span class="string">"."</span>, <span class="string">"/"</span>);</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            FileInputStream fin = <span class="keyword">new</span> FileInputStream(classPath + <span class="string">"/"</span> + fileName + <span class="string">".class"</span>);</span><br><span class="line">            <span class="keyword">int</span> available = fin.available();</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[available];</span><br><span class="line">            fin.read(bytes);</span><br><span class="line">            fin.close();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.defineClass(name, bytes, <span class="number">0</span>, bytes.length);</span><br><span class="line">        } <span class="keyword">catch</span> (Exception ignore) {</span><br><span class="line">            <span class="comment">// throw the end</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        MyClassLoader classLoader = <span class="keyword">new</span> MyClassLoader(<span class="string">"/Users/chenjianyuan/Documents"</span>);</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            Class&lt;?&gt; aClass = classLoader.loadClass(<span class="string">"tech.stack.HelloWorld"</span>);</span><br><span class="line">            System.out.println(aClass);</span><br><span class="line">            System.out.println(aClass.getClassLoader());</span><br><span class="line">            Method sayHello = aClass.getMethod(<span class="string">"sayHello"</span>, <span class="keyword">null</span>);</span><br><span class="line">            sayHello.invoke(aClass.newInstance(), <span class="keyword">null</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// class tech.stack.HelloWorld</span></span><br><span class="line"><span class="comment">// tech.stack.classload.MyClassLoader@610455d6</span></span><br><span class="line"><span class="comment">// Hello world!</span></span><br></pre></td></tr></tbody></table></figure><p>此处只是简单的一个实现，不同的业务模型实现的模式不同，要根据实际问题具体分析。</p><blockquote><p>思维扩展</p><p>判断两个类是否相等的前提是这两个类是同一个类加载器加载的。如下代码：</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        MyClassLoader classLoader = <span class="keyword">new</span> MyClassLoader(<span class="string">"/Users/chenjianyuan/Documents"</span>);</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            Class&lt;?&gt; aClass = classLoader.loadClass(<span class="string">"tech.stack.HelloWorld"</span>);</span><br><span class="line">            System.out.println(aClass.newInstance() <span class="keyword">instanceof</span> HelloWorld);</span><br><span class="line">            Class&lt;?&gt; bClass = ClassLoader.getSystemClassLoader().loadClass(<span class="string">"tech.stack.HelloWorld"</span>);</span><br><span class="line">            System.out.println(bClass.newInstance() <span class="keyword">instanceof</span> HelloWorld);</span><br><span class="line">            System.out.println(aClass.equals(bClass));</span><br><span class="line">            System.out.println(bClass.equals(HelloWorld.class));</span><br><span class="line">        } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 输出结果为</span></span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></tbody></table></figure><p>这里所指的“相等”，包括代表类的Class对象的equals()方法、isAssignableFrom()方法、isInstance()方法的返回结果，也包括使用instanceof关键字做对象所属关系判定等情况。</p></blockquote><h4 id="为什么要打破双亲委派模型">为什么要打破双亲委派模型<a href="#为什么要打破双亲委派模型"></a></h4><p>过双亲委派模型并不是一个强制性的约束模型，而是Java设计者推荐给开发者的类加载器实现方式。虽然双亲委派模型很好的保证了类库的安全和统一，但是一些情况下，这也会成为一些弊端：</p><ul><li>在核心底层代码需要调用上层用户代码，典型的便是 JNDI 服务，它的代码由启动类加载器去加载（rt.jar），但JNDI的目的就是对资源进行集中管理和查找，它需要调用由独立厂商实现并部署在应用程序的ClassPath下的JNDI接口提供者（SPI,Service Provider Interface）的代码。</li><li>程序追求动态性。比如代码热替换（HotSwap）、模块热部署（Hot Deployment）等。</li><li>为了保证环境隔离与资源共享。例如 Tomcat隔离多个 webApp jar 包冲突问题、Spring 读取Tomcat 环境中共享资源。</li></ul><script>document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });</script></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">陈建源</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://www.techstack.tech/post/164885504/">https://www.techstack.tech/post/164885504/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://www.techstack.tech" target="_blank">陈建源的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a><a class="post-meta__tags" href="/tags/JVM/">JVM</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/images/2020/08/20/image-20200820173314832.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/reward/wechat.jpeg" target="_blank"><img class="post-qr-code-img" src="/img/reward/wechat.jpeg" alt="wechat"></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/reward/alipay.jpeg" target="_blank"><img class="post-qr-code-img" src="/img/reward/alipay.jpeg" alt="alipay"></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/post/164885507/"><img class="prev-cover" src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/images/2020/09/07/image-20200907160940185.png" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">对象的创建与死亡以及内存分配、回收机制</div></div></a></div><div class="next-post pull-right"><a href="/post/164885659/"><img class="next-cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Feign Api返回值为void时获取 Response信息</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/post/159683533/" title="JVM内存结构"><img class="cover" src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/images/2020/08/08/JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-08-08</div><div class="title">JVM内存结构</div></div></a></div><div><a href="/post/164885506/" title="字节码文件结构详解"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-08-10</div><div class="title">字节码文件结构详解</div></div></a></div><div><a href="/post/164885508/" title="类加载过程"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-08-14</div><div class="title">类加载过程</div></div></a></div><div><a href="/post/164885507/" title="对象的创建与死亡以及内存分配、回收机制"><img class="cover" src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/images/2020/09/07/image-20200907160940185.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-09-09</div><div class="title">对象的创建与死亡以及内存分配、回收机制</div></div></a></div><div><a href="/post/164885659/" title="Feign Api返回值为void时获取 Response信息"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-08-17</div><div class="title">Feign Api返回值为void时获取 Response信息</div></div></a></div><div><a href="/post/164885509/" title="原码、补码、反码"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-08-03</div><div class="title">原码、补码、反码</div></div></a></div></div></div><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.png" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">陈建源</div><div class="author-info__description">过着平凡的生活，享受着简单的人生</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">55</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a></div><div class="card-info-data-item is-center"><a href="/m/"><div class="headline">分类</div><div class="length-num">11</div></a></div></div><a class="button--animated" id="card-info-btn" href="https://github.com/yuanjianchen"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/yuanjianchen" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:jianyuan.c@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="tencent://message/?uin=1752133445&amp;Site=&amp;Menu=yes" target="_blank" title="QQ"><i class="fab fa-qq"></i></a><a class="social-icon" href="/img/wechat.jpg" target="_blank" title="WeChat"><i class="fab fa-weixin"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%90%E8%A1%8C%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B"><span class="toc-text">类加载运行的基本流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%88%86%E7%B1%BB%E4%B8%8E%E7%BB%93%E6%9E%84"><span class="toc-text">类加载器分类与结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#BootStrapClassLoader"><span class="toc-text">BootStrapClassLoader</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ExtClassLoader"><span class="toc-text">ExtClassLoader</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AppClassLoader"><span class="toc-text">AppClassLoader</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6"><span class="toc-text">JVM类加载机制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B%EF%BC%88Parents-Delegation-Model%EF%BC%89"><span class="toc-text">双亲委派模型（Parents Delegation Model）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%95%E4%B8%BA%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE"><span class="toc-text">何为双亲委派</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E4%B9%8B%E9%97%B4%E7%BB%93%E6%9E%84%E5%92%8C%E5%85%B3%E7%B3%BB"><span class="toc-text">类加载器之间结构和关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B"><span class="toc-text">双亲委派模型工作过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90"><span class="toc-text">双亲委派模型源码解析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AE%BE%E8%AE%A1%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6"><span class="toc-text">为什么设计双亲委派机制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-%E7%A8%8B%E5%BA%8F%E5%8A%A8%E6%80%81%E6%89%A9%E5%B1%95%E6%96%B9%E5%BC%8F"><span class="toc-text">Java 程序动态扩展方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84-%E8%B0%83%E7%94%A8java-lang-Class-forName-%E2%80%A6-%E5%8A%A0%E8%BD%BD%E7%B1%BB"><span class="toc-text">反射 (调用java.lang.Class.forName(…)加载类)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-text">用户自定义类加载器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-text">实现自定义类加载器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%93%E7%A0%B4%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B"><span class="toc-text">打破双亲委派模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8A%A0%E8%BD%BD%E5%99%A8%E6%89%93%E7%A0%B4%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B"><span class="toc-text">实现自定义加载器打破双亲委派模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%89%93%E7%A0%B4%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B"><span class="toc-text">为什么要打破双亲委派模型</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/165052629/" title="深入理解Volatile">深入理解Volatile</a><time datetime="2022-04-21T07:31:28.000Z" title="发表于 2022-04-21 15:31:28">2022-04-21</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/165052618/" title="并发理论接触：内存屏障">并发理论接触：内存屏障</a><time datetime="2022-04-21T07:29:30.000Z" title="发表于 2022-04-21 15:29:30">2022-04-21</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/164995635/" title="并发理论基础：Java 内存模型JMM">并发理论基础：Java 内存模型JMM</a><time datetime="2022-04-14T17:12:29.000Z" title="发表于 2022-04-15 01:12:29">2022-04-15</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/164942290/" title="并发理论基础：指令重排序问题">并发理论基础：指令重排序问题</a><time datetime="2022-04-08T13:01:28.000Z" title="发表于 2022-04-08 21:01:28">2022-04-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/164926797/" title="并发理论基础：缓存可见性、MESI">并发理论基础：缓存可见性、MESI</a><time datetime="2022-04-06T17:59:31.000Z" title="发表于 2022-04-07 01:59:31">2022-04-07</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/164913260/" title="并发理论基础：原子性问题">并发理论基础：原子性问题</a><time datetime="2022-04-05T03:25:31.000Z" title="发表于 2022-04-05 11:25:31">2022-04-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/164912916/" title="并发理论基础：并发与并行">并发理论基础：并发与并行</a><time datetime="2022-04-05T03:25:31.000Z" title="发表于 2022-04-05 11:25:31">2022-04-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/164912852/" title="并发理论基础：并发问题产生的三大根源">并发理论基础：并发问题产生的三大根源</a><time datetime="2022-04-05T03:15:11.000Z" title="发表于 2022-04-05 11:15:11">2022-04-05</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By 陈建源</div><div class="framework-info"><span>框架 </span><a href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text"><span><a href="http://www.beian.miit.gov.cn"><img class="icp-icon" src="/img/icp.png"><span>备案号：京ICP备17031811号-1</span></a> | 本网站由<a href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral" target="_blank"><img src="/img/又拍云_logo6.png" class="youpai-logo"></a>提供CDN加速/云储存服务</span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div></div><hr><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'M1Fb2kAISrjFNkvAaWci9NrJ-gzGzoHsz',
      appKey: 'q4sEVnF9Minjscuva66D0auY',
      placeholder: 'Please leave your footprints',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'zh-CN',
      recordIP: true,
      serverURLs: 'https://m1fb2kai.lc-cn-n1-shared.com',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: true,
      path: window.location.pathname,
      requiredFields: ["nick,mail"],
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script defer id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>
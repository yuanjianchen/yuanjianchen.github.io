<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>类加载过程 | 陈建源的博客</title><meta name="keywords" content="jvm,类加载,类加载过程,类的生命周期,加载,验证,准备,接卸,初始化"><meta name="author" content="陈建源"><meta name="copyright" content="陈建源"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="类从被加载到虚拟机内容中开始，到卸载出内存为止，它的整个生命周期包括加载、验证、准备、解析、初始化、使用和卸载 7 个阶段"><meta property="og:type" content="article"><meta property="og:title" content="类加载过程"><meta property="og:url" content="https://www.techstack.tech/post/164885508/"><meta property="og:site_name" content="陈建源的博客"><meta property="og:description" content="类从被加载到虚拟机内容中开始，到卸载出内存为止，它的整个生命周期包括加载、验证、准备、解析、初始化、使用和卸载 7 个阶段"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://www.techstack.tech/img/avatar.png"><meta property="article:published_time" content="2020-08-13T20:55:17.000Z"><meta property="article:modified_time" content="2022-04-09T11:05:15.870Z"><meta property="article:author" content="陈建源"><meta property="article:tag" content="Java"><meta property="article:tag" content="JVM"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://www.techstack.tech/img/avatar.png"><link rel="shortcut icon" href="/img/avatar.png"><link rel="canonical" href="https://www.techstack.tech/post/164885508/"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":300},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: 陈建源","link":"链接: ","source":"来源: 陈建源的博客","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: true,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"类加载过程",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2022-04-09 19:05:15"}</script><noscript><style type="text/css">#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    })(window)</script><meta name="generator" content="Hexo 5.1.1"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.png" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">53</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/m/"><div class="headline">分类</div><div class="length-num">11</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa-solid fa-book"></i><span> 必修课</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/m/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%95%99%E7%A8%8B/"><span>数据结构和算法</span></a></li><li><a class="site-page child" href="/m/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%95%99%E7%A8%8B/"><span>计算机操作系统</span></a></li><li><a class="site-page child" href="/m/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%95%99%E7%A8%8B/"><span>计算机网络</span></a></li><li><a class="site-page child" href="/m/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%95%99%E7%A8%8B/"><span>计算机组成原理</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa-brands fa-java"></i><span> Java</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/m/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"><span>基础知识</span></a></li><li><a class="site-page child" href="/m/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"><span>集合框架</span></a></li><li><a class="site-page child" href="/m/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"><span>并发编程</span></a></li><li><a class="site-page child" href="/m/JVM/"><span>JVM</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa-solid fa-database"></i><span> 数据库</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/m/MySQL/"><span>MySQL</span></a></li><li><a class="site-page child" href="/m/Redis/"><span>Redis</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa-solid fa-code"></i><span> 源码框架</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/m/OpenFeign/"><span>OpenFeign</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa-solid fa-marker"></i><span> 设计与理论</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/m/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><i class="fa-fw fas fa-layer-group"></i><span> 设计模式</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa-solid fa-c"></i><span> 辅助语言</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/m/C%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E6%89%8B%E5%86%8C/"><span>C语言入门手册</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa-solid fa-jet-fighter-up"></i><span> 开发工具</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/m/Maven/"><span>Maven</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa-solid fa-address-card"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/contact/"><i class="fa-fw fas fa-comment"></i><span> 留言板</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">陈建源的博客</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa-solid fa-book"></i><span> 必修课</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/m/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%95%99%E7%A8%8B/"><span>数据结构和算法</span></a></li><li><a class="site-page child" href="/m/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%95%99%E7%A8%8B/"><span>计算机操作系统</span></a></li><li><a class="site-page child" href="/m/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%95%99%E7%A8%8B/"><span>计算机网络</span></a></li><li><a class="site-page child" href="/m/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%95%99%E7%A8%8B/"><span>计算机组成原理</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa-brands fa-java"></i><span> Java</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/m/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"><span>基础知识</span></a></li><li><a class="site-page child" href="/m/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"><span>集合框架</span></a></li><li><a class="site-page child" href="/m/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"><span>并发编程</span></a></li><li><a class="site-page child" href="/m/JVM/"><span>JVM</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa-solid fa-database"></i><span> 数据库</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/m/MySQL/"><span>MySQL</span></a></li><li><a class="site-page child" href="/m/Redis/"><span>Redis</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa-solid fa-code"></i><span> 源码框架</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/m/OpenFeign/"><span>OpenFeign</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa-solid fa-marker"></i><span> 设计与理论</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/m/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><i class="fa-fw fas fa-layer-group"></i><span> 设计模式</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa-solid fa-c"></i><span> 辅助语言</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/m/C%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E6%89%8B%E5%86%8C/"><span>C语言入门手册</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa-solid fa-jet-fighter-up"></i><span> 开发工具</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/m/Maven/"><span>Maven</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa-solid fa-address-card"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/contact/"><i class="fa-fw fas fa-comment"></i><span> 留言板</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">类加载过程</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-08-13T20:55:17.000Z" title="发表于 2020-08-14 04:55:17">2020-08-14</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-04-09T11:05:15.870Z" title="更新于 2022-04-09 19:05:15">2022-04-09</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/m/JVM/">JVM</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">6.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>23分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title="类加载过程"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div><article class="post-content" id="article-container"><p>之前在网上看到一道面试题，很形象的描述了类的加载初始化过程。要完全理解这道题，就不得不深入理解类加载的过程。面试题如下：</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleTon</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingleTon singleTon = <span class="keyword">new</span> SingleTon();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> count1;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> count2 = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingleTon</span><span class="params">()</span> </span>{</span><br><span class="line">        count1++;</span><br><span class="line">        count2++;</span><br><span class="line">    }</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingleTon <span class="title">getInstance</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> singleTon;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        SingleTon singleTon = SingleTon.getInstance();</span><br><span class="line">        System.out.println(<span class="string">"count1="</span> + singleTon.count1);</span><br><span class="line">        System.out.println(<span class="string">"count2="</span> + singleTon.count2);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这道题的正确答案为 :</p><p><strong>count1=1</strong></p><p><strong>count2=0</strong></p><p>至于为什么会是这个答案，这就涉及到了 JVM 类加载的过程。</p><h2 id="类的生命周期">类的生命周期<a href="#类的生命周期"></a></h2><p>类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括加载、验证、准备、解析、初始化、使用和卸载 7 个阶段，其中验证、准备和解析 3 个阶段统称为连接，这 7 个阶段发生的顺序如下图所示。</p><p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/images/2020/08/12/image-20200812153126606.png" alt="类的生命周期"></p><p>加载、验证、准备、初始化和卸载这 5 个阶段的顺序是确定的。解析阶段则不一定，由于支持运行时绑定，类可以在初始化之后再开始进行解析。同时这些阶段只是按照顺序进行开始，并不一定会按照顺序进行或者结束，因为这些阶段通常都是互相交叉地混合式进行的，通常会在一个阶段执行过程中调用、激活另外一个阶段。</p><h2 id="类的加载过程">类的加载过程<a href="#类的加载过程"></a></h2><h3 id="加载">加载<a href="#加载"></a></h3><p>加载是类加载过程的一个阶段，是根据特定名称查找类或接口类型的二进制表示（binary representation），并由此二进制表示来创建类或接口的过程。在加载阶段，虚拟机需要完成 3 件事：</p><ol><li>通过一个类的全限定名来获取定义此类的二进制字节流。</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li><li>在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口。</li></ol><h4 id="加载途径">加载途径<a href="#加载途径"></a></h4><p>虚拟机加载的是类的二进制流，只是对内容格式做了限制，并没有指名要从哪里去获取、怎样获取一个类的二进制流，比较常见的有一下几种：</p><ul><li>从 jar、ear、war 包中读取。</li><li>从网络流中读取，这种场景的典型应用就是 Applet。</li><li>运行时计算生成，使用最多的就是动态代理技术。</li><li>其他文件生成，典型的场景是 JSP 应用，即由 JSP 文件生成对应的 Class 类。</li></ul><h4 id="加载方式">加载方式<a href="#加载方式"></a></h4><ul><li>对于一个非数组类，加载阶段可以使用系统提供的引导类加载器来完成，也可以由用户自定义的类加载器去完成。</li><li>数组类是 Java 虚拟机直接创建的。一个数组类创建的过程遵循以下规则：<ul><li>数组的元素是引用类型，那就递归采用本文所讲的类加载过程加载这个元素，数组类将在加载该元素类型的类加载器的类名称空间上被标识。</li><li>如果数组的元素类型不是引用类型（例如:int[] 数组），Java 虚拟机将会把数组类标记与引导类加载器关联。</li><li>数组的可见性与他的元素类型的可见性一致，如果元素类型不是引用类型，那数组的可见性将默认为 public。</li></ul></li></ul><p>加载阶段完成后，二级制字节流就按照虚拟机所需的格式储存在方法区之中，然后在内存中实例化一个 java.lang.Class 对象，将这个对象作为程序访问方法区中的这些类型数据的外部接口。</p><h3 id="验证">验证<a href="#验证"></a></h3><p>验证时连接阶段的第一步，这一步是为了保证 Class文件二进制字节流符合虚拟机规范，并且不会危害虚拟机自身的安全。<a href="https://docs.oracle.com/javase/specs/jvms/se7/html/index.html">Java 虚拟机规范</a>有大量的约束和验证规则，详细的描述的验证过程。验证过程主要还是围绕 Class 文件格式对各部分进行验证。Class 文件格式课参考另一篇博文<a href="https://www.techstack.tech/post/zi-jie-ma-wen-jian-jie-gou-xiang-jie/">字节码文件结构详解</a>。但从整体上看，验证阶段大致会完成下面 4 个阶段的验证动作。</p><h4 id="文件格式验证">文件格式验证<a href="#文件格式验证"></a></h4><p>第一阶段要验证字节流是否符合 Class文件格式规范，并且能被当前版本的虚拟机处理。这一阶段可能包括下面验证点：</p><ul><li>是否一魔数 0xCAFEBEBE 开头。</li><li>主次版本号是否在当前虚拟机处理范围之内。</li><li>常量池中的常量是否有不被支持的常量类型（检查常量 tag 标志）。</li><li>指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量。</li><li>…</li></ul><p>第一阶段的验证远不止这些，该阶段的主要目的是保证输入的字节流能正确的解析并存储于方法区内。这阶段的验证是基于二进制字节流进行的，只有通过了这个阶段的验证后，字节流才会进入内存的方法区中进行存储，所以后面的3个验证阶段全部是基于方法区的存储结构进行的，不会再直接操作字节流。</p><h4 id="元数据验证">元数据验证<a href="#元数据验证"></a></h4><p>元数据验证是对字节码描述的信息进行语义分析，确保其描述的信息符合 Java 语言规范的要求，这个阶段可能包括的验证点如下：</p><ul><li>这个类是否有父类（出了 java.lang.Object 之外，所有的类都应当有父类）。</li><li>这个类是否继承了不允许被继承的类（被 final 修饰的类）。</li><li>如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法。</li><li>类中的字段、方法是否与父类产生矛盾（例如覆盖了父类的final字段，或者出现不符合规则的方法重载，例如方法参数都一致，但返回值类型却不同等）。</li></ul><h4 id="字节码验证">字节码验证<a href="#字节码验证"></a></h4><p>字节码验证将对类的方法体进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的事件。</p><ul><li>保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作。</li><li>保证跳转指令不会跳转到方法体以外的字节码指令上。</li><li>保证方法体中的类型转换是有效的。</li></ul><p>如果一个方法通过了字节码验证，也不能说明其一定就是安全的。</p><h4 id="符号引用验证">符号引用验证<a href="#符号引用验证"></a></h4><p>符号引用验证可以看做是对类自身以外（常量池中的各种符号引用）的信息校验，通常需要校验一下内容：</p><ul><li>符号引用中通过字符串描述的全限定名是否能找到对应的类。</li><li>在指定类中是否存在符合方法的字段描述符以及简单名称所描述的方法和字段。</li><li>符号引用中的类、字段、方法的访问性（private、protected、public、default）是否可被当前类访问。</li></ul><p>如果一个类无法通过符号引用验证，那么将会抛出一个<code>java.lang.IncompatibleClassChangeError</code>异常的子类，如常见的<code>java.lang.IllegalAccessError</code>、<code>java.lang.NoSuchFieldError</code>、<code>java.lang.NoSuchMethodError</code>等。</p><h3 id="准备">准备<a href="#准备"></a></h3><p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些类变量所使用的内存都将在方法区中进行分配。此处需要明确<code>类变量</code>的含义，即被<code>static</code>修饰的变量，而不包括实例变量，实例变量会在初始化阶段随着对象一起分配在 Java 堆中。此时分配的初始值是数据类型的<code>零值</code>，并不是我们定义的初始值。此处还要明确一个概念，如果变量被<code>final</code>修饰，则此字段的字段属性表存在 ConstantValue 属性，那么在准备阶段变量就会被初始化为 ConstantValue属性所指定的值。可通过下例代码来对照理解：</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> B = <span class="number">20</span>;</span><br></pre></td></tr></tbody></table></figure><p>其部分汇编字节码为：</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">Constant pool:</span><br><span class="line">  #2 = Fieldref           #3.#21         // tech/techstack/blog/Test.a:I</span><br><span class="line">  #3 = Class              #22            // tech/techstack/blog/Test</span><br><span class="line">  #5 = Utf8               a</span><br><span class="line">  #6 = Utf8               I</span><br><span class="line">  #21 = NameAndType        #5:#6          // a:I</span><br><span class="line">  #22 = Utf8               tech/techstack/blog/Test</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> a;</span><br><span class="line">  descriptor: I</span><br><span class="line">  flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> B;</span><br><span class="line">  descriptor: I</span><br><span class="line">  flags: ACC_PUBLIC, ACC_STATIC, ACC_FINAL</span><br><span class="line">  ConstantValue: <span class="keyword">int</span> <span class="number">20</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> {};</span><br><span class="line">  descriptor: ()V</span><br><span class="line">  flags: ACC_STATIC</span><br><span class="line">  Code:</span><br><span class="line">    stack=<span class="number">1</span>, locals=<span class="number">0</span>, args_size=<span class="number">0</span></span><br><span class="line">       <span class="number">0</span>: bipush        <span class="number">10</span></span><br><span class="line">       2: putstatic     #2                  // Field a:I</span><br><span class="line">       <span class="number">5</span>: <span class="keyword">return</span></span><br><span class="line">    LineNumberTable:</span><br><span class="line">      line <span class="number">8</span>: <span class="number">0</span></span><br><span class="line">      </span><br></pre></td></tr></tbody></table></figure><p>从上述代码可以看出，B 字段对应的 field_info 与 a 字段对应的 field_info 相比对了一个 Constant_Value 属性，而 Constant_Value 属性的值 20 就会在准备阶段直接赋给字段 B。同时在字节码第 19 行有一个 <code>static {};</code>方法，此方法对应的就是类的构造方法<code>&lt;clinit&gt;</code>在初始化阶段执行,它的<code>Code</code>属性中对应的字节码指令<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.bipush"><code>bipush 10</code></a>为往操作数栈压入 10，<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.putstatic"><code>putstatic</code></a> 则是将值 10 赋值给 a 字段。</p><blockquote><p>基本数据类型的零值：</p><table><thead><tr><th>数据类型</th><th>零值</th></tr></thead><tbody><tr><td>byte</td><td>(byte)0</td></tr><tr><td>char</td><td>‘\u0000’</td></tr><tr><td>short</td><td>(short)0</td></tr><tr><td>boolean</td><td>false</td></tr><tr><td>int</td><td>0</td></tr><tr><td>long</td><td>0l</td></tr><tr><td>float</td><td>0.0f</td></tr><tr><td>double</td><td>0.0</td></tr><tr><td>reference</td><td>null</td></tr></tbody></table></blockquote><h3 id="解析">解析<a href="#解析"></a></h3><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，符号引用在 Class 文件中以 CONSTANT_Class_info、CONSTANT_Feildref_info、CONSTANT_Methodref_info 等类型的常量出现，具体可以参考博文<a href="https://www.techstack.tech/post/zi-jie-ma-wen-jian-jie-gou-xiang-jie/">字节码文件结构详解</a>。此处有符号引用和直接引用两个概念需要了解一下.</p><h4 id="符号引用（Symbolic-References）">符号引用（Symbolic References）<a href="#符号引用（Symbolic-References）"></a></h4><p>符号引用以一组符号来描述所引用的目标，符号引用可以是任何形式的字面量，只要使用能无歧义地定义到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标不一定已经加载到内存中。各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用必须都是一致的。符号引用的字面量形式需要明确的定义在 Class 文件格式中。</p><h4 id="直接引用（Direct-References）">直接引用（Direct References）<a href="#直接引用（Direct-References）"></a></h4><p>直接引用可以是直接执行目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是和虚拟机实现的内存布局相关的，同一个符号引用在不同的虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用目标必定已经出现在内存中。</p><blockquote><p>关于符号引用和直接引用两个概念看起来很空洞，此处放一个 <a href="https://www.zhihu.com/people/rednaxelafx/answers">R 大</a>的回答：<a href="https://www.zhihu.com/question/30300585">传送门</a></p></blockquote><p>虚拟机规范并未规定解析发生的具体时间，只要求在执行<code>anewarray</code>、<code>checkcast</code>、<code>getfield</code>、<code>getstatic</code>、<code>instanceof</code>、<code>invokedynamic</code>、<code>invokeinterface</code>、<code>invokespecial</code>、<code>invokestatic</code>、<code>invokevirtual</code>、<code>ldc</code>、<code>ldc_w</code>、<code>multianewarray</code>、<code>new</code>、<code>putfield</code>和 <code>putstatic</code>这 16 个用于操作符号引用的字节码指令之前，先对他们所使用的符号引用进行解析。所以虚拟机实现可以根据需要来判断到底是在类被加载和加载时就对常量池中的符号引用进行解析还是等到一个符号引用将要被使用前才去解析它。</p><blockquote><p>加载过程中的解析阶段为静态的将符号引用替换为直接引用的过程。可与虚拟机栈内存中的<a href="https://www.techstack.tech/post/jvm-nei-cun-jie-gou/#toc-heading-7">动态链接</a>参照记忆。</p></blockquote><p>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用限定符 7 类符号引用进行，分别对应于常量池的<code>CONSTANT_Class_info</code>、<code>CONSTANT_Fieldref_info</code>、<code>CONSTANT_Methodref_info</code>、<code>CONSTANT_InterfaceMethodref_info</code>、<code>CONSTANT_MethodType_info</code>、<code>CONSTANT_MethodHandle_info</code>和<code>CONSTANT_InvokeDynamic_info</code> 7种常量类型。</p><h3 id="初始化">初始化<a href="#初始化"></a></h3><p>初始化阶段是类加载过程中的最后一步，此阶段才是真正执行类中定义的 Java 程序代码。初始化阶段和准备阶段的初始化是不同概念的，准备阶段的初始化是给类字段赋值零值的过程，而类加载过程中的初始化阶段可以看做是类对象的初始化。对于类的初始化反映到字节码中就是类的<code>&lt;clinit&gt;()</code>方法。从另外一个角度来讲，可以将初始化阶段理解成是执行类构造器＜clinit＞()方法的过程。同时对于<code>&lt;clinit&gt;()</code>方法，有几个概念要弄清楚。</p><ul><li><code>&lt;clinit&gt;()</code>方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块(static {})中的语句合并产生的。</li><li>编译器收集的顺序是由语句在源文件中出现的顺序决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在静态语句块中可以赋值，但不能访问。</li><li>在执行子类的<code>&lt;clinit&gt;()</code>方法之前，虚拟机会确保子类的<code>&lt;clinit&gt;()</code>方法已经执行完毕。因此在虚拟机中第一个被执行的＜clinit＞()方法的类肯定是java.lang.Object。</li><li>接口中不能使用静态代码块，但仍有变量初始化的赋值操作，因此接口也会生成<code>&lt;clinit&gt;()</code>方法。与类不同的是，执行接口<code>&lt;clinit&gt;()</code>方法不需要先执行父接口的<code>&lt;clinit&gt;()</code>方法。只有当父接口中定义的变量使用时，父接口才会初始化。接口的实现类在初始化时也不会执行接口的<code>&lt;clinit&gt;()</code>方法。</li><li>在多线程的情况下，虚拟机会保证一个类的<code>&lt;clinit&gt;()</code>方法只被一个线程调用，其它线程会被阻塞。同时，在一个类加载器下，一个类的<code>&lt;clinit&gt;()</code>方法只会被执行一次。</li></ul><blockquote><p>注：</p><p>本文所说的类对象与类实例不是一个概念。关于类对象与类实例以及 java.lang.Class 对象之间的关系，此处可以引用 <code>R 大</code>的一个回答<a href="https://www.zhihu.com/question/50258991/answer/120450561">传送门</a>：</p><blockquote><p>在HotSpot VM中，对象(类的实例对象)、类的元数据（InstanceKlass）、类的Java镜像（java.lang.Class 实例），三者之间的关系是这样的：</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">&gt;&gt;Java object      InstanceKlass       Java mirror</span><br><span class="line">[ _mark  ]                          (java.lang.Class instance)</span><br><span class="line">[ _klass ] --&gt; [ ...          ] &lt;-\              </span><br><span class="line">[ fields ]     [ _java_mirror ] --+&gt; [ _mark  ]</span><br><span class="line">               [ ...          ]   |  [ _klass ]</span><br><span class="line">                                  |  [ fields ]</span><br><span class="line">                                   \ [ klass  ]</span><br></pre></td></tr></tbody></table></figure><p>每个Java对象的对象头里，_klass字段会指向一个VM内部用来记录类的元数据用的InstanceKlass对象；InsanceKlass里有个_java_mirror字段，指向该类所对应的Java镜像——java.lang.Class实例。HotSpot VM会给Class对象注入一个隐藏字段“klass”，用于指回到其对应的InstanceKlass对象。这样，klass与mirror之间就有双向引用，可以来回导航。这个模型里，java.lang.Class实例并不负责记录真正的类元数据，而只是对VM内部的InstanceKlass对象的一个包装供Java的反射访问用。</p></blockquote><p>通过上面的引用，可以清楚的知道 Java Object, InstanceKlass, Java mirror(java.lang.Class instance)在内存中的分布了。</p></blockquote><p>对于初始化阶段可以通过代码来理解一下：</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperClass</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> superClassField = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> {</span><br><span class="line">        System.out.println(<span class="string">"supper class static code"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SuperClass</span><span class="params">()</span> </span>{</span><br><span class="line">        System.out.println(<span class="string">"supper class constructor"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SuperInterface</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> superInterfaceField = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">SuperClass</span> <span class="keyword">implements</span> <span class="title">SuperInterface</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> subClassField = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> {</span><br><span class="line">        System.out.println(<span class="string">"sub class static code."</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SubClass</span><span class="params">()</span> </span>{</span><br><span class="line">        System.out.println(<span class="string">"sub class constructor"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClassLoad</span> </span>{</span><br><span class="line">    <span class="keyword">static</span> {</span><br><span class="line">        System.out.println(<span class="string">"test class load"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>{</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">static</span> {</span><br><span class="line">        System.out.println(<span class="string">"App main static code"</span>);</span><br><span class="line">    }</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        System.out.println(SubClass.superClassField);</span><br><span class="line">        System.out.println(<span class="string">"----------------------"</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(SubClass::<span class="keyword">new</span>).start();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>在运行 SubClass 的时候加上 <code>-XX:+TraceClassLoading</code> 参数，打印出来运行过程中加载的类。上述代码运行结果为结果 1：</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 类加载日志（节选）</span></span><br><span class="line">[Loaded tech.stack.App from file:/Users/chenjianyuan/IdeaProjects/course/target/classes/]</span><br><span class="line">[Loaded tech.stack.SuperInterface from file:/Users/chenjianyuan/IdeaProjects/course/target/classes/]</span><br><span class="line">[Loaded tech.stack.SuperClass from file:/Users/chenjianyuan/IdeaProjects/course/target/classes/]</span><br><span class="line">[Loaded tech.stack.SubClass from file:/Users/chenjianyuan/IdeaProjects/course/target/classes/]</span><br><span class="line"></span><br><span class="line">App main <span class="keyword">static</span> code</span><br><span class="line">supper <span class="class"><span class="keyword">class</span> <span class="title">static</span> <span class="title">code</span></span></span><br><span class="line"><span class="class">1</span></span><br><span class="line"><span class="class">----------------------</span></span><br><span class="line"><span class="class"><span class="title">sub</span> <span class="title">class</span> <span class="title">static</span> <span class="title">code</span>.</span></span><br><span class="line"><span class="class"><span class="title">supper</span> <span class="title">class</span> <span class="title">constructor</span></span></span><br><span class="line"><span class="class"><span class="title">sub</span> <span class="title">class</span> <span class="title">constructor</span>  </span></span><br><span class="line"><span class="class">  </span></span><br></pre></td></tr></tbody></table></figure><p>注释掉<code>new Thread(SubClass::new).start();</code>重新运行程序，得到一下输出结果 2：</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">[Loaded tech.stack.App from file:/Users/chenjianyuan/IdeaProjects/course/target/classes/]</span><br><span class="line">[Loaded tech.stack.SuperInterface from file:/Users/chenjianyuan/IdeaProjects/course/target/classes/]</span><br><span class="line">[Loaded tech.stack.SuperClass from file:/Users/chenjianyuan/IdeaProjects/course/target/classes/]</span><br><span class="line">[Loaded tech.stack.SubClass from file:/Users/chenjianyuan/IdeaProjects/course/target/classes/]</span><br><span class="line"></span><br><span class="line">App main <span class="keyword">static</span> code</span><br><span class="line">supper <span class="class"><span class="keyword">class</span> <span class="title">static</span> <span class="title">code</span></span></span><br><span class="line"><span class="class">1</span></span><br><span class="line"><span class="class">----------------------</span></span><br></pre></td></tr></tbody></table></figure><p>然后将 <code>System.out.println(SubClass.superClassField);</code> 替换为 <code>System.out.println(SubClass.subClassField);</code> 再次运行程序，得到输出结果 3：</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">[Loaded tech.stack.App from file:/Users/chenjianyuan/IdeaProjects/course/target/classes/]</span><br><span class="line">[Loaded tech.stack.SuperInterface from file:/Users/chenjianyuan/IdeaProjects/course/target/classes/]</span><br><span class="line">[Loaded tech.stack.SuperClass from file:/Users/chenjianyuan/IdeaProjects/course/target/classes/]</span><br><span class="line">[Loaded tech.stack.SubClass from file:/Users/chenjianyuan/IdeaProjects/course/target/classes/]</span><br><span class="line"></span><br><span class="line">App main <span class="keyword">static</span> code</span><br><span class="line">supper <span class="class"><span class="keyword">class</span> <span class="title">static</span> <span class="title">code</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">sub</span> <span class="title">class</span> <span class="title">static</span> <span class="title">code</span>.</span></span><br><span class="line"><span class="class">20</span></span><br><span class="line"><span class="class">----------------------</span></span><br></pre></td></tr></tbody></table></figure><p>这几段代码信息量很大，根据上文所讲慢慢分析：</p><ul><li>加载<ul><li>从类加载日志从看到<code>TestClassLoad</code>类始终都没有被加载。而<code>App</code>、<code>SuperInterface</code>、<code>SuperClass</code>、<code>SubClass</code> 始终被加载，是不是可以证明属于 Applicatin 作用域范围内的类会在首次使用时加载。</li><li>对比结果 1 和结果 2 以及没有显示调用<code>SuperInterface</code>任何方法、变量可以看出对于子类来说，在加载子类时首先要加载实现的接口以及父类。</li></ul></li><li>初始化<ul><li><p>当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。</p></li><li><p>结果 1 结果 3 都表明父类的<code>&lt;clinit&gt;()</code>方法在子类<code>&lt;clinit&gt;()</code>方法之前调用。</p></li><li><p>结果 1 结果 2 对比表明通过子类调用父类的静态的变量只会引起父类的初始化并不会使子类初始化。</p></li><li><p>对比结果 1 和结果 2 说明在多线程的情况况下只要类加载器相同，类只初始化一次。</p></li><li><p>对比结果 1、2、3 能得出一个实例的初始化顺序</p><ol><li>父类 static 代码块即父类的<code>&lt;clinit&gt;()</code>方法。</li><li>子类的 static 代码块即子类的<code>&lt;clinit&gt;()</code>方法。</li><li>父类的构造方法即父类的<code>&lt;init&gt;()</code>方法。</li><li>子类的构造方法<code>&lt;init&gt;()</code>方法、</li></ol></li></ul></li></ul><blockquote><p>注：</p><ol><li><p>关于类实例的初始化过程即对象的实例化过程会专门在另一篇博客进行讲解。</p></li><li><p>关于"接口中不能使用静态代码块，但仍有变量初始化的赋值操作，因此接口也会生成<code>&lt;clinit&gt;()</code>方法。" 在接口中变量初始化赋值操作可参考如下代码：</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SuperInterface</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> superInterfaceField = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    SuperClass su = <span class="keyword">new</span> SuperClass();</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// bytecode</span></span><br><span class="line"></span><br><span class="line">{</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> superInterfaceField;</span><br><span class="line">    descriptor: I</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC, ACC_FINAL</span><br><span class="line">    ConstantValue: <span class="keyword">int</span> <span class="number">10</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> tech.stack.SuperClass su;</span><br><span class="line">    descriptor: Ltech/stack/SuperClass;</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC, ACC_FINAL</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> {};</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">0</span>, args_size=<span class="number">0</span></span><br><span class="line">         0: new           #1                  // class tech/stack/SuperClass</span><br><span class="line">         <span class="number">3</span>: dup</span><br><span class="line">         4: invokespecial #2                  // Method tech/stack/SuperClass."&lt;init&gt;":()V</span><br><span class="line">         7: putstatic     #3                  // Field su:Ltech/stack/SuperClass;</span><br><span class="line">        <span class="number">10</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">10</span>: <span class="number">0</span></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></li></ol></blockquote><h2 id="类的加载时机">类的加载时机<a href="#类的加载时机"></a></h2><p>关于类在什么时候加载，我们可以有上面的代码窥见一斑。但是这只是在JDK1.8， Hotspot 虚拟机测试的情况下得出的结论，也不一定会是正确的，因为 Java 虚拟机规范中并没有进行强制约束，关于加载阶段，都是根据虚拟机的具体实现来自由把握。但是对于初始化阶段，虚拟机严格规定了<code>有且只有</code> 5 种情况必须立即对类进行<code>初始化</code>（而加载、验证、准备自然需要再次之前开始）：</p><ol><li>遇到<code>new</code>、<code>getstatic</code>、<code>putstatic</code>或<code>invokestatic</code>这4条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。生成这4条指令的最常见的Java代码场景是：使用new关键字实例化对象的时候、读取或设置一个类的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）的时候，以及调用一个类的静态方法的时候（已通过上文代码验证）。</li><li>使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。</li><li>当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化（上文代码也已验证）。</li><li>当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类（上文代码也已验证）。</li><li>当使用JDK 1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。</li></ol><p>尝试着补充解释一下这几条其中的原理，对于 <code>new</code> 关键字自然不用多说，<code>new</code> 关键字实例化类的实例对象之前自然会执行类的初始化操作，以完成 Java 程序对类的一些操作。<code>getstatic</code> <code>putstatic</code> 指令的含义为读取或设置一个类的静态字段，此处还是应用<code>R大</code>的回答，原文与上处引用出自同一处：</p><blockquote><p>从JDK 1.3到JDK 6的HotSpot VM，静态变量保存在类的元数据（InstanceKlass）的末尾。而从JDK 7开始的HotSpot VM，静态变量则是保存在类的Java镜像（java.lang.Class实例）的末尾。假如有这样的A类：</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>{</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>那么在JDK 6或之前的HotSpot VM里：</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">Java object      InstanceKlass       Java mirror</span><br><span class="line"> [ _mark  ]                          (java.lang.Class instance)</span><br><span class="line"> [ _klass ] --&gt; [ ...          ] &lt;-\              </span><br><span class="line"> [ fields ]     [ _java_mirror ] --+&gt; [ _mark  ]</span><br><span class="line">                [ ...          ]   |  [ _klass ]</span><br><span class="line">                [ A.value      ]   |  [ fields ]</span><br><span class="line">                                    \ [ klass  ]	</span><br></pre></td></tr></tbody></table></figure><p>可以看到这个A.value静态字段就在InstanceKlass对象的末尾存着了。而在JDK 7或之后的HotSpot VM里：</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">Java object      InstanceKlass       Java mirror</span><br><span class="line"> [ _mark  ]                          (java.lang.Class instance)</span><br><span class="line"> [ _klass ] --&gt; [ ...          ] &lt;-\              </span><br><span class="line"> [ fields ]     [ _java_mirror ] --+&gt; [ _mark   ]</span><br><span class="line">                [ ...          ]   |  [ _klass  ]</span><br><span class="line">                                   |  [ fields  ]</span><br><span class="line">                                    \ [ klass   ]</span><br><span class="line">                                      [ A.value ]</span><br></pre></td></tr></tbody></table></figure><p>可以看到这个A.value静态字段就在java.lang.Class对象的末尾存着了。</p></blockquote><p>据此我们应该就能得出结论，在设置静态变量的时候已经需要根据<code>InstanceKlass</code>生成<code>java.lang.Class</code>对象了，而静态变量已经不能在方法区通过读取类元信息进行获取或者储存。而生成 Java mirror 必然要通过完整的类元信息，因此需要进行初始化动作。对于<code>java.lang.reflect</code>包的反射方法，其根据的就是 <code>java.lang.Class</code>对象。对于子类初始化时，因为 Java 的继承特性，继承的是父类完整的类信息。父类进行初始化也是理所当然的。</p><p>上述 5 种场景中的行为称为对一个类的主动引用。除此之外，所有的引用类的方式都不会触发初始化，称为被动引用。例：</p><ul><li><p>通过子类调用父类的静态字段（变量+常量），不会导致子类的初始化。代码可参考上文。</p></li><li><p>通过数组定义来引用类，不会触发此类的初始化</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">      SuperClass[] superClasses = <span class="keyword">new</span> SuperClass[<span class="number">10</span>];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p>常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstantClass</span> </span>{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String HELLO_WORLD = <span class="string">"hello world !"</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        System.out.println(ConstantClass.HELLO_WORLD);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这是因为虽然在Java源码中引用了ConstClass类中的常量HELLOWORLD，但其实在编译阶段通过常量传播优化，已经将此常量的值"hello world !"存储到了App类的常量池中，以后App对常量HELLO_WORLD的引用实际都被转化为App类对自身常量池的引用了。也就是说，实际上App的Class文件之中并没有ConstantClass类的符号引用入口，这两个类在编译成Class之后就不存在任何联系了。可以看一下App的字节码。</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">Constant pool:</span><br><span class="line">	 #4 = String             #25            // hello world !</span><br><span class="line">	 #25 = Utf8               hello world !</span><br><span class="line"></span><br><span class="line">{</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">         3: ldc           #4                  // String hello world !</span><br><span class="line">         5: invokevirtual #5                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">         <span class="number">8</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">10</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">11</span>: <span class="number">8</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">9</span>     <span class="number">0</span>  args   [Ljava/lang/String;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="例题解析">例题解析<a href="#例题解析"></a></h2><p>其实讲到这里，这道题也算是分析完了，那么就根据上面所讲，总结一下这道题：</p><ol><li>运行 <code>Test</code> 类的 main 方法，回顾上文肯定要先加载、验证、初始化 <code>Test</code> 类（由于加载、验证必然发生在初始化之前，下面分析就忽略这两个阶段）。</li><li><code>SingleTon.getInstance()</code> 为 <code>Test</code> 类调用 <code>SingleTon</code> 类的静态方法，必然引起 <code>SingleTon</code> 类的初始化。</li><li><code>SingleTon</code> 类存在 <code>singleTon</code> <code>count1</code> <code>count2</code> 三个静态变量，因此这三个静态变量会被编译器<strong>顺序</strong>收集值到<code>&lt;clinit&gt;()</code>方法中。</li><li><code>&lt;clinit&gt;()</code> 开始就是 <code>new SingleTon()</code> 会创建 <code>SingleTon</code> 类的实例 <code>singleTon</code>，此时 ``singleTon.count1<code></code>singleTon.count2` 值都为 1。</li><li><code>&lt;clinit&gt;()</code> 操作完第一个变量 <code>singleTon</code> 之后便是对第二个变量 <code>count1</code> 操作，此时就会将 1 赋值给 <code>SingleTon</code> 变量 <code>count1</code>。</li><li><code>&lt;clinit&gt;()</code> 后续操作便是执行 <code>count2 = 0</code> 即通过操作数栈将 0 赋值给<code>SingleTon</code> 变量 <code>count2</code>。</li></ol><p>查看<code>SingleTon</code> 的字节码：</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">{</span><br><span class="line"> <span class="keyword">static</span> {};</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">0</span>, args_size=<span class="number">0</span></span><br><span class="line">         0: new           #5                  // class tech/stack/SingleTon</span><br><span class="line">         <span class="number">3</span>: dup</span><br><span class="line">         4: invokespecial #6                  // Method "&lt;init&gt;":()V</span><br><span class="line">         7: putstatic     #4                  // Field singleTon:Ltech/stack/SingleTon;</span><br><span class="line">        <span class="number">10</span>: iconst_0</span><br><span class="line">        11: putstatic     #3                  // Field count2:I</span><br><span class="line">        <span class="number">14</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">4</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">6</span>: <span class="number">10</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>其 <code>static{}</code> 方法执行流程正如上文分析。不妨想一下如果将<code>private static SingleTon singleTon = new SingleTon();</code>移动到<code>public static int count2 = 0;</code>下面将会输出什么结果？</p><h2 id="总结">总结<a href="#总结"></a></h2><p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/images/2020/08/14/%E7%B1%BB%E5%8A%A0%E8%BD%BD.png" alt="类加载"></p><p>参考：</p><p>[1] 周志明.深入理解Java虚拟机：JVM高级特性与最佳实践.北京:机械工业出版社,2013.</p><p>[2] <a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-5.html">Chapter 5. Loading, Linking, and Initializing</a></p><p>[3] <a href="https://www.zhihu.com/question/30300585">JVM里的符号引用如何存储？</a></p><p>[4] <a href="https://www.zhihu.com/question/50258991/answer/120450561">JVM符号引用转换直接引用的过程?</a></p><script>document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });</script></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">陈建源</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://www.techstack.tech/post/164885508/">https://www.techstack.tech/post/164885508/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://www.techstack.tech" target="_blank">陈建源的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a><a class="post-meta__tags" href="/tags/JVM/">JVM</a></div><div class="post_share"><div class="social-share" data-image="/img/avatar.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/reward/wechat.jpeg" target="_blank"><img class="post-qr-code-img" src="/img/reward/wechat.jpeg" alt="wechat"></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/reward/alipay.jpeg" target="_blank"><img class="post-qr-code-img" src="/img/reward/alipay.jpeg" alt="alipay"></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/post/164885659/"><img class="prev-cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Feign Api返回值为void时获取 Response信息</div></div></a></div><div class="next-post pull-right"><a href="/post/164885506/"><img class="next-cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">字节码文件结构详解</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/post/159683533/" title="JVM内存结构"><img class="cover" src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/images/2020/08/08/JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-08-08</div><div class="title">JVM内存结构</div></div></a></div><div><a href="/post/164885506/" title="字节码文件结构详解"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-08-10</div><div class="title">字节码文件结构详解</div></div></a></div><div><a href="/post/164885504/" title="从源码角度理解类加载器"><img class="cover" src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/images/2020/08/20/image-20200820173314832.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-08-21</div><div class="title">从源码角度理解类加载器</div></div></a></div><div><a href="/post/164885507/" title="对象的创建与死亡以及内存分配、回收机制"><img class="cover" src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/images/2020/09/07/image-20200907160940185.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-09-09</div><div class="title">对象的创建与死亡以及内存分配、回收机制</div></div></a></div><div><a href="/post/164885659/" title="Feign Api返回值为void时获取 Response信息"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-08-17</div><div class="title">Feign Api返回值为void时获取 Response信息</div></div></a></div><div><a href="/post/164885509/" title="原码、补码、反码"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-08-03</div><div class="title">原码、补码、反码</div></div></a></div></div></div><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.png" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">陈建源</div><div class="author-info__description">过着平凡的生活，享受着简单的人生</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">53</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a></div><div class="card-info-data-item is-center"><a href="/m/"><div class="headline">分类</div><div class="length-num">11</div></a></div></div><a class="button--animated" id="card-info-btn" href="https://github.com/yuanjianchen"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/yuanjianchen" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:jianyuan.c@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="tencent://message/?uin=1752133445&amp;Site=&amp;Menu=yes" target="_blank" title="QQ"><i class="fab fa-qq"></i></a><a class="social-icon" href="/img/wechat.jpg" target="_blank" title="WeChat"><i class="fab fa-weixin"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text">类的生命周期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B"><span class="toc-text">类的加载过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD"><span class="toc-text">加载</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD%E9%80%94%E5%BE%84"><span class="toc-text">加载途径</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD%E6%96%B9%E5%BC%8F"><span class="toc-text">加载方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AA%8C%E8%AF%81"><span class="toc-text">验证</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E9%AA%8C%E8%AF%81"><span class="toc-text">文件格式验证</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%83%E6%95%B0%E6%8D%AE%E9%AA%8C%E8%AF%81"><span class="toc-text">元数据验证</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E7%A0%81%E9%AA%8C%E8%AF%81"><span class="toc-text">字节码验证</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%A6%E5%8F%B7%E5%BC%95%E7%94%A8%E9%AA%8C%E8%AF%81"><span class="toc-text">符号引用验证</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%86%E5%A4%87"><span class="toc-text">准备</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90"><span class="toc-text">解析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%A6%E5%8F%B7%E5%BC%95%E7%94%A8%EF%BC%88Symbolic-References%EF%BC%89"><span class="toc-text">符号引用（Symbolic References）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E5%BC%95%E7%94%A8%EF%BC%88Direct-References%EF%BC%89"><span class="toc-text">直接引用（Direct References）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">初始化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%97%B6%E6%9C%BA"><span class="toc-text">类的加载时机</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98%E8%A7%A3%E6%9E%90"><span class="toc-text">例题解析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/164995635/" title="并发理论基础：Java 内存模型JMM">并发理论基础：Java 内存模型JMM</a><time datetime="2022-04-14T17:12:29.000Z" title="发表于 2022-04-15 01:12:29">2022-04-15</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/164942290/" title="并发理论基础：指令重排序问题">并发理论基础：指令重排序问题</a><time datetime="2022-04-08T13:01:28.000Z" title="发表于 2022-04-08 21:01:28">2022-04-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/164926797/" title="并发理论基础：缓存可见性、MESI、内存屏障">并发理论基础：缓存可见性、MESI、内存屏障</a><time datetime="2022-04-06T17:59:31.000Z" title="发表于 2022-04-07 01:59:31">2022-04-07</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/164913260/" title="并发理论基础：原子性问题">并发理论基础：原子性问题</a><time datetime="2022-04-05T03:25:31.000Z" title="发表于 2022-04-05 11:25:31">2022-04-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/164912916/" title="并发理论基础：并发与并行">并发理论基础：并发与并行</a><time datetime="2022-04-05T03:25:31.000Z" title="发表于 2022-04-05 11:25:31">2022-04-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/164912852/" title="并发理论基础：并发问题产生的三大根源">并发理论基础：并发问题产生的三大根源</a><time datetime="2022-04-05T03:15:11.000Z" title="发表于 2022-04-05 11:15:11">2022-04-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/164885530/" title="说一说我理解的Java">说一说我理解的Java</a><time datetime="2022-04-01T22:21:13.000Z" title="发表于 2022-04-02 06:21:13">2022-04-02</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/164885535/" title="Redis入门-Redis概念和基础">Redis入门-Redis概念和基础</a><time datetime="2022-04-01T13:42:39.000Z" title="发表于 2022-04-01 21:42:39">2022-04-01</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By 陈建源</div><div class="framework-info"><span>框架 </span><a href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text"><span><a href="http://www.beian.miit.gov.cn"><img class="icp-icon" src="/img/icp.png"><span>备案号：京ICP备17031811号-1</span></a> | 本网站由<a href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral" target="_blank"><img src="/img/又拍云_logo6.png" class="youpai-logo"></a>提供CDN加速/云储存服务</span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div></div><hr><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'M1Fb2kAISrjFNkvAaWci9NrJ-gzGzoHsz',
      appKey: 'q4sEVnF9Minjscuva66D0auY',
      placeholder: 'Please leave your footprints',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'zh-CN',
      recordIP: true,
      serverURLs: 'https://m1fb2kai.lc-cn-n1-shared.com',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: true,
      path: window.location.pathname,
      requiredFields: ["nick,mail"],
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script defer id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>
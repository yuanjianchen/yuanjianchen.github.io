<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>字节码文件结构详解 | 陈建源的博客</title><meta name="keywords" content="jvm,class,字节码,Class类文件结构"><meta name="author" content="陈建源"><meta name="copyright" content="陈建源"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Class 类文件的结构,Class文件是一组以 8位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在 Class 文件中"><meta property="og:type" content="article"><meta property="og:title" content="字节码文件结构详解"><meta property="og:url" content="https://www.techstack.tech/post/164885506/"><meta property="og:site_name" content="陈建源的博客"><meta property="og:description" content="Class 类文件的结构,Class文件是一组以 8位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在 Class 文件中"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://www.techstack.tech/img/avatar.png"><meta property="article:published_time" content="2020-08-09T17:42:35.000Z"><meta property="article:modified_time" content="2022-04-21T08:08:26.728Z"><meta property="article:author" content="陈建源"><meta property="article:tag" content="Java"><meta property="article:tag" content="JVM"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://www.techstack.tech/img/avatar.png"><link rel="shortcut icon" href="/img/avatar.png"><link rel="canonical" href="https://www.techstack.tech/post/164885506/"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":300},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: 陈建源","link":"链接: ","source":"来源: 陈建源的博客","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: true,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"字节码文件结构详解",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2022-04-21 16:08:26"}</script><noscript><style type="text/css">#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    })(window)</script><meta name="generator" content="Hexo 5.1.1"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.png" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">55</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/m/"><div class="headline">分类</div><div class="length-num">11</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa-solid fa-book"></i><span> 必修课</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/m/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%95%99%E7%A8%8B/"><span>数据结构和算法</span></a></li><li><a class="site-page child" href="/m/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%95%99%E7%A8%8B/"><span>计算机操作系统</span></a></li><li><a class="site-page child" href="/m/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%95%99%E7%A8%8B/"><span>计算机网络</span></a></li><li><a class="site-page child" href="/m/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%95%99%E7%A8%8B/"><span>计算机组成原理</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa-brands fa-java"></i><span> Java</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/m/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"><span>基础知识</span></a></li><li><a class="site-page child" href="/m/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"><span>集合框架</span></a></li><li><a class="site-page child" href="/m/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"><span>并发编程</span></a></li><li><a class="site-page child" href="/m/JVM/"><span>JVM</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa-solid fa-database"></i><span> 数据库</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/m/MySQL/"><span>MySQL</span></a></li><li><a class="site-page child" href="/m/Redis/"><span>Redis</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa-solid fa-code"></i><span> 源码框架</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/m/OpenFeign/"><span>OpenFeign</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa-solid fa-marker"></i><span> 设计与理论</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/m/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><i class="fa-fw fas fa-layer-group"></i><span> 设计模式</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa-solid fa-c"></i><span> 辅助语言</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/m/C%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E6%89%8B%E5%86%8C/"><span>C语言入门手册</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa-solid fa-jet-fighter-up"></i><span> 开发工具</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/m/Maven/"><span>Maven</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">陈建源的博客</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa-solid fa-book"></i><span> 必修课</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/m/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%95%99%E7%A8%8B/"><span>数据结构和算法</span></a></li><li><a class="site-page child" href="/m/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%95%99%E7%A8%8B/"><span>计算机操作系统</span></a></li><li><a class="site-page child" href="/m/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%95%99%E7%A8%8B/"><span>计算机网络</span></a></li><li><a class="site-page child" href="/m/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%95%99%E7%A8%8B/"><span>计算机组成原理</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa-brands fa-java"></i><span> Java</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/m/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"><span>基础知识</span></a></li><li><a class="site-page child" href="/m/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"><span>集合框架</span></a></li><li><a class="site-page child" href="/m/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"><span>并发编程</span></a></li><li><a class="site-page child" href="/m/JVM/"><span>JVM</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa-solid fa-database"></i><span> 数据库</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/m/MySQL/"><span>MySQL</span></a></li><li><a class="site-page child" href="/m/Redis/"><span>Redis</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa-solid fa-code"></i><span> 源码框架</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/m/OpenFeign/"><span>OpenFeign</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa-solid fa-marker"></i><span> 设计与理论</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/m/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><i class="fa-fw fas fa-layer-group"></i><span> 设计模式</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa-solid fa-c"></i><span> 辅助语言</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/m/C%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E6%89%8B%E5%86%8C/"><span>C语言入门手册</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa-solid fa-jet-fighter-up"></i><span> 开发工具</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/m/Maven/"><span>Maven</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">字节码文件结构详解</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-08-09T17:42:35.000Z" title="发表于 2020-08-10 01:42:35">2020-08-10</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-04-21T08:08:26.728Z" title="更新于 2022-04-21 16:08:26">2022-04-21</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/m/JVM/">JVM</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">5.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>20分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title="字节码文件结构详解"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div><article class="post-content" id="article-container"><p>“一次编写，到处运行（Write Once,Run Anywhere）“，这是 Java 诞生之时一个非常著名的口号。在学习 Java 之初，就了解到了我们所写的<code>.java</code>会被编译期编译成<code>.class</code>文件之后被 JVM 加载运行。JVM 全称为 <code>Java Virtual Machine</code>，一直以为 JVM 执行 Java 程序是一件理所当然的事情，但随着工作过程中接触到了越来越多的基于 JVM 实现的语言如<code>Groovy</code> <code>Kotlin</code> <code>Scala</code>等，就深刻的理解到了 JVM 和 Java 的无关性，JVM 运行的不是 Java 程序，而是符合 JVM 规范的<code>.class</code>字节码文件。字节码是各种不同平台的虚拟机与所有平台都统一使用的程序储存格式。是构成<code>Run Anywhere</code> 的基石。因此了解 Class 字节码文件对于我们开发、逆向都是十分有帮助的。</p><h2 id="Class-类文件的结构">Class 类文件的结构<a href="#Class-类文件的结构"></a></h2><h3 id="概述">概述<a href="#概述"></a></h3><p>Class文件是一组以 8位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在 Class 文件中，中间没有添加任何分隔符，这使得整个 Class 文件中存储的内容几乎全部是程序运行的必要数据，没有空隙存在。当遇到需要占用 8 位字节以上空间的数据项时，则会按照<code>Big-Endian</code>的方式分割成若干个 8 字节进行存储。<code>Big-Endian</code>具体是指最高位字节在地址最低位、最低位字节在地址最高位的顺序来存储数据。<code>SPARC</code>、<code>PowerPC</code>等处理器默认使用<code>Big-Endian</code>字节存储顺序，而<code>x86</code>等处理器则是使用了相反的<code>Little-Endian</code>顺序来存储数据。因此为了Class文件的保证平台无关性，JVM必须对其规范统一。</p><h3 id="Class-文件结构">Class 文件结构<a href="#Class-文件结构"></a></h3><p>在讲解Class类文件结构之前需要先介绍两个概念：无符号数和表。一种类似 C 语言结构体的伪结构。</p><ul><li>无符号数：基本类型数据，一 u1、u2、u4、u8 来分别代表 1 个字节、2 个字节、4 个字节和 8 个字节的无符号数。用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串值。</li><li>表：由多个无符号数或者其他表作为数据项构成的复合数据类型，所有的表都习惯以<code>_info</code>结尾，用于描述有层次关系的复合结构的数据。</li></ul><p>当需要描述同一类型但数量不定的多个数据时，经常会使用一个前置的容量计数器加若干个连续的数据项的形式，这时就代表此类型的集合。整个 Class文件本质上就是一张表，其数据项如下伪代码所示：</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">ClassFile {</span><br><span class="line">  u4              magic;</span><br><span class="line">  u2              minor_version;</span><br><span class="line">  u2              major_version;</span><br><span class="line">  u2              constant_pool_count;</span><br><span class="line">  cp_info         constant_pool[constant_pool_count-<span class="number">1</span>];</span><br><span class="line">  u2              access_flags;</span><br><span class="line">  u2              this_class;</span><br><span class="line">  u2              super_class;</span><br><span class="line">  u2              interfaces_count;</span><br><span class="line">  u2              interfaces[interfaces_count];</span><br><span class="line">  u2              fields_count;</span><br><span class="line">  field_info      fields[fields_count];</span><br><span class="line">  u2              methods_count;</span><br><span class="line">  method_info     methods[methods_count];</span><br><span class="line">  u2              attributes_count;</span><br><span class="line">  attribute_info  attributes[attributes_count];</span><br><span class="line">}	</span><br></pre></td></tr></tbody></table></figure><p>每项数据项的含义我们可以对照下图参照表：</p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/images/2020/08/08/image-20200808150307745.png" alt="Class类文件结构"><p>同时我们将根据一个具体的 Java 类来分析 Class 文件结构</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteCode</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> username;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsername</span><span class="params">(String username)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>其.class 文件内容如下：</p><p id=".class"></p><img id=".class" src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/images/2020/08/09/class%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84.png" alt="class文件结构"><p id="huibian"></p><p>使用 <code>javap</code> 命令可以得到反汇编代码：</p><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">Classfile /Users/chenjianyuan/IdeaProjects/blog/blog-web/target/test-classes/tech/techstack/blog/ByteCode.class</span><br><span class="line">  Last modified 2020-8-8; size 581 bytes</span><br><span class="line">  MD5 checksum 43eb79f48927d9c5bbecfa5507de0f3c</span><br><span class="line">  Compiled from "ByteCode.java"</span><br><span class="line">public class tech.techstack.blog.ByteCode</span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: 52</span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #1 = Methodref          #4.#21         // java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">   #2 = Fieldref           #3.#22         // tech/techstack/blog/ByteCode.username:Ljava/lang/String;</span><br><span class="line">   #3 = Class              #23            // tech/techstack/blog/ByteCode</span><br><span class="line">   #4 = Class              #24            // java/lang/Object</span><br><span class="line">   #5 = Utf8               username</span><br><span class="line">   #6 = Utf8               Ljava/lang/String;</span><br><span class="line">   #7 = Utf8               &lt;init&gt;</span><br><span class="line">   #8 = Utf8               ()V</span><br><span class="line">   #9 = Utf8               Code</span><br><span class="line">  #10 = Utf8               LineNumberTable</span><br><span class="line">  #11 = Utf8               LocalVariableTable</span><br><span class="line">  #12 = Utf8               this</span><br><span class="line">  #13 = Utf8               Ltech/techstack/blog/ByteCode;</span><br><span class="line">  #14 = Utf8               getUsername</span><br><span class="line">  #15 = Utf8               ()Ljava/lang/String;</span><br><span class="line">  #16 = Utf8               setUsername</span><br><span class="line">  #17 = Utf8               (Ljava/lang/String;)V</span><br><span class="line">  #18 = Utf8               MethodParameters</span><br><span class="line">  #19 = Utf8               SourceFile</span><br><span class="line">  #20 = Utf8               ByteCode.java</span><br><span class="line">  #21 = NameAndType        #7:#8          // "&lt;init&gt;":()V</span><br><span class="line">  #22 = NameAndType        #5:#6          // username:Ljava/lang/String;</span><br><span class="line">  #23 = Utf8               tech/techstack/blog/ByteCode</span><br><span class="line">  #24 = Utf8               java/lang/Object</span><br><span class="line">{</span><br><span class="line">  public tech.techstack.blog.ByteCode();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=1, locals=1, args_size=1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">         4: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 7: 0</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0       5     0  this   Ltech/techstack/blog/ByteCode;</span><br><span class="line"></span><br><span class="line">  public java.lang.String getUsername();</span><br><span class="line">    descriptor: ()Ljava/lang/String;</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=1, locals=1, args_size=1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: getfield      #2                  // Field username:Ljava/lang/String;</span><br><span class="line">         4: areturn</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 11: 0</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0       5     0  this   Ltech/techstack/blog/ByteCode;</span><br><span class="line"></span><br><span class="line">  public void setUsername(java.lang.String);</span><br><span class="line">    descriptor: (Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=2, args_size=2</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: aload_1</span><br><span class="line">         2: putfield      #2                  // Field username:Ljava/lang/String;</span><br><span class="line">         5: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 15: 0</span><br><span class="line">        line 16: 5</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0       6     0  this   Ltech/techstack/blog/ByteCode;</span><br><span class="line">            0       6     1 username   Ljava/lang/String;</span><br><span class="line">    MethodParameters:</span><br><span class="line">      Name                           Flags</span><br><span class="line">      username</span><br><span class="line">}</span><br><span class="line">SourceFile: "ByteCode.java"                                   </span><br></pre></td></tr></tbody></table></figure><h4 id="magic">magic<a href="#magic"></a></h4><p>每个 Class 文件的头 4 个字节<code>0xCAFEBABE</code>称为魔数（Magic Number），用来确定这个文件是否为能被虚拟机接受的 Class 文件格式。</p><h4 id="minor-version-major-version">minor_version &amp; major_version<a href="#minor-version-major-version"></a></h4><p>第 5、6 个字节为次版本号（minor_version），第 6、7 个字节是主版本号（major version）上图次版本号 <code>00 00</code> 转换为 10 进制为 0，主版本号 <code>00 34</code> 转换为十进制为 52，代表 JDK 1.8。观察<a href="#huibian">反汇编</a>代码也能得到次版本和主版本信息。高版本的 JDK 向下兼容低版本的 Class 文件，但低版本不能运行高版本的 Class 文件，即使文件格式没有发生任何变化，虚拟机也拒绝执行高于其版本号的 Class 文件。</p><h4 id="constant-pool-count-constant-pool">constant_pool_count &amp; constant_pool[]<a href="#constant-pool-count-constant-pool"></a></h4><p>后面紧跟着的 2 个字节为常量池个数（constant_pool_count）,然后后面紧跟 constant_pool_count 个数的常量。constant_pool_count 是从 1 开始而不是从 0 开始，是为了将 0 项空出来标识后面某些指向常量池的索引值的数据在特定情况下不引用常量池，这种情况下就可以把索引值置为 0 来表示。（除常量池计数外，对于其他类型集合包括接口索引集合、字段表集合、方法表集合等的容量计数都与一般习惯相同，是从0开始的）</p><p>常量池（constant_pool）主要存放两大类常量：</p><ul><li>字面量<ul><li>字符串常量</li><li>final 的常量值</li><li>其他类文件的引用</li></ul></li><li>符号引用<ul><li>类和接口的全限定名</li><li>字段的名称和描述符</li><li>方法的名称和描述符</li></ul></li></ul><p>常量池中的每一个常量都是一个常量表，常量表开始的第一位是一个u1类型的标志位（tag），来区分常量表的类型。在JDK 1.7之前共有11种结构各不相同的表结构数据，在JDK 1.7中为了更好地支持动态语言调用，又额外增加了3种（CONSTANT_MethodHandle_info、CONSTANT_MethodType_info和CONSTANT_InvokeDynamic_info），14 中常量类型所代表的具体含义如下：</p><p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/images/2020/08/08/image-20200808180458818.png" alt="常量池的项目类型"></p><p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/images/2020/08/08/image-20200808182307356.png" alt="常量池中的 14 种常量项的结构总表"></p><p>我们对其按照字面量和符号引用类型分类的话可以入下图所示</p><img id="常量表类型分类" src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/images/2020/08/08/image-20200808170707933.png" alt="常量表类型分类"><p>Class文件中的常量池结构通过上例汇编代码可看出：</p><p id="constant_pool"></p><figure class="highlight"><table><tbody><tr><td class="code"><pre><span class="line">Constant pool:</span><br><span class="line">   #1 = Methodref          #4.#21         // java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">   #2 = Fieldref           #3.#22         // tech/techstack/blog/ByteCode.username:Ljava/lang/String;</span><br><span class="line">   #3 = Class              #23            // tech/techstack/blog/ByteCode</span><br><span class="line">   #4 = Class              #24            // java/lang/Object</span><br><span class="line">   #5 = Utf8               username</span><br><span class="line">   #6 = Utf8               Ljava/lang/String;</span><br><span class="line">   #7 = Utf8               &lt;init&gt;</span><br><span class="line">   #8 = Utf8               ()V</span><br><span class="line">   #9 = Utf8               Code</span><br><span class="line">  #10 = Utf8               LineNumberTable</span><br><span class="line">  #11 = Utf8               LocalVariableTable</span><br><span class="line">  #12 = Utf8               this</span><br><span class="line">  #13 = Utf8               Ltech/techstack/blog/ByteCode;</span><br><span class="line">  #14 = Utf8               getUsername</span><br><span class="line">  #15 = Utf8               ()Ljava/lang/String;</span><br><span class="line">  #16 = Utf8               setUsername</span><br><span class="line">  #17 = Utf8               (Ljava/lang/String;)V</span><br><span class="line">  #18 = Utf8               MethodParameters</span><br><span class="line">  #19 = Utf8               SourceFile</span><br><span class="line">  #20 = Utf8               ByteCode.java</span><br><span class="line">  #21 = NameAndType        #7:#8          // "&lt;init&gt;":()V</span><br><span class="line">  #22 = NameAndType        #5:#6          // username:Ljava/lang/String;</span><br><span class="line">  #23 = Utf8               tech/techstack/blog/ByteCode</span><br><span class="line">  #24 = Utf8               java/lang/Object</span><br></pre></td></tr></tbody></table></figure><p>观察上面<a href="#.class">Class</a>文件<code>00 19</code>表示有 25 个常量，依次往后数 24（25-1）个常量则为常量池中的常量。紧随其后的一个字节为第一个常量表的 tag 位 <code>0A</code> -&gt; <code>10</code>，通过<a href="#%E5%B8%B8%E9%87%8F%E8%A1%A8%E7%B1%BB%E5%9E%8B%E5%88%86%E7%B1%BB">常量表类型</a>查询可知 10 为 <code>CONSTANT_Methodref_info</code>，表内数据项为<code>u1: tag</code> <code>u2: class_info</code> <code>u2: name_and_type_index</code>,结合<a href="#.class">Class文件</a>分析，这表示从第一个常量<code>CONSTANT_Methodref_info</code>占用 5 个字节，其中第一个字节<code>0A</code>为标志位，其后两个字节<code>00 04</code> -&gt; <code>4</code> 之后两个字节为 class_info，紧随 2 个字节<code>00 15</code> -&gt; <code>21</code>为 name_and_type_index。我们通过查询汇编代码<a href="#constant_pool">常量池</a>中的一个常量表为<code>#1 = Methodref #4.#21</code>得出一个常量表正是方法引用，其数据项索引也是<code>#4</code>和<code>#21</code>。剩下的 24 种常量分析也是如此。也是因为这 14 中常量类型各自均有自己的结构，所以说常量池是最繁琐的数据。</p><blockquote><p>小知识：</p><p>由于Class文件中方法、字段等都需要引用CONSTANT_Utf8_info型常量来描述名称，所以CONSTANT_Utf8_info型常量的最大长度也就是Java中方法、字段名的最大长度。而这里的最大长度就是length的最大值，既u2类型能表达的最大值65535。所以Java程序中如果定义了超过64KB英文字符的变量或方法名，将会无法编译。</p></blockquote><h4 id="access-flags">access_flags<a href="#access-flags"></a></h4><p>在常量池结束之后，紧接着两个字节代表访问标志（access_flag）这个标志用于识别一些类或接口层次的访问信息。具体标志位以及标志的含义见下表：</p><p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/images/2020/08/08/image-20200808191213634.png" alt="类的访问权限查询书册"></p><blockquote><p>invokeSpecial 指令语义在 JDK1.0.2发生过改变，为了区别这条指令使用哪种语意，在 JDK1.0.2之后编译出来的类的这个标志都必须为真。</p></blockquote><p>分析[Class]文件我们得出 access_flag 为 <code>00 21</code>，但是查询上表确没有查询到对应的标志，这是因为 <code>ByteCode</code>是一个普通的 Java 类，不是接口、枚举或者注解，被public关键字修饰但没有被声明为final和abstract，并且它使用了JDK 1.2之后的编译器进行编译，因此它的ACC_PUBLIC、ACC_SUPER标志应当为真，而其余 6 个标志应当为假，因此它的access_flags的值应为：<code>0x0001|0x0020=0x0021</code>。而我们通过 <code>ByteCode</code> <a href="#huibian">汇编</a>代码查看得到 <code>flags: ACC_PUBLIC, ACC_SUPER</code> 也证明了的确为上述所言。</p><h4 id="this-class-super-class-interfaces-count-interfaces">this_class &amp; super_class &amp;interfaces_count &amp; interfaces[]<a href="#this-class-super-class-interfaces-count-interfaces"></a></h4><p>类索引（this_class）、父类索引（super_class）和 接口数量（interface_count）是一个 u2类型的数据，而接口索引集合 interfaces[] 是一组 u2 类型的数据的集合。这四项数据直接确定了这个类的继承关系。Java 不允许多继承但是允许实现多个接口，这就为什么super_class是一个而 interfaces 是一个集合。我们通过分析[Class]文件可以看出 this_class 对应<code>00 03 -&gt; 3</code> 从常量池中查询 #3 对应的常量</p><figure class="highlight"><table><tbody><tr><td class="code"><pre><span class="line">#3 = Class              #23            // tech/techstack/blog/ByteCode</span><br><span class="line">#23 = Utf8               tech/techstack/blog/ByteCode</span><br></pre></td></tr></tbody></table></figure><p>可以看出 #3 对应的就是当前类 <code>tech/techstack/blog/ByteCode</code>。后面同样为占两个字节的 super_class 对应的``00 04 -&gt; 4`从常量池中查询出来对应的常量为</p><figure class="highlight"><table><tbody><tr><td class="code"><pre><span class="line">#4 = Class              #24            // java/lang/Object</span><br><span class="line">#24 = Utf8               java/lang/Object</span><br></pre></td></tr></tbody></table></figure><p>所以 super_class 表示的为：<code>java/lang/Object</code>。随后便是 interface_count 对应的 <code>00 00 -&gt; 0</code> 说明 <code>ByteCode</code> 没有实现接口，因此就不存在后面的 interfaces[]。</p><h4 id="fields-count-fields">fields_count &amp; fields[]<a href="#fields-count-fields"></a></h4><p>字段表（field_info）用于描述接口或者类中声明的变量。字段（field）包括类级变量以及实例级变量，但不包括在方法内部声明的局部变量。fields_count 类中 field_info 的数量。fields[] 则是 field_info 的集合。field_info 的结构如下图所示：</p><p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/images/2020/08/08/10851.png" alt="field_info"></p><p>字段修饰符 access_flag 和类中的 access_flag十分相似：</p><p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/images/2020/08/08/image-20200808212229634.png" alt="字段访问标志"></p><p>在实际情况中，ACC_PUBLIC、ACC_PRIVATE、ACC_PROTECTED三个标志最多只能选择其一，ACC_FINAL、ACC_VOLATILE不能同时选择。接口之中的字段必须有ACC_PUBLIC、ACC_STATIC、ACC_FINAL标志。</p><p>继续分析<a href="#.class">Class</a>文件，<code>00 01 00 02 00 05 00 06 00 00</code>。其中 <code>00 01 -&gt; 1</code>表示 field_count,很显然 <code>ByteCode</code> 类中的字段只有一个 <code>private String username;</code>。 参照上表继续取两个字节<code>00 02 -&gt; 2</code>表示access_flag,查询可知修饰符号为<code>ACC_PRIVATE</code>，继续取两个字节<code>00 05 -&gt; 5</code>表示 name_index,从<a href="#huibian">汇编</a>代码中查询常量池#5为</p><figure class="highlight"><table><tbody><tr><td class="code"><pre><span class="line">#5 = Utf8               username	</span><br></pre></td></tr></tbody></table></figure><p>继续取两个字节<code>00 006 -&gt; 6</code>表示<code>descriptor_index</code>,指向的是常量池 #6 的常量</p><figure class="highlight"><table><tbody><tr><td class="code"><pre><span class="line">#6 = Utf8               Ljava/lang/String;</span><br></pre></td></tr></tbody></table></figure><p>后续的 <code>00 00 -&gt; 0</code>表示<code>attribute_count</code>的个数，此处为 0。</p><blockquote><p>名词释义:</p><ol><li><p>全限定名和简单名称把类名中的<code>.</code>替换成<code>/</code>，连续多个全限定名时，为了不产生混淆，在使用时最后一般都会加入一个<code>;</code>表示全限定名结束。</p></li><li><p>方法、字段索引描述</p><p>方法的参数列表（包括数量、类型以及顺序）和返回值。根据描述符规则，基本数据类型（byte、char、double、float、int、long、short、boolean）以及代表无返回值的void类型都用一个大写字符来表示，而对象类型则用字符L加对象的全限定名来表示。</p><ul><li><p>基本数据类型</p><p>B----&gt;byte C----&gt;char D----&gt;double F-----&gt;float I------&gt;int J------&gt;long S------&gt;short Z------&gt;boolean V-------&gt;void</p></li><li><p>对象类型</p><p>String------&gt;Ljava/lang/String;</p></li><li><p>数组类型：每一个唯独都是用一个前置 [ 来表示</p><p>int[] ------&gt;[ I,</p><p>String [][]------&gt;[[Ljava.lang.String;</p></li></ul></li><li><p>用描述符来描述方法的,先参数列表，后返回值的格式，参数列表按照严格的顺序放在()中比如源码 String getUserInfoByIdAndName(int id,String name) 的方法描述符（I,Ljava/lang/String;）Ljava/lang/String;</p></li></ol></blockquote><h4 id="methods-count-methods">methods_count &amp; methods[]<a href="#methods-count-methods"></a></h4><p>Class文件储存格式中对方法的描述与对字段的描述几乎采用了完全一致的方式。方法表的结构如下图所示：</p><p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/images/2020/08/08/10855.png" alt="Method_info"></p><p>因为volatile关键字和transient关键字不能修饰方法，所以方法表的访问标志中没有了ACC_VOLATILE标志和ACC_TRANSIENT标志。与之相对的，synchronized、native、strictfp和abstract关键字可以修饰方法，所以方法表的访问标志中增加了ACC_SYNCHRONIZED、ACC_NATIVE、ACC_STRICTFP和ACC_ABSTRACT标志：</p><p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/images/2020/08/08/image-20200808212552101.png" alt="方法访问标志"></p><p>同样根据<a href="#.class">Class</a>文件进行分析。<code>00 03</code>表示 method_count 说明<code>ByteCode</code>类的方法有三个，根据Method_info继续取出第一个方法的 8 个字节<code>00 01 00 07 00 08 00 01</code>，<code>00 01 -&gt; 0</code>表示的是方法的修饰符 表示的是access_flag 为 acc_public，<code>00 07 -&gt; 7</code>表示的是方法的名称(name_index) 指向常量池中#7常量</p><figure class="highlight"><table><tbody><tr><td class="code"><pre><span class="line">#7 = Utf8               &lt;init&gt;</span><br></pre></td></tr></tbody></table></figure><p>表示方法为<code>&lt;init&gt;</code>的构造方法。<code>00 08 -&gt;8</code>代表方法的描述符号（descriptor_index）,指向常量池 #8 常量</p><figure class="highlight"><table><tbody><tr><td class="code"><pre><span class="line">#8 = Utf8               ()V</span><br></pre></td></tr></tbody></table></figure><p>表示的是无参无返回值。<code>00 01 -&gt; 1</code>表示有一个方法属性的个数为 1。</p><p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/images/2020/08/08/10890.png" alt="Method_info.attribute_info"></p><p>根据 attribute_info 结构继续从<a href="#.class">Class</a>文件中取出<code>00 09 00 00 00 2F</code> 。<code>00 09 -&gt; 9</code>表示方法属性名称（attribute_name_index）指向常量池 #9 常量</p><figure class="highlight"><table><tbody><tr><td class="code"><pre><span class="line">#9 = Utf8               Code</span><br></pre></td></tr></tbody></table></figure><p><code>00 00 00 2F -&gt;</code>表示<code>Code</code>属性的长度为 47 个字节。（特别特别需要注意这47个字节从Code属性表中第三个开始也就是max_stack开始，因为此 attribute_info为 Code_attribute 本身，attribute_name_index 和 attribute_length 为 Code 的属性）。</p><p>Code_attribute属性表结构如下：</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">Code_attribute {</span><br><span class="line">    u2 attribute_name_index; <span class="comment">// 属性名索引，常量值固定为"Code"</span></span><br><span class="line">    u4 attribute_length;  <span class="comment">//属性值长度，值为整个表的长度减去6个字节(attribute_name_index + attribute_length)</span></span><br><span class="line">    u2 max_stack; <span class="comment">//操作数栈深度最大值</span></span><br><span class="line">    u2 max_locals; <span class="comment">//局部变量表所需的存储空间，单位为"Slot"，Slot是虚拟机为局部变量分配内存所使用的最小的单位。</span></span><br><span class="line">    u4 code_length; <span class="comment">// 存储Java源程序编译后生成的字节码指令，每个指令为u1类型的单字节。虚拟机规范中明确限制了一个方法不允许超过65535条字节指令，实际上只用了u2长度。</span></span><br><span class="line">    u1 code[code_length]; <span class="comment">// 方法指向的具体指令码</span></span><br><span class="line">    u2 exception_table_length; <span class="comment">// 异常表的个数</span></span><br><span class="line">    {   u2 start_pc; <span class="comment">// start_pc 和 end_pc 表示在 Code 数组中的[start_pc, end_pc)处指令所抛出的异常由这个表处理。</span></span><br><span class="line">        u2 end_pc;</span><br><span class="line">        u2 handler_pc; <span class="comment">// 异常代码的开始处</span></span><br><span class="line">        u2 catch_type; <span class="comment">// 表示被处理流程的异常类型，指向常量池中具体的某一个异常类，catchType为 0 处理所有的异常</span></span><br><span class="line">    } exception_table[exception_table_length]; <span class="comment">// 异常表结构，用于存放异常信息</span></span><br><span class="line">    u2 attributes_count; <span class="comment">// 属性的个数</span></span><br><span class="line">    attribute_info attributes[attributes_count]; <span class="comment">// 属性的集合</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>第一个 Code 的汇编代码如下：</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">         <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">7</span>: <span class="number">0</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">5</span>     <span class="number">0</span>  <span class="keyword">this</span>   Ltech/techstack/blog/ByteCode;</span><br></pre></td></tr></tbody></table></figure><blockquote><p>Tips: args_size=1是因为在任何实例方法里面，都可以通过"this"关键字访问到此方法所属的对象。这个访问机制对Java程序的编写很重要，而它的实现却非常简单，仅仅是通过Javac编译器编译的时候把对this关键字的访问转变为对一个普通方法参数的访问，然后在虚拟机调用实例方法时自动传入此参数而已。因此在实例方法的局部变量表中至少会存在一个指向当前对象实例的局部变量，局部变量表中也会预留出第一个Slot位来存放对象实例的引用，方法参数值从1开始计算。</p></blockquote><p>回到示例代码，取出 47 位 Code 值：</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// _ 是本文自行添加方便表示数据项之间的间隔，Class 文件中是不存在的</span></span><br><span class="line"><span class="number">00</span> <span class="number">01</span>  _00 <span class="number">01</span> _00 <span class="number">00</span> <span class="number">00</span> <span class="number">05</span>  _2A B7 <span class="number">00</span> <span class="number">01</span> B1 _00 <span class="number">00</span>  _00 <span class="number">02</span>  _00 0A  _00 <span class="number">00</span> <span class="number">00</span> <span class="number">06</span>  _00 <span class="number">01</span>  _00 <span class="number">00</span>  _00 <span class="number">06</span>  _00 0B  _00 <span class="number">00</span> <span class="number">00</span> 0C  _00 <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">05</span> <span class="number">00</span> 0C <span class="number">00</span> <span class="number">0D</span> <span class="number">00</span> <span class="number">00</span></span><br></pre></td></tr></tbody></table></figure><p><code>00 01 -&gt; 1</code> 表示 操作数栈（max_stack）的最大深度为 1。后面的<code>00 01 -&gt; 1</code>表示局部变量表的长度(max_locals)为 1，正好与 Code 的汇编代码<code>stack=1</code> <code>locals=1</code>对应。紧接着后面 4 位<code>00 00 00 05 -&gt; 5</code>表示字节码指令长度（code_length）为 5。继续往后数 5 位<code>2A B7 00 01 B1</code>表示 JVM具体的字节码指令。</p><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">0: aload_0</span><br><span class="line">1: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">4: return</span><br></pre></td></tr></tbody></table></figure><blockquote><ol><li><p><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.aload_n">0x2A</a>:对应的字节码注记符是<code>aload_0</code>,作用就是把当前调用方法的栈帧中的局部变量表索引位置为0的局部变量推送到操作数栈的栈顶。</p></li><li><p><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.invokespecial">0xB7</a>:表示是 invokespecial 调用父类的方法 那么后面需要接入二个字节表示调用哪个方法，所以<code>00 01</code>表示的是指向常量池中第一个位置为为如下结构</p><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">1: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V</span><br></pre></td></tr></tbody></table></figure></li><li><p><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.return">0xB1</a>:对应的字节码指令值<code>retrun</code> `表示retrun void from method。</p></li></ol></blockquote><p><code>00 00</code>表示异常表个数（exception_table_length）为 0，方法没有抛出异常。</p><p><code>00 02 -&gt; 2</code>表示 Code_attribute 结构中属性表的个数为 2 个。<code>00 0A -&gt; 10</code>表示 attribute_name_index 指向常量池 #10 <code>LineNumberTable</code> 常量。继续后面 4 位<code>00 00 00 06 -&gt; 10</code> 表示 attribute_length 即 LineNumberTable 的长度。LineNumberTable 是用来描述Java源码行号与字节码行号（字节码偏移量）之间的对应关系，比如我们平时 debug 某一行代码。其结构如下所示：</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">LineNumberTable_attribute {</span><br><span class="line">    u2 attribute_name_index;</span><br><span class="line">    u4 attribute_length;</span><br><span class="line">    u2 line_number_table_length;</span><br><span class="line">    {   u2 start_pc;</span><br><span class="line">        u2 line_number;	</span><br><span class="line">    } line_number_table[line_number_table_length];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>00 01 -&gt; 1</code>表示行号表的个数为 1，即只存在一个行号表。<code>00 00</code> 表示start_pc为字节码行号，<code>00 06 -&gt; 6</code>表示源码行号为第 7(6+1) 行。</p><p><code>00 0B -&gt; 11</code>表示第二个属性表对应常量池 #11 <code>LocalVariableTable</code> 常量。<code>00 00 00 0C -&gt; 12</code> 表示 <code>LocalVariableTable</code> 常量的长度为 12。LocalVariableTable 属性用于描述栈帧中局部变量表中的变量与Java源码中定义的变量之间的关系。其结构如下：</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">LocalVariableTable_attribute {</span><br><span class="line">    u2 attribute_name_index;</span><br><span class="line">    u4 attribute_length;</span><br><span class="line">    u2 local_variable_table_length;</span><br><span class="line">    {   u2 start_pc;</span><br><span class="line">        u2 length;</span><br><span class="line">        u2 name_index;</span><br><span class="line">        u2 descriptor_index;</span><br><span class="line">        u2 index;</span><br><span class="line">    } local_variable_table[local_variable_table_length];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>LocalVariableTable也不是运行时必需的属性，但默认会生成到Class文件之中，可以在Javac中分别使用<code>-g:none</code>或<code>-g:vars</code>选项来取消或要求生成这项信息。如果没有生成这项属性，最大的影响就是当其他人引用这个方法时，所有的参数名称都将会丢失，IDE将会使用诸如arg0、arg1之类的占位符代替原有的参数名，这对程序运行没有影响，但是会对代码编写带来较大不便，而且在调试期间无法根据参数名称从上下文中获得参数值。</p><p><code>00 01 -&gt; 1</code>表示本地变量表的个数 local_variable_table_length 为 1。<code>00 00</code>表示local_variable_table 的 start_pc 为 0，其含义为这个局部变量的生命周期开始的字节码偏移量。<code>00 05 -&gt; 5</code> 表示 local_variable_table 的 length 为 5，其含义为这个局部变量作用范围覆盖的长度。两者结合起来就是这个局部变量在字节码之中的作用域范围。<code>00 0C</code> <code>00 0D</code>分别表示 name_index 和 descriptor_index，分别指向常量池中 #12 <code>this</code> 和 #13 <code>Ltech/techstack/blog/ByteCode;</code>常量。分别代表了局部变量的名称以及这个局部变量的描述符。<code>00 00</code> 表示了这个变量在本地变量表中的index 即这个局部变量在栈帧局部变量表中Slot的位置。当这个变量数据类型是64位类型时（double和long），它占用的Slot为index和index+1两个。</p><h4 id="attributes-count-attributes">attributes_count &amp; attributes[]<a href="#attributes-count-attributes"></a></h4><p>属性表（attribute_info）用于描述某些场景专有的信息。在Class文件、字段表、方法表都可以携带自己的属性表集合。所有的属性都具有一下常规格式：</p><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">attribute_info { </span><br><span class="line">    u2 attribute_name_index; </span><br><span class="line">    u4 attribute_length; </span><br><span class="line">    u1 info [attribute_length]; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>根据<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/index.html">The Java® Virtual Machine Specification</a>已经增加到了 23 项。根据其用途可以分为三组：</p><ol><li><p>五个属性对于<code>class</code>Java虚拟机正确解释文件至关重要 ：</p><ul><li><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.7.2">ConstantValue</a></li><li><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.7.3">Code</a></li><li><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.7.4">StackMapTable</a></li><li><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.7.5">Exceptions</a></li><li><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.7.23">BootstrapMethods</a></li></ul></li><li><p>十二个属性对于Java SE平台的类库正确解释<code>class</code>文件至关重要 ：</p><ul><li><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.7.6">InnerClasses</a></li><li><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.7.7">EnclosingMethod</a></li><li><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.7.8">Synthetic</a></li><li><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.7.9">Signature</a></li><li><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.7.16">RuntimeVisibleAnnotations</a></li><li><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.7.17">RuntimeInvisibleAnnotations</a></li><li><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.7.18">RuntimeVisibleParameterAnnotations</a></li><li><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.7.19">RuntimeInvisibleParameterAnnotations</a></li><li><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.7.20">RuntimeVisibleTypeAnnotations</a></li><li><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.7.21">RuntimeInvisibleTypeAnnotations</a></li><li><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.7.22">AnnotationDefault</a></li><li><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.7.24">MethodParameters</a></li></ul></li><li><p>六个属性对于classJava虚拟机或Java SE平台的类库对文件的正确解释不是至关重要的 ，但对于工具来说非常有用：</p><ul><li><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.7.10">SourceFile</a></li><li><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.7.11">SourceDebugExtension</a></li><li><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.7.12">LineNumberTable</a></li><li><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.7.13">LocalVariableTable</a></li><li><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.7.14">LocalVariableTypeTable</a></li><li><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.7.15">Deprecated</a></li></ul></li></ol><h5 id="属性汇总">属性汇总<a href="#属性汇总"></a></h5><p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/images/2020/08/09/image-20200809013940538.png" alt="按文件位置排序预定义属性"></p><p>参考：</p><p>[1] 周志明.深入理解Java虚拟机：JVM高级特性与最佳实践.北京:机械工业出版社,2013.</p><p>[2] <a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4">Chapter 4. Th class File Format</a></p><p>[3] <a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5">Chapter 6. The Java Virtual Machine Instruction Set</a></p><script>document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });</script></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">陈建源</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://www.techstack.tech/post/164885506/">https://www.techstack.tech/post/164885506/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://www.techstack.tech" target="_blank">陈建源的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a><a class="post-meta__tags" href="/tags/JVM/">JVM</a></div><div class="post_share"><div class="social-share" data-image="/img/avatar.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/reward/wechat.jpeg" target="_blank"><img class="post-qr-code-img" src="/img/reward/wechat.jpeg" alt="wechat"></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/reward/alipay.jpeg" target="_blank"><img class="post-qr-code-img" src="/img/reward/alipay.jpeg" alt="alipay"></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/post/164885508/"><img class="prev-cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">类加载过程</div></div></a></div><div class="next-post pull-right"><a href="/post/159683533/"><img class="next-cover" src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/images/2020/08/08/JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.png" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">JVM内存结构</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/post/159683533/" title="JVM内存结构"><img class="cover" src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/images/2020/08/08/JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-08-08</div><div class="title">JVM内存结构</div></div></a></div><div><a href="/post/164885508/" title="类加载过程"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-08-14</div><div class="title">类加载过程</div></div></a></div><div><a href="/post/164885504/" title="从源码角度理解类加载器"><img class="cover" src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/images/2020/08/20/image-20200820173314832.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-08-21</div><div class="title">从源码角度理解类加载器</div></div></a></div><div><a href="/post/164885507/" title="对象的创建与死亡以及内存分配、回收机制"><img class="cover" src="https://cdn.jsdelivr.net/gh/yuanjianchen/static@master/uPic/images/2020/09/07/image-20200907160940185.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-09-09</div><div class="title">对象的创建与死亡以及内存分配、回收机制</div></div></a></div><div><a href="/post/164885659/" title="Feign Api返回值为void时获取 Response信息"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-08-17</div><div class="title">Feign Api返回值为void时获取 Response信息</div></div></a></div><div><a href="/post/164885509/" title="原码、补码、反码"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-08-03</div><div class="title">原码、补码、反码</div></div></a></div></div></div><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.png" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">陈建源</div><div class="author-info__description">过着平凡的生活，享受着简单的人生</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">55</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a></div><div class="card-info-data-item is-center"><a href="/m/"><div class="headline">分类</div><div class="length-num">11</div></a></div></div><a class="button--animated" id="card-info-btn" href="https://github.com/yuanjianchen"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/yuanjianchen" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:jianyuan.c@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="tencent://message/?uin=1752133445&amp;Site=&amp;Menu=yes" target="_blank" title="QQ"><i class="fab fa-qq"></i></a><a class="social-icon" href="/img/wechat.jpg" target="_blank" title="WeChat"><i class="fab fa-weixin"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Class-%E7%B1%BB%E6%96%87%E4%BB%B6%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-text">Class 类文件的结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Class-%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84"><span class="toc-text">Class 文件结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#magic"><span class="toc-text">magic</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#minor-version-major-version"><span class="toc-text">minor_version &amp; major_version</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#constant-pool-count-constant-pool"><span class="toc-text">constant_pool_count &amp; constant_pool[]</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#access-flags"><span class="toc-text">access_flags</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#this-class-super-class-interfaces-count-interfaces"><span class="toc-text">this_class &amp; super_class &amp;interfaces_count &amp; interfaces[]</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#fields-count-fields"><span class="toc-text">fields_count &amp; fields[]</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#methods-count-methods"><span class="toc-text">methods_count &amp; methods[]</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#attributes-count-attributes"><span class="toc-text">attributes_count &amp; attributes[]</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E6%B1%87%E6%80%BB"><span class="toc-text">属性汇总</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/165052629/" title="深入理解Volatile">深入理解Volatile</a><time datetime="2022-04-21T07:31:28.000Z" title="发表于 2022-04-21 15:31:28">2022-04-21</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/165052618/" title="并发理论接触：内存屏障">并发理论接触：内存屏障</a><time datetime="2022-04-21T07:29:30.000Z" title="发表于 2022-04-21 15:29:30">2022-04-21</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/164995635/" title="并发理论基础：Java 内存模型JMM">并发理论基础：Java 内存模型JMM</a><time datetime="2022-04-14T17:12:29.000Z" title="发表于 2022-04-15 01:12:29">2022-04-15</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/164942290/" title="并发理论基础：指令重排序问题">并发理论基础：指令重排序问题</a><time datetime="2022-04-08T13:01:28.000Z" title="发表于 2022-04-08 21:01:28">2022-04-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/164926797/" title="并发理论基础：缓存可见性、MESI">并发理论基础：缓存可见性、MESI</a><time datetime="2022-04-06T17:59:31.000Z" title="发表于 2022-04-07 01:59:31">2022-04-07</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/164913260/" title="并发理论基础：原子性问题">并发理论基础：原子性问题</a><time datetime="2022-04-05T03:25:31.000Z" title="发表于 2022-04-05 11:25:31">2022-04-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/164912916/" title="并发理论基础：并发与并行">并发理论基础：并发与并行</a><time datetime="2022-04-05T03:25:31.000Z" title="发表于 2022-04-05 11:25:31">2022-04-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/164912852/" title="并发理论基础：并发问题产生的三大根源">并发理论基础：并发问题产生的三大根源</a><time datetime="2022-04-05T03:15:11.000Z" title="发表于 2022-04-05 11:15:11">2022-04-05</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By 陈建源</div><div class="framework-info"><span>框架 </span><a href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text"><span><a href="http://www.beian.miit.gov.cn"><img class="icp-icon" src="/img/icp.png"><span>备案号：京ICP备17031811号-1</span></a> | 本网站由<a href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral" target="_blank"><img src="/img/又拍云_logo6.png" class="youpai-logo"></a>提供CDN加速/云储存服务</span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div></div><hr><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'M1Fb2kAISrjFNkvAaWci9NrJ-gzGzoHsz',
      appKey: 'q4sEVnF9Minjscuva66D0auY',
      placeholder: 'Please leave your footprints',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'zh-CN',
      recordIP: true,
      serverURLs: 'https://m1fb2kai.lc-cn-n1-shared.com',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: true,
      path: window.location.pathname,
      requiredFields: ["nick,mail"],
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script defer id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>